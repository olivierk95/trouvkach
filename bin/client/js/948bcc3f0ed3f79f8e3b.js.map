{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setDifference.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setIntersect.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setSymDifference.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setCartesian.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setDistinct.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setIsSubset.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setMultiplicity.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setPowerset.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setSize.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/set/setUnion.js"],"names":["flatten","__webpack_require__","identify","generalize","exports","name","factory","type","config","load","typed","MatrixIndex","DenseMatrix","size","subset","compareNatural","Array | Matrix, Array | Matrix","a1","a2","result","toArray","inb2","b1","Array","isArray","sort","b2","i","length","j","value","identifier","push","concat","setDifference","Array | Matrix","a","b","number | BigNumber | Fraction | Complex, Array | Matrix","e","count","number","toString","_subset","split","reverse","array","temp","_sort","bitarray","Array | Matrix, boolean","unique","setIntersect","setSymDifference"],"mappings":"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","file":"js/948bcc3f0ed3f79f8e3b.js","sourcesContent":["'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nvar identify = require('../../utils/array').identify;\n\nvar generalize = require('../../utils/array').generalize;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var DenseMatrix = load(require('../../type/matrix/DenseMatrix'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Create the difference of two (multi)sets: every element of set1, that is not the element of set2.\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setDifference(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2]\n   *    math.setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2]\n   *\n   * See also:\n   *\n   *    setUnion, setIntersect, setSymDifference\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {Array | Matrix}    The difference of two (multi)sets\n   */\n\n  var setDifference = typed('setDifference', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      var result;\n\n      if (subset(size(a1), new MatrixIndex(0)) === 0) {\n        // empty-anything=empty\n        result = [];\n      } else if (subset(size(a2), new MatrixIndex(0)) === 0) {\n        // anything-empty=anything\n        return flatten(a1.toArray());\n      } else {\n        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));\n        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));\n        result = [];\n        var inb2;\n\n        for (var i = 0; i < b1.length; i++) {\n          inb2 = false;\n\n          for (var j = 0; j < b2.length; j++) {\n            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {\n              // the identifier is always a decimal int\n              inb2 = true;\n              break;\n            }\n          }\n\n          if (!inb2) {\n            result.push(b1[i]);\n          }\n        }\n      } // return an array, if both inputs were arrays\n\n\n      if (Array.isArray(a1) && Array.isArray(a2)) {\n        return generalize(result);\n      } // return a matrix otherwise\n\n\n      return new DenseMatrix(generalize(result));\n    }\n  });\n  return setDifference;\n}\n\nexports.name = 'setDifference';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nvar identify = require('../../utils/array').identify;\n\nvar generalize = require('../../utils/array').generalize;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var DenseMatrix = load(require('../../type/matrix/DenseMatrix'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Create the intersection of two (multi)sets.\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setIntersect(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setIntersect([1, 2, 3, 4], [3, 4, 5, 6])            // returns [3, 4]\n   *    math.setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [3, 4]\n   *\n   * See also:\n   *\n   *    setUnion, setDifference\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {Array | Matrix}    The intersection of two (multi)sets\n   */\n\n  var setIntersect = typed('setIntersect', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      var result;\n\n      if (subset(size(a1), new MatrixIndex(0)) === 0 || subset(size(a2), new MatrixIndex(0)) === 0) {\n        // of any of them is empty, return empty\n        result = [];\n      } else {\n        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));\n        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));\n        result = [];\n\n        for (var i = 0; i < b1.length; i++) {\n          for (var j = 0; j < b2.length; j++) {\n            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {\n              // the identifier is always a decimal int\n              result.push(b1[i]);\n              break;\n            }\n          }\n        }\n      } // return an array, if both inputs were arrays\n\n\n      if (Array.isArray(a1) && Array.isArray(a2)) {\n        return generalize(result);\n      } // return a matrix otherwise\n\n\n      return new DenseMatrix(generalize(result));\n    }\n  });\n  return setIntersect;\n}\n\nexports.name = 'setIntersect';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var concat = load(require('../matrix/concat'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var setDifference = load(require('../set/setDifference'));\n  /**\n   * Create the symmetric difference of two (multi)sets.\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setSymDifference(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 5, 6]\n   *    math.setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 5, 6]\n   *\n   * See also:\n   *\n   *    setUnion, setIntersect, setDifference\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {Array | Matrix}    The symmetric difference of two (multi)sets\n   */\n\n  var setSymDifference = typed('setSymDifference', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      if (subset(size(a1), new MatrixIndex(0)) === 0) {\n        // if any of them is empty, return the other one\n        return flatten(a2);\n      } else if (subset(size(a2), new MatrixIndex(0)) === 0) {\n        return flatten(a1);\n      }\n\n      var b1 = flatten(a1);\n      var b2 = flatten(a2);\n      return concat(setDifference(b1, b2), setDifference(b2, b1));\n    }\n  });\n  return setSymDifference;\n}\n\nexports.name = 'setSymDifference';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var DenseMatrix = load(require('../../type/matrix/DenseMatrix'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Create the cartesian product of two (multi)sets.\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setCartesian(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setCartesian([1, 2], [3, 4])        // returns [[1, 3], [1, 4], [2, 3], [2, 4]]\n   *\n   * See also:\n   *\n   *    setUnion, setIntersect, setDifference, setPowerset\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {Array | Matrix}    The cartesian product of two (multi)sets\n   */\n\n  var setCartesian = typed('setCartesian', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      var result = [];\n\n      if (subset(size(a1), new MatrixIndex(0)) !== 0 && subset(size(a2), new MatrixIndex(0)) !== 0) {\n        // if any of them is empty, return empty\n        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);\n        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);\n        result = [];\n\n        for (var i = 0; i < b1.length; i++) {\n          for (var j = 0; j < b2.length; j++) {\n            result.push([b1[i], b2[j]]);\n          }\n        }\n      } // return an array, if both inputs were arrays\n\n\n      if (Array.isArray(a1) && Array.isArray(a2)) {\n        return result;\n      } // return a matrix otherwise\n\n\n      return new DenseMatrix(result);\n    }\n  });\n  return setCartesian;\n}\n\nexports.name = 'setCartesian';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var DenseMatrix = load(require('../../type/matrix/DenseMatrix'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Collect the distinct elements of a multiset.\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setDistinct(set)\n   *\n   * Examples:\n   *\n   *    math.setDistinct([1, 1, 1, 2, 2, 3])        // returns [1, 2, 3]\n   *\n   * See also:\n   *\n   *    setMultiplicity\n   *\n   * @param {Array | Matrix}    a  A multiset\n   * @return {Array | Matrix}    A set containing the distinc elements of the multiset\n   */\n\n  var setDistinct = typed('setDistinct', {\n    'Array | Matrix': function ArrayMatrix(a) {\n      var result;\n\n      if (subset(size(a), new MatrixIndex(0)) === 0) {\n        // if empty, return empty\n        result = [];\n      } else {\n        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n        result = [];\n        result.push(b[0]);\n\n        for (var i = 1; i < b.length; i++) {\n          if (compareNatural(b[i], b[i - 1]) !== 0) {\n            result.push(b[i]);\n          }\n        }\n      } // return an array, if the input was an array\n\n\n      if (Array.isArray(a)) {\n        return result;\n      } // return a matrix otherwise\n\n\n      return new DenseMatrix(result);\n    }\n  });\n  return setDistinct;\n}\n\nexports.name = 'setDistinct';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nvar identify = require('../../utils/array').identify;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Check whether a (multi)set is a subset of another (multi)set. (Every element of set1 is the element of set2.)\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setIsSubset(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setIsSubset([1, 2], [3, 4, 5, 6])        // returns false\n   *    math.setIsSubset([3, 4], [3, 4, 5, 6])        // returns true\n   *\n   * See also:\n   *\n   *    setUnion, setIntersect, setDifference\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {boolean}            true | false\n   */\n\n  var setIsSubset = typed('setIsSubset', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      if (subset(size(a1), new MatrixIndex(0)) === 0) {\n        // empty is a subset of anything\n        return true;\n      } else if (subset(size(a2), new MatrixIndex(0)) === 0) {\n        // anything is not a subset of empty\n        return false;\n      }\n\n      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));\n      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));\n      var inb2;\n\n      for (var i = 0; i < b1.length; i++) {\n        inb2 = false;\n\n        for (var j = 0; j < b2.length; j++) {\n          if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {\n            // the identifier is always a decimal int\n            inb2 = true;\n            break;\n          }\n        }\n\n        if (inb2 === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  });\n  return setIsSubset;\n}\n\nexports.name = 'setIsSubset';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var compareNatural = load(require('../relational/compareNatural'));\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  /**\n   * Count the multiplicity of an element in a multiset.\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setMultiplicity(element, set)\n   *\n   * Examples:\n   *\n   *    math.setMultiplicity(1, [1, 2, 2, 4])    // returns 1\n   *    math.setMultiplicity(2, [1, 2, 2, 4])    // returns 2\n   *\n   * See also:\n   *\n   *    setDistinct, setSize\n   *\n   * @param {number | BigNumber | Fraction | Complex} e  An element in the multiset\n   * @param {Array | Matrix}     a  A multiset\n   * @return {number}            The number of how many times the multiset contains the element\n   */\n\n  var setMultiplicity = typed('setMultiplicity', {\n    'number | BigNumber | Fraction | Complex, Array | Matrix': function numberBigNumberFractionComplexArrayMatrix(e, a) {\n      if (subset(size(a), new MatrixIndex(0)) === 0) {\n        // if empty, return 0\n        return 0;\n      }\n\n      var b = flatten(Array.isArray(a) ? a : a.toArray());\n      var count = 0;\n\n      for (var i = 0; i < b.length; i++) {\n        if (compareNatural(b[i], e) === 0) {\n          count++;\n        }\n      }\n\n      return count;\n    }\n  });\n  return setMultiplicity;\n}\n\nexports.name = 'setMultiplicity';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setPowerset(set)\n   *\n   * Examples:\n   *\n   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n   *\n   * See also:\n   *\n   *    setCartesian\n   *\n   * @param {Array | Matrix}    a  A (multi)set\n   * @return {Array}    The powerset of the (multi)set\n   */\n\n  var setPowerset = typed('setPowerset', {\n    'Array | Matrix': function ArrayMatrix(a) {\n      if (subset(size(a), new MatrixIndex(0)) === 0) {\n        // if empty, return empty\n        return [];\n      }\n\n      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n      var result = [];\n      var number = 0;\n\n      while (number.toString(2).length <= b.length) {\n        result.push(_subset(b, number.toString(2).split('').reverse()));\n        number++;\n      } // can not return a matrix, because of the different size of the subarrays\n\n\n      return _sort(result);\n    }\n  });\n  return setPowerset; // create subset\n\n  function _subset(array, bitarray) {\n    var result = [];\n\n    for (var i = 0; i < bitarray.length; i++) {\n      if (bitarray[i] === '1') {\n        result.push(array[i]);\n      }\n    }\n\n    return result;\n  } // sort subsests by length\n\n\n  function _sort(array) {\n    var temp = [];\n\n    for (var i = array.length - 1; i > 0; i--) {\n      for (var j = 0; j < i; j++) {\n        if (array[j].length > array[j + 1].length) {\n          temp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = temp;\n        }\n      }\n    }\n\n    return array;\n  }\n}\n\nexports.name = 'setPowerset';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Count the number of elements of a (multi)set. When a second parameter is 'true', count only the unique values.\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setSize(set)\n   *    math.setSize(set, unique)\n   *\n   * Examples:\n   *\n   *    math.setSize([1, 2, 2, 4])          // returns 4\n   *    math.setSize([1, 2, 2, 4], true)    // returns 3\n   *\n   * See also:\n   *\n   *    setUnion, setIntersect, setDifference\n   *\n   * @param {Array | Matrix}    a  A multiset\n   * @return {number}            The number of elements of the (multi)set\n   */\n\n  var setSize = typed('setSize', {\n    'Array | Matrix': function ArrayMatrix(a) {\n      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;\n    },\n    'Array | Matrix, boolean': function ArrayMatrixBoolean(a, unique) {\n      if (unique === false || a.length === 0) {\n        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;\n      } else {\n        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n        var count = 1;\n\n        for (var i = 1; i < b.length; i++) {\n          if (compareNatural(b[i], b[i - 1]) !== 0) {\n            count++;\n          }\n        }\n\n        return count;\n      }\n    }\n  });\n  return setSize;\n}\n\nexports.name = 'setSize';\nexports.factory = factory;","'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var MatrixIndex = load(require('../../type/matrix/MatrixIndex'));\n  var concat = load(require('../matrix/concat'));\n  var size = load(require('../matrix/size'));\n  var subset = load(require('../matrix/subset'));\n  var setIntersect = load(require('../set/setIntersect'));\n  var setSymDifference = load(require('../set/setSymDifference'));\n  /**\n   * Create the union of two (multi)sets.\n   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setUnion(set1, set2)\n   *\n   * Examples:\n   *\n   *    math.setUnion([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 3, 4, 5, 6]\n   *    math.setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 3, 4, 5, 6]\n   *\n   * See also:\n   *\n   *    setIntersect, setDifference\n   *\n   * @param {Array | Matrix}    a1  A (multi)set\n   * @param {Array | Matrix}    a2  A (multi)set\n   * @return {Array | Matrix}    The union of two (multi)sets\n   */\n\n  var setUnion = typed('setUnion', {\n    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {\n      if (subset(size(a1), new MatrixIndex(0)) === 0) {\n        // if any of them is empty, return the other one\n        return flatten(a2);\n      } else if (subset(size(a2), new MatrixIndex(0)) === 0) {\n        return flatten(a1);\n      }\n\n      var b1 = flatten(a1);\n      var b2 = flatten(a2);\n      return concat(setSymDifference(b1, b2), setIntersect(b1, b2));\n    }\n  });\n  return setUnion;\n}\n\nexports.name = 'setUnion';\nexports.factory = factory;"],"sourceRoot":""}