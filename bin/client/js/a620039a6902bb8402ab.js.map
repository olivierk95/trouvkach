{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csFkeep.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csEtree.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csCounts.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csLeaf.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csLu.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csDfs.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csIpvec.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csFlip.js"],"names":["exports","name","path","factory","a","callback","other","avalues","_values","aindex","_index","aptr","_ptr","n","_size","nz","j","p","splice","length","ata","i","inext","asize","m","parent","w","prev","k","p0","p1","r","type","config","load","transpose","__webpack_require__","csLeaf","post","J","s","maxfirst","prevleaf","first","head","next","colcount","at","tindex","tptr","Math","min","jleaf","q","ancestor","sparent","jprev","abs","divideScalar","multiply","larger","largerEq","csSpsolve","SparseMatrix","tol","lnz","unz","lvalues","lindex","lptr","L","values","index","ptr","size","uvalues","uindex","uptr","U","pinv","x","xi","col","top","ipiv","xabs","pivot","csMarked","csMark","csUnflip","g","p2","jnew","done","b"],"mappings":"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","file":"js/a620039a6902bb8402ab.js","sourcesContent":["'use strict';\n\nfunction factory() {\n  /**\n   * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise\n   *\n   * @param {Matrix}   a              The sparse matrix\n   * @param {function} callback       The callback function, function will be invoked with the following args:\n   *                                    - The entry row\n   *                                    - The entry column\n   *                                    - The entry value\n   *                                    - The state parameter\n   * @param {any}      other          The state\n   *\n   * @return                          The number of nonzero elements in the matrix\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csFkeep = function csFkeep(a, callback, other) {\n    // a arrays\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // nonzero items\n\n    var nz = 0; // loop columns\n\n    for (var j = 0; j < n; j++) {\n      // get current location of col j\n      var p = aptr[j]; // record new location of col j\n\n      aptr[j] = nz;\n\n      for (; p < aptr[j + 1]; p++) {\n        // check we need to keep this item\n        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {\n          // keep A(i,j)\n          aindex[nz] = aindex[p]; // check we need to process values (pattern only)\n\n          if (avalues) {\n            avalues[nz] = avalues[p];\n          } // increment nonzero items\n\n\n          nz++;\n        }\n      }\n    } // finalize A\n\n\n    aptr[n] = nz; // trim arrays\n\n    aindex.splice(nz, aindex.length - nz); // check we need to process values (pattern only)\n\n    if (avalues) {\n      avalues.splice(nz, avalues.length - nz);\n    } // return number of nonzero items\n\n\n    return nz;\n  };\n\n  return csFkeep;\n}\n\nexports.name = 'csFkeep';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory() {\n  /**\n   * Computes the elimination tree of Matrix A (using triu(A)) or the\n   * elimination tree of A'A without forming A'A.\n   *\n   * @param {Matrix}  a               The A Matrix\n   * @param {boolean} ata             A value of true the function computes the etree of A'A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csEtree = function csEtree(a, ata) {\n    // check inputs\n    if (!a) {\n      return null;\n    } // a arrays\n\n\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // allocate result\n\n    var parent = []; // (n)\n    // allocate workspace\n\n    var w = []; // (n + (ata ? m : 0))\n\n    var ancestor = 0; // first n entries in w\n\n    var prev = n; // last m entries (ata = true)\n\n    var i, inext; // check we are calculating A'A\n\n    if (ata) {\n      // initialize workspace\n      for (i = 0; i < m; i++) {\n        w[prev + i] = -1;\n      }\n    } // loop columns\n\n\n    for (var k = 0; k < n; k++) {\n      // node k has no parent yet\n      parent[k] = -1; // nor does k have an ancestor\n\n      w[ancestor + k] = -1; // values in column k\n\n      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // row\n        var r = aindex[p]; // node\n\n        i = ata ? w[prev + r] : r; // traverse from i to k\n\n        for (; i !== -1 && i < k; i = inext) {\n          // inext = ancestor of i\n          inext = w[ancestor + i]; // path compression\n\n          w[ancestor + i] = k; // check no anc., parent is k\n\n          if (inext === -1) {\n            parent[i] = k;\n          }\n        }\n\n        if (ata) {\n          w[prev + r] = k;\n        }\n      }\n    }\n\n    return parent;\n  };\n\n  return csEtree;\n}\n\nexports.name = 'csEtree';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var transpose = load(require('../../matrix/transpose'));\n  var csLeaf = load(require('./csLeaf'));\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csCounts = function csCounts(a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n\n  return csCounts;\n}\n\nexports.name = 'csCounts';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory() {\n  /**\n   * This function determines if j is a leaf of the ith row subtree.\n   * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\n   *\n   * @param {Number}  i               The ith row subtree\n   * @param {Number}  j               The node to test\n   * @param {Array}   w               The workspace array\n   * @param {Number}  first           The index offset within the workspace for the first array\n   * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\n   * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\n   * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\n   *\n   * @return {Object}\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csLeaf = function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n    var s, sparent, jprev; // our result\n\n    var jleaf = 0;\n    var q; // check j is a leaf\n\n    if (i <= j || w[first + j] <= w[maxfirst + i]) {\n      return -1;\n    } // update max first[j] seen so far\n\n\n    w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\n\n    jprev = w[prevleaf + i];\n    w[prevleaf + i] = j; // check j is first or subsequent leaf\n\n    if (jprev === -1) {\n      // 1st leaf, q = root of ith subtree\n      jleaf = 1;\n      q = i;\n    } else {\n      // update jleaf\n      jleaf = 2; // q = least common ancester (jprev,j)\n\n      for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\n        ;\n      }\n\n      for (s = jprev; s !== q; s = sparent) {\n        // path compression\n        sparent = w[ancestor + s];\n        w[ancestor + s] = q;\n      }\n    }\n\n    return {\n      jleaf: jleaf,\n      q: q\n    };\n  };\n\n  return csLeaf;\n}\n\nexports.name = 'csLeaf';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var abs = load(require('../../arithmetic/abs'));\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiply = load(require('../../arithmetic/multiply'));\n  var larger = load(require('../../relational/larger'));\n  var largerEq = load(require('../../relational/largerEq'));\n  var csSpsolve = load(require('./csSpsolve'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csLu = function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    } // m arrays\n\n\n    var size = m._size; // columns\n\n    var n = size[1]; // symbolic analysis result\n\n    var q;\n    var lnz = 100;\n    var unz = 100; // update symbolic analysis parameters\n\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    } // L arrays\n\n\n    var lvalues = []; // (lnz)\n\n    var lindex = []; // (lnz)\n\n    var lptr = []; // (n + 1)\n    // L\n\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    }); // U arrays\n\n    var uvalues = []; // (unz)\n\n    var uindex = []; // (unz)\n\n    var uptr = []; // (n + 1)\n    // U\n\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    }); // inverse of permutation vector\n\n    var pinv = []; // (n)\n    // vars\n\n    var i, p; // allocate arrays\n\n    var x = []; // (n)\n\n    var xi = []; // (2 * n)\n    // initialize variables\n\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0; // no rows pivotal yet\n\n      pinv[i] = -1; // no cols of L yet\n\n      lptr[i + 1] = 0;\n    } // reset number of nonzero elements in L and U\n\n\n    lnz = 0;\n    unz = 0; // compute L(:,k) and U(:,k)\n\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz; // apply column permutations if needed\n\n      var col = q ? q[k] : k; // solve triangular system, x = L\\A(:,col)\n\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\n\n      var ipiv = -1;\n      var a = -1; // loop xi[] from top -> n\n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p]; // check row i is not yet pivotal\n\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\n\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      } // validate we found a valid pivot\n\n\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      } // update actual pivot column, give preference to diagonal value\n\n\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      } // the chosen pivot\n\n\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\n\n      uindex[unz] = k;\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\n\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\n\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\n\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p]; // check x(i) is an entry in L(:,k)\n\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i; // scale pivot column\n\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        } // x[0..n-1] = 0 for next k\n\n\n        x[i] = 0;\n      }\n    } // update ptr\n\n\n    lptr[n] = lnz;\n    uptr[n] = unz; // fix row indices of L for final pinv\n\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    } // trim arrays\n\n\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz); // return LU factor\n\n    return {\n      L: L,\n      U: U,\n      pinv: pinv\n    };\n  };\n\n  return csLu;\n}\n\nexports.name = 'csLu';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var csMarked = load(require('./csMarked'));\n  var csMark = load(require('./csMark'));\n  var csUnflip = load(require('./csUnflip'));\n  /**\n   * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\n   * at nodes in B (see csReach()).\n   *\n   * @param {Number}  j               The starting node for the DFS algorithm\n   * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\n   * @param {Number}  top             Start index in stack xi[top..n-1]\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   *\n   * @return {Number}                 New value of top\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csDfs = function csDfs(j, g, top, xi, pinv) {\n    // g arrays\n    var index = g._index;\n    var ptr = g._ptr;\n    var size = g._size; // columns\n\n    var n = size[1]; // vars\n\n    var i, p, p2; // initialize head\n\n    var head = 0; // initialize the recursion stack\n\n    xi[0] = j; // loop\n\n    while (head >= 0) {\n      // get j from the top of the recursion stack\n      j = xi[head]; // apply permutation vector\n\n      var jnew = pinv ? pinv[j] : j; // check node j is marked\n\n      if (!csMarked(ptr, j)) {\n        // mark node j as visited\n        csMark(ptr, j); // update stack (last n entries in xi)\n\n        xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);\n      } // node j done if no unvisited neighbors\n\n\n      var done = 1; // examine all neighbors of j, stack (last n entries in xi)\n\n      for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {\n        // consider neighbor node i\n        i = index[p]; // check we have visited node i, skip it\n\n        if (csMarked(ptr, i)) {\n          continue;\n        } // pause depth-first search of node j, update stack (last n entries in xi)\n\n\n        xi[n + head] = p; // start dfs at node i\n\n        xi[++head] = i; // node j is not done\n\n        done = 0; // break, to start dfs(i)\n\n        break;\n      } // check depth-first search at node j is done\n\n\n      if (done) {\n        // remove j from the recursion stack\n        head--; // and place in the output stack\n\n        xi[--top] = j;\n      }\n    }\n\n    return top;\n  };\n\n  return csDfs;\n}\n\nexports.name = 'csDfs';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory() {\n  /**\n   * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.\n   *\n   * @param {Array} p           The permutation vector of length n. null value denotes identity\n   * @param {Array} b           The input vector\n   *\n   * @return {Array}            The output vector x = P'b\n   */\n  function csIpvec(p, b) {\n    // vars\n    var k;\n    var n = b.length;\n    var x = []; // check permutation vector was provided, p = null denotes identity\n\n    if (p) {\n      // loop vector\n      for (k = 0; k < n; k++) {\n        // apply permutation\n        x[p[k]] = b[k];\n      }\n    } else {\n      // loop vector\n      for (k = 0; k < n; k++) {\n        // x[i] = b[i]\n        x[k] = b[k];\n      }\n    }\n\n    return x;\n  }\n\n  return csIpvec;\n}\n\nexports.name = 'csIpvec';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory() {\n  /**\n   * This function \"flips\" its input about the integer -1.\n   *\n   * @param {Number}  i               The value to flip\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csFlip = function csFlip(i) {\n    // flip the value\n    return -i - 2;\n  };\n\n  return csFlip;\n}\n\nexports.name = 'csFlip';\nexports.path = 'algebra.sparse';\nexports.factory = factory;"],"sourceRoot":""}