{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/lcm.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/log10.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/log1p.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/log2.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/mod.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/arithmetic/log.js"],"names":["isInteger","__webpack_require__","_lcm","a","b","Error","t","prod","Math","abs","exports","name","factory","type","config","load","typed","matrix","algorithm02","algorithm06","algorithm11","algorithm13","algorithm14","lcm","number, number","BigNumber, BigNumber","isInt","isZero","BigNumber","times","mod","div","Fraction, Fraction","x","y","SparseMatrix, SparseMatrix","SparseMatrix, DenseMatrix","DenseMatrix, SparseMatrix","DenseMatrix, DenseMatrix","Array, Array","valueOf","Array, Matrix","Matrix, Array","SparseMatrix, number | BigNumber","DenseMatrix, number | BigNumber","number | BigNumber, SparseMatrix","number | BigNumber, DenseMatrix","Array, number | BigNumber","number | BigNumber, Array","Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber","args","res","i","length","toTex","undefined","deepMap","_log10","log10","log","LN10","number","predictable","Complex","isNegative","toNumber","Array | Matrix","1","divideScalar","log1p","_log1pComplex","plus","ln","any, any","base","xRe1p","re","sqrt","im","atan2","2","log2","LN2","_log2Complex","newX","latex","algorithm03","algorithm05","algorithm12","floor","SparseMatrix, any","DenseMatrix, any","any, SparseMatrix","any, DenseMatrix","Array, any","any, Array","concat","operators"],"mappings":"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","file":"js/b0d882562762eed31d1e.js","sourcesContent":["'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));\n  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));\n  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Calculate the least common multiple for two or more values or arrays.\n   *\n   * lcm is defined as:\n   *\n   *     lcm(a, b) = abs(a * b) / gcd(a, b)\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.lcm(a, b)\n   *    math.lcm(a, b, c, ...)\n   *\n   * Examples:\n   *\n   *    math.lcm(4, 6)               // returns 12\n   *    math.lcm(6, 21)              // returns 42\n   *    math.lcm(6, 21, 5)           // returns 210\n   *\n   *    math.lcm([4, 6], [6, 21])    // returns [12, 42]\n   *\n   * See also:\n   *\n   *    gcd, xgcd\n   *\n   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers\n   * @return {number | BigNumber | Array | Matrix}                           The least common multiple\n   */\n\n  var lcm = typed('lcm', {\n    'number, number': _lcm,\n    'BigNumber, BigNumber': _lcmBigNumber,\n    'Fraction, Fraction': function FractionFraction(x, y) {\n      return x.lcm(y);\n    },\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm06(x, y, lcm);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      return algorithm02(y, x, lcm, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm02(x, y, lcm, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, lcm);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      // use matrix implementation\n      return lcm(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use matrix implementation\n      return lcm(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use matrix implementation\n      return lcm(x, matrix(y));\n    },\n    'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {\n      return algorithm11(x, y, lcm, false);\n    },\n    'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {\n      return algorithm14(x, y, lcm, false);\n    },\n    'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {\n      return algorithm11(y, x, lcm, true);\n    },\n    'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {\n      return algorithm14(y, x, lcm, true);\n    },\n    'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, lcm, false).valueOf();\n    },\n    'number | BigNumber, Array': function numberBigNumberArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, lcm, true).valueOf();\n    },\n    // TODO: need a smarter notation here\n    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {\n      var res = lcm(a, b);\n\n      for (var i = 0; i < args.length; i++) {\n        res = lcm(res, args[i]);\n      }\n\n      return res;\n    }\n  });\n  lcm.toTex = undefined; // use default template\n\n  return lcm;\n  /**\n   * Calculate lcm for two BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @returns {BigNumber} Returns the least common multiple of a and b\n   * @private\n   */\n\n  function _lcmBigNumber(a, b) {\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function lcm must be integer numbers');\n    }\n\n    if (a.isZero() || b.isZero()) {\n      return new type.BigNumber(0);\n    } // http://en.wikipedia.org/wiki/Euclidean_algorithm\n    // evaluate lcm here inline to reduce overhead\n\n\n    var prod = a.times(b);\n\n    while (!b.isZero()) {\n      var t = b;\n      b = a.mod(t);\n      a = t;\n    }\n\n    return prod.div(a).abs();\n  }\n}\n/**\n * Calculate lcm for two numbers\n * @param {number} a\n * @param {number} b\n * @returns {number} Returns the least common multiple of a and b\n * @private\n */\n\n\nfunction _lcm(a, b) {\n  if (!isInteger(a) || !isInteger(b)) {\n    throw new Error('Parameters in function lcm must be integer numbers');\n  }\n\n  if (a === 0 || b === 0) {\n    return 0;\n  } // http://en.wikipedia.org/wiki/Euclidean_algorithm\n  // evaluate lcm here inline to reduce overhead\n\n\n  var t;\n  var prod = a * b;\n\n  while (b !== 0) {\n    t = b;\n    b = a % t;\n    a = t;\n  }\n\n  return Math.abs(prod / a);\n}\n\nexports.name = 'lcm';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log10(x)\n   *\n   * Examples:\n   *\n   *    math.log10(0.00001)            // returns -5\n   *    math.log10(10000)              // returns 4\n   *    math.log(10000) / math.log(10) // returns 4\n   *    math.pow(10, 4)                // returns 10000\n   *\n   * See also:\n   *\n   *    exp, log, log1p, log2\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the 10-base logarithm of `x`\n   */\n  var log10 = typed('log10', {\n    'number': function number(x) {\n      if (x >= 0 || config.predictable) {\n        return _log10(x);\n      } else {\n        // negative value -> complex value computation\n        return new type.Complex(x, 0).log().div(Math.LN10);\n      }\n    },\n    'Complex': function Complex(x) {\n      return new type.Complex(x).log().div(Math.LN10);\n    },\n    'BigNumber': function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.log();\n      } else {\n        // downgrade to number, return Complex valued result\n        return new type.Complex(x.toNumber(), 0).log().div(Math.LN10);\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, log10);\n    }\n  });\n  log10.toTex = {\n    1: \"\\\\log_{10}\\\\left(${args[0]}\\\\right)\"\n  };\n  return log10;\n}\n/**\n * Calculate the 10-base logarithm of a number\n * @param {number} x\n * @return {number}\n * @private\n */\n\n\nvar _log10 = Math.log10 || function (x) {\n  return Math.log(x) / Math.LN10;\n};\n\nexports.name = 'log10';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var divideScalar = load(require('./divideScalar'));\n  var log = load(require('./log'));\n  /**\n   * Calculate the logarithm of a `value+1`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log1p(x)\n   *    math.log1p(x, base)\n   *\n   * Examples:\n   *\n   *    math.log1p(2.5)                 // returns 1.252762968495368\n   *    math.exp(math.log1p(1.4))       // returns 2.4\n   *\n   *    math.pow(10, 4)                 // returns 10000\n   *    math.log1p(9999, 10)            // returns 4\n   *    math.log1p(9999) / math.log(10) // returns 4\n   *\n   * See also:\n   *\n   *    exp, log, log2, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm of `x+1`.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x+1` is calculated.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the logarithm of `x+1`\n   */\n\n  var log1p = typed('log1p', {\n    'number': _log1pNumber,\n    'Complex': _log1pComplex,\n    'BigNumber': function BigNumber(x) {\n      var y = x.plus(1);\n\n      if (!y.isNegative() || config.predictable) {\n        return y.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log1pComplex(new type.Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, log1p);\n    },\n    'any, any': function anyAny(x, base) {\n      // calculate logarithm for a specified base, log1p(x, base)\n      return divideScalar(log1p(x), log(base));\n    }\n  });\n  /**\n   * Calculate the natural logarithm of a `number+1`\n   * @param {number} x\n   * @returns {number | Complex}\n   * @private\n   */\n\n  function _log1pNumber(x) {\n    if (x >= -1 || config.predictable) {\n      return Math.log1p ? Math.log1p(x) : Math.log(x + 1);\n    } else {\n      // negative value -> complex value computation\n      return _log1pComplex(new type.Complex(x, 0));\n    }\n  }\n  /**\n   * Calculate the natural logarithm of a complex number + 1\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n\n\n  function _log1pComplex(x) {\n    var xRe1p = x.re + 1;\n    return new type.Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));\n  }\n\n  log1p.toTex = {\n    1: \"\\\\ln\\\\left(${args[0]}+1\\\\right)\",\n    2: \"\\\\log_{${args[1]}}\\\\left(${args[0]}+1\\\\right)\"\n  };\n  return log1p;\n}\n\nexports.name = 'log1p';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log2(x)\n   *\n   * Examples:\n   *\n   *    math.log2(0.03125)           // returns -5\n   *    math.log2(16)                // returns 4\n   *    math.log2(16) / math.log2(2) // returns 4\n   *    math.pow(2, 4)               // returns 16\n   *\n   * See also:\n   *\n   *    exp, log, log1p, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the 2-base logarithm of `x`\n   */\n  var log2 = typed('log2', {\n    'number': function number(x) {\n      if (x >= 0 || config.predictable) {\n        return Math.log2 ? Math.log2(x) : Math.log(x) / Math.LN2;\n      } else {\n        // negative value -> complex value computation\n        return _log2Complex(new type.Complex(x, 0));\n      }\n    },\n    'Complex': _log2Complex,\n    'BigNumber': function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.log(2);\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log2Complex(new type.Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, log2);\n    }\n  });\n  /**\n   * Calculate log2 for a complex value\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n\n  function _log2Complex(x) {\n    var newX = Math.sqrt(x.re * x.re + x.im * x.im);\n    return new type.Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);\n  }\n\n  log2.toTex = \"\\\\log_{2}\\\\left(${args[0]}\\\\right)\";\n  return log2;\n}\n\nexports.name = 'log2';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n\n  var latex = require('../../utils/latex');\n\n  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));\n  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));\n  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));\n  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));\n  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Calculates the modulus, the remainder of an integer division.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * The modulus is defined as:\n   *\n   *     x - y * floor(x / y)\n   *\n   * See http://en.wikipedia.org/wiki/Modulo_operation.\n   *\n   * Syntax:\n   *\n   *    math.mod(x, y)\n   *\n   * Examples:\n   *\n   *    math.mod(8, 3)                // returns 2\n   *    math.mod(11, 2)               // returns 1\n   *\n   *    function isOdd(x) {\n   *      return math.mod(x, 2) != 0\n   *    }\n   *\n   *    isOdd(2)                      // returns false\n   *    isOdd(3)                      // returns true\n   *\n   * See also:\n   *\n   *    divide\n   *\n   * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend\n   * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor\n   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.\n   */\n\n  var mod = typed('mod', {\n    'number, number': _mod,\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\n      return y.isZero() ? x : x.mod(y);\n    },\n    'Fraction, Fraction': function FractionFraction(x, y) {\n      return x.mod(y);\n    },\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm05(x, y, mod, false);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      return algorithm02(y, x, mod, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm03(x, y, mod, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, mod);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      // use matrix implementation\n      return mod(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use matrix implementation\n      return mod(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use matrix implementation\n      return mod(x, matrix(y));\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, mod, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, mod, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm12(y, x, mod, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, mod, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, mod, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, mod, true).valueOf();\n    }\n  });\n  mod.toTex = {\n    2: \"\\\\left(${args[0]}\".concat(latex.operators['mod'], \"${args[1]}\\\\right)\")\n  };\n  return mod;\n  /**\n   * Calculate the modulus of two numbers\n   * @param {number} x\n   * @param {number} y\n   * @returns {number} res\n   * @private\n   */\n\n  function _mod(x, y) {\n    if (y > 0) {\n      // We don't use JavaScript's % operator here as this doesn't work\n      // correctly for x < 0 and x === 0\n      // see http://en.wikipedia.org/wiki/Modulo_operation\n      return x - y * Math.floor(x / y);\n    } else if (y === 0) {\n      return x;\n    } else {\n      // y < 0\n      // TODO: implement mod for a negative divisor\n      throw new Error('Cannot calculate mod for a negative divisor');\n    }\n  }\n}\n\nexports.name = 'mod';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var divideScalar = load(require('./divideScalar'));\n  /**\n   * Calculate the logarithm of a value.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log(x)\n   *    math.log(x, base)\n   *\n   * Examples:\n   *\n   *    math.log(3.5)                  // returns 1.252762968495368\n   *    math.exp(math.log(2.4))        // returns 2.4\n   *\n   *    math.pow(10, 4)                // returns 10000\n   *    math.log(10000, 10)            // returns 4\n   *    math.log(10000) / math.log(10) // returns 4\n   *\n   *    math.log(1024, 2)              // returns 10\n   *    math.pow(2, 10)                // returns 1024\n   *\n   * See also:\n   *\n   *    exp, log2, log10, log1p\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x` is calculated.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the logarithm of `x`\n   */\n\n  var log = typed('log', {\n    'number': function number(x) {\n      if (x >= 0 || config.predictable) {\n        return Math.log(x);\n      } else {\n        // negative value -> complex value computation\n        return new type.Complex(x, 0).log();\n      }\n    },\n    'Complex': function Complex(x) {\n      return x.log();\n    },\n    'BigNumber': function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return new type.Complex(x.toNumber(), 0).log();\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, log);\n    },\n    'any, any': function anyAny(x, base) {\n      // calculate logarithm for a specified base, log(x, base)\n      return divideScalar(log(x), log(base));\n    }\n  });\n  log.toTex = {\n    1: \"\\\\ln\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\log_{${args[1]}}\\\\left(${args[0]}\\\\right)\"\n  };\n  return log;\n}\n\nexports.name = 'log';\nexports.factory = factory;"],"sourceRoot":""}