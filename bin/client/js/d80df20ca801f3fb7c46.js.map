{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/utils/compileInlineExpression.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/error.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/index.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/concat.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/filter.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/forEach.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/index.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/map.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/max.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/mean.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/min.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/range.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/subset.transform.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/transform/sum.transform.js"],"names":["exports","factory","type","config","load","typed","expression","math","scope","symbol","filter","node","isSymbolNode","name","Error","subScope","Object","create","eq","compile","x","eval","IndexError","__webpack_require__","transform","err","isIndexError","index","min","undefined","max","module","errorTransform","path","concat","...any","args","lastIndex","length","last","isNumber","isBigNumber","minus","apply","filterRegExp","maxArgumentCount","_filter","callback","value","array","compileInlineExpression","matrix","filterTransform","isFunctionAssignmentNode","rawArgs","Array, function","Matrix, function","test","toArray","Array, RegExp","Matrix, RegExp","toTex","forEach","forEachTransform","_forEach","Array | Matrix, function","recurse","Array","isArray","child","i","valueOf","ii","arguments","arg","isRange","start","end","step","isSet","map","v","isMatrix","toNumber","TypeError","res","Index","_map","orig","argsCount","mapTransform","isCollection","dim","mean","range","push","subset","sum"],"mappings":"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","file":"js/d80df20ca801f3fb7c46.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Compile an inline expression like \"x > 0\"\n   * @param {Node} expression\n   * @param {Object} math\n   * @param {Object} scope\n   * @return {function} Returns a function with one argument which fills in the\n   *                    undefined variable (like \"x\") and evaluates the expression\n   */\n  return function compileInlineExpression(expression, math, scope) {\n    // find an undefined symbol\n    var symbol = expression.filter(function (node) {\n      return type.isSymbolNode(node) && !(node.name in math) && !(node.name in scope);\n    })[0];\n\n    if (!symbol) {\n      throw new Error('No undefined variable found in inline expression \"' + expression + '\"');\n    } // create a test function for this equation\n\n\n    var name = symbol.name; // variable name\n\n    var subScope = Object.create(scope);\n    var eq = expression.compile();\n    return function inlineExpression(x) {\n      subScope[name] = x;\n      return eq.eval(subScope);\n    };\n  };\n}\n\nexports.factory = factory;","'use strict';\n\nvar IndexError = require('../../error/IndexError');\n/**\n * Transform zero-based indices to one-based indices in errors\n * @param {Error} err\n * @returns {Error} Returns the transformed error\n */\n\n\nexports.transform = function (err) {\n  if (err && err.isIndexError) {\n    return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);\n  }\n\n  return err;\n};","'use strict';\n\nmodule.exports = [require('./concat.transform'), require('./filter.transform'), require('./forEach.transform'), require('./index.transform'), require('./map.transform'), require('./max.transform'), require('./mean.transform'), require('./min.transform'), require('./range.transform'), require('./subset.transform'), require('./sum.transform')];","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n/**\n * Attach a transform function to math.range\n * Adds a property transform containing the transform function.\n *\n * This transform changed the last `dim` parameter of function concat\n * from one-based to zero based\n */\n\n\nfunction factory(type, config, load, typed) {\n  var concat = load(require('../../function/matrix/concat')); // @see: comment of concat itself\n\n  return typed('concat', {\n    '...any': function any(args) {\n      // change last argument from one-based to zero-based\n      var lastIndex = args.length - 1;\n      var last = args[lastIndex];\n\n      if (type.isNumber(last)) {\n        args[lastIndex] = last - 1;\n      } else if (type.isBigNumber(last)) {\n        args[lastIndex] = last.minus(1);\n      }\n\n      try {\n        return concat.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'concat';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar filter = require('../../utils/array').filter;\n\nvar filterRegExp = require('../../utils/array').filterRegExp;\n\nvar maxArgumentCount = require('../../utils/function').maxArgumentCount;\n/**\n * Attach a transform function to math.filter\n * Adds a property transform containing the transform function.\n *\n * This transform adds support for equations as test function for math.filter,\n * so you can do something like 'filter([3, -2, 5], x > 0)'.\n */\n\n\nfunction factory(type, config, load, typed) {\n  var compileInlineExpression = load(require('./utils/compileInlineExpression'));\n  var matrix = load(require('../../type/matrix/function/matrix'));\n\n  function filterTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().eval(scope);\n    }\n\n    if (args[1]) {\n      if (type.isSymbolNode(args[1]) || type.isFunctionAssignmentNode(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().eval(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(args[1], math, scope);\n      }\n    }\n\n    return filter(x, callback);\n  }\n\n  filterTransform.rawArgs = true; // one based version of function filter\n\n  var filter = typed('filter', {\n    'Array, function': _filter,\n    'Matrix, function': function MatrixFunction(x, test) {\n      return matrix(_filter(x.toArray(), test));\n    },\n    'Array, RegExp': filterRegExp,\n    'Matrix, RegExp': function MatrixRegExp(x, test) {\n      return matrix(filterRegExp(x.toArray(), test));\n    }\n  });\n  filter.toTex = undefined; // use default template\n\n  return filterTransform;\n}\n/**\n * Filter values in a callback given a callback function\n *\n * !!! Passes a one-based index !!!\n *\n * @param {Array} x\n * @param {Function} callback\n * @return {Array} Returns the filtered array\n * @private\n */\n\n\nfunction _filter(x, callback) {\n  // figure out what number of arguments the callback function expects\n  var args = maxArgumentCount(callback);\n  return filter(x, function (value, index, array) {\n    // invoke the callback function with the right number of arguments\n    if (args === 1) {\n      return callback(value);\n    } else if (args === 2) {\n      return callback(value, [index + 1]);\n    } else {\n      // 3 or -1\n      return callback(value, [index + 1], array);\n    }\n  });\n}\n\nexports.name = 'filter';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar maxArgumentCount = require('../../utils/function').maxArgumentCount;\n\nvar forEach = require('../../utils/array').forEach;\n/**\n * Attach a transform function to math.forEach\n * Adds a property transform containing the transform function.\n *\n * This transform creates a one-based index instead of a zero-based index\n */\n\n\nfunction factory(type, config, load, typed) {\n  var compileInlineExpression = load(require('./utils/compileInlineExpression'));\n\n  function forEachTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().eval(scope);\n    }\n\n    if (args[1]) {\n      if (type.isSymbolNode(args[1]) || type.isFunctionAssignmentNode(args[1])) {\n        // a function pointer, like forEach([3, -2, 5], myTestFunction)\n        callback = args[1].compile().eval(scope);\n      } else {\n        // an expression like forEach([3, -2, 5], x > 0 ? callback1(x) : callback2(x) )\n        callback = compileInlineExpression(args[1], math, scope);\n      }\n    }\n\n    return _forEach(x, callback);\n  }\n\n  forEachTransform.rawArgs = true; // one-based version of forEach\n\n  var _forEach = typed('forEach', {\n    'Array | Matrix, function': function ArrayMatrixFunction(array, callback) {\n      // figure out what number of arguments the callback function expects\n      var args = maxArgumentCount(callback);\n\n      var recurse = function recurse(value, index) {\n        if (Array.isArray(value)) {\n          forEach(value, function (child, i) {\n            // we create a copy of the index array and append the new index value\n            recurse(child, index.concat(i + 1)); // one based index, hence i+1\n          });\n        } else {\n          // invoke the callback function with the right number of arguments\n          if (args === 1) {\n            callback(value);\n          } else if (args === 2) {\n            callback(value, index);\n          } else {\n            // 3 or -1\n            callback(value, index, array);\n          }\n        }\n      };\n\n      recurse(array.valueOf(), []); // pass Array\n    }\n  });\n\n  return forEachTransform;\n}\n\nexports.name = 'forEach';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n/**\n * Attach a transform function to math.index\n * Adds a property transform containing the transform function.\n *\n * This transform creates a one-based index instead of a zero-based index\n */\n\nfunction factory(type, config, load) {\n  return function indexTransform() {\n    var args = [];\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i]; // change from one-based to zero based, and convert BigNumber to number\n\n      if (type.isRange(arg)) {\n        arg.start--;\n        arg.end -= arg.step > 0 ? 0 : 2;\n      } else if (arg && arg.isSet === true) {\n        arg = arg.map(function (v) {\n          return v - 1;\n        });\n      } else if (type.isArray(arg) || type.isMatrix(arg)) {\n        arg = arg.map(function (v) {\n          return v - 1;\n        });\n      } else if (type.isNumber(arg)) {\n        arg--;\n      } else if (type.isBigNumber(arg)) {\n        arg = arg.toNumber() - 1;\n      } else if (typeof arg === 'string') {// leave as is\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      }\n\n      args[i] = arg;\n    }\n\n    var res = new type.Index();\n    type.Index.apply(res, args);\n    return res;\n  };\n}\n\nexports.name = 'index';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar maxArgumentCount = require('../../utils/function').maxArgumentCount;\n\nvar map = require('../../utils/array').map;\n/**\n * Attach a transform function to math.map\n * Adds a property transform containing the transform function.\n *\n * This transform creates a one-based index instead of a zero-based index\n */\n\n\nfunction factory(type, config, load, typed) {\n  var compileInlineExpression = load(require('./utils/compileInlineExpression'));\n  var matrix = load(require('../../type/matrix/function/matrix'));\n\n  function mapTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().eval(scope);\n    }\n\n    if (args[1]) {\n      if (type.isSymbolNode(args[1]) || type.isFunctionAssignmentNode(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().eval(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(args[1], math, scope);\n      }\n    }\n\n    return map(x, callback);\n  }\n\n  mapTransform.rawArgs = true; // one-based version of map function\n\n  var map = typed('map', {\n    'Array, function': function ArrayFunction(x, callback) {\n      return _map(x, callback, x);\n    },\n    'Matrix, function': function MatrixFunction(x, callback) {\n      return matrix(_map(x.valueOf(), callback, x));\n    }\n  });\n  return mapTransform;\n}\n/**\n * Map for a multi dimensional array. One-based indexes\n * @param {Array} array\n * @param {function} callback\n * @param {Array} orig\n * @return {Array}\n * @private\n */\n\n\nfunction _map(array, callback, orig) {\n  // figure out what number of arguments the callback function expects\n  var argsCount = maxArgumentCount(callback);\n\n  function recurse(value, index) {\n    if (Array.isArray(value)) {\n      return map(value, function (child, i) {\n        // we create a copy of the index array and append the new index value\n        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1\n      });\n    } else {\n      // invoke the (typed) callback function with the right number of arguments\n      if (argsCount === 1) {\n        return callback(value);\n      } else if (argsCount === 2) {\n        return callback(value, index);\n      } else {\n        // 3 or -1\n        return callback(value, index, orig);\n      }\n    }\n  }\n\n  return recurse(array, []);\n}\n\nexports.name = 'map';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n\nvar isCollection = require('../../utils/collection/isCollection');\n/**\n * Attach a transform function to math.max\n * Adds a property transform containing the transform function.\n *\n * This transform changed the last `dim` parameter of function max\n * from one-based to zero based\n */\n\n\nfunction factory(type, config, load, typed) {\n  var max = load(require('../../function/statistics/max'));\n  return typed('max', {\n    '...any': function any(args) {\n      // change last argument dim from one-based to zero-based\n      if (args.length === 2 && isCollection(args[0])) {\n        var dim = args[1];\n\n        if (type.isNumber(dim)) {\n          args[1] = dim - 1;\n        } else if (type.isBigNumber(dim)) {\n          args[1] = dim.minus(1);\n        }\n      }\n\n      try {\n        return max.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'max';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n\nvar isCollection = require('../../utils/collection/isCollection');\n/**\n * Attach a transform function to math.mean\n * Adds a property transform containing the transform function.\n *\n * This transform changed the last `dim` parameter of function mean\n * from one-based to zero based\n */\n\n\nfunction factory(type, config, load, typed) {\n  var mean = load(require('../../function/statistics/mean'));\n  return typed('mean', {\n    '...any': function any(args) {\n      // change last argument dim from one-based to zero-based\n      if (args.length === 2 && isCollection(args[0])) {\n        var dim = args[1];\n\n        if (type.isNumber(dim)) {\n          args[1] = dim - 1;\n        } else if (type.isBigNumber(dim)) {\n          args[1] = dim.minus(1);\n        }\n      }\n\n      try {\n        return mean.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'mean';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n\nvar isCollection = require('../../utils/collection/isCollection');\n/**\n * Attach a transform function to math.min\n * Adds a property transform containing the transform function.\n *\n * This transform changed the last `dim` parameter of function min\n * from one-based to zero based\n */\n\n\nfunction factory(type, config, load, typed) {\n  var min = load(require('../../function/statistics/min'));\n  return typed('min', {\n    '...any': function any(args) {\n      // change last argument dim from one-based to zero-based\n      if (args.length === 2 && isCollection(args[0])) {\n        var dim = args[1];\n\n        if (type.isNumber(dim)) {\n          args[1] = dim - 1;\n        } else if (type.isBigNumber(dim)) {\n          args[1] = dim.minus(1);\n        }\n      }\n\n      try {\n        return min.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'min';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n/**\n * Attach a transform function to math.range\n * Adds a property transform containing the transform function.\n *\n * This transform creates a range which includes the end value\n */\n\nfunction factory(type, config, load, typed) {\n  var range = load(require('../../function/matrix/range'));\n  return typed('range', {\n    '...any': function any(args) {\n      var lastIndex = args.length - 1;\n      var last = args[lastIndex];\n\n      if (typeof last !== 'boolean') {\n        // append a parameter includeEnd=true\n        args.push(true);\n      }\n\n      return range.apply(null, args);\n    }\n  });\n}\n\nexports.name = 'range';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n/**\n * Attach a transform function to math.subset\n * Adds a property transform containing the transform function.\n *\n * This transform creates a range which includes the end value\n */\n\n\nfunction factory(type, config, load, typed) {\n  var subset = load(require('../../function/matrix/subset'));\n  return typed('subset', {\n    '...any': function any(args) {\n      try {\n        return subset.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'subset';\nexports.path = 'expression.transform';\nexports.factory = factory;","'use strict';\n\nvar errorTransform = require('./error.transform').transform;\n\nvar isCollection = require('../../utils/collection/isCollection');\n/**\n * Attach a transform function to math.sum\n * Adds a property transform containing the transform function.\n *\n * This transform changed the last `dim` parameter of function mean\n * from one-based to zero based\n */\n\n\nfunction factory(type, config, load, typed) {\n  var sum = load(require('../../function/statistics/sum'));\n  return typed('sum', {\n    '...any': function any(args) {\n      // change last argument dim from one-based to zero-based\n      if (args.length === 2 && isCollection(args[0])) {\n        var dim = args[1];\n\n        if (type.isNumber(dim)) {\n          args[1] = dim - 1;\n        } else if (type.isBigNumber(dim)) {\n          args[1] = dim.minus(1);\n        }\n      }\n\n      try {\n        return sum.apply(null, args);\n      } catch (err) {\n        throw errorTransform(err);\n      }\n    }\n  });\n}\n\nexports.name = 'sum';\nexports.path = 'expression.transform';\nexports.factory = factory;"],"sourceRoot":""}