{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/ArrayNode.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/AssignmentNode.js"],"names":["map","__webpack_require__","exports","name","path","factory","type","config","load","typed","Node","ArrayNode","items","this","SyntaxError","Array","isArray","every","isNode","TypeError","deprecated","Error","Object","defineProperty","get","set","prototype","isArrayNode","_compile","math","argNames","evalItems","item","matrix","scope","args","context","evalItem","forEach","callback","i","length","_ifNode","clone","slice","_toString","options","node","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","s","childNode","toTex","getSafeProperty","setSafeProperty","assign","access","operators","AssignmentNode","object","index","value","isSymbolNode","isAccessorNode","isIndexNode","isObjectProperty","getObjectProperty","bind","needParenthesis","parenthesis","precedence","getPrecedence","exprPrecedence","isAssignmentNode","evalObject","evalIndex","evalValue","prop","childObject","evalParentObject","parentProp","parent","evalParentIndex","parentIndex","concat"],"mappings":"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","file":"js/81b9afe29e82c2c2598f.js","sourcesContent":["'use strict';\n\nvar map = require('../../utils/array').map;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');\n    };\n\n    Object.defineProperty(this, 'nodes', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config().matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    var s = '\\\\begin{bmatrix}';\n    this.items.forEach(function (node) {\n      if (node.items) {\n        s += node.items.map(function (childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      } else {\n        s += node.toTex(options);\n      } // new line\n\n\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}\n\nexports.name = 'ArrayNode';\nexports.path = 'expression.node';\nexports.factory = factory;","'use strict';\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var assign = load(require('./utils/assign'));\n  var access = load(require('./utils/access'));\n\n  var operators = require('../operators');\n  /**\n   * @constructor AssignmentNode\n   * @extends {Node}\n   *\n   * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or\n   * replace a subset of a matrix like `A[2,2]=42`.\n   *\n   * Syntax:\n   *\n   *     new AssignmentNode(symbol, value)\n   *     new AssignmentNode(object, index, value)\n   *\n   * Usage:\n   *\n   *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))                       // a=2\n   *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2\n   *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3\n   *\n   * @param {SymbolNode | AccessorNode} object  Object on which to assign a value\n   * @param {IndexNode} [index=null]            Index, property name or matrix\n   *                                            index. Optional. If not provided\n   *                                            and `object` is a SymbolNode,\n   *                                            the property is assigned to the\n   *                                            global scope.\n   * @param {Node} value                        The value to be assigned\n   */\n\n\n  function AssignmentNode(object, index, value) {\n    if (!(this instanceof AssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.object = object;\n    this.index = value ? index : null;\n    this.value = value || index; // validate input\n\n    if (!type.isSymbolNode(object) && !type.isAccessorNode(object)) {\n      throw new TypeError('SymbolNode or AccessorNode expected as \"object\"');\n    }\n\n    if (type.isSymbolNode(object) && object.name === 'end') {\n      throw new Error('Cannot assign to symbol \"end\"');\n    }\n\n    if (this.index && !type.isIndexNode(this.index)) {\n      // index is optional\n      throw new TypeError('IndexNode expected as \"index\"');\n    }\n\n    if (!type.isNode(this.value)) {\n      throw new TypeError('Node expected as \"value\"');\n    } // readonly property name\n\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\n        } else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AssignmentNode.prototype = new Node();\n  AssignmentNode.prototype.type = 'AssignmentNode';\n  AssignmentNode.prototype.isAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  AssignmentNode.prototype._compile = function (math, argNames) {\n    var evalObject = this.object._compile(math, argNames);\n\n    var evalIndex = this.index ? this.index._compile(math, argNames) : null;\n\n    var evalValue = this.value._compile(math, argNames);\n\n    var name = this.object.name;\n\n    if (!this.index) {\n      // apply a variable to the scope, for example `a=2`\n      if (!type.isSymbolNode(this.object)) {\n        throw new TypeError('SymbolNode expected as object');\n      }\n\n      return function evalAssignmentNode(scope, args, context) {\n        return setSafeProperty(scope, name, evalValue(scope, args, context));\n      };\n    } else if (this.index.isObjectProperty()) {\n      // apply an object property for example `a.b=2`\n      var prop = this.index.getObjectProperty();\n      return function evalAssignmentNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        var value = evalValue(scope, args, context);\n        return setSafeProperty(object, prop, value);\n      };\n    } else if (type.isSymbolNode(this.object)) {\n      // update a matrix subset, for example `a[2]=3`\n      return function evalAssignmentNode(scope, args, context) {\n        var childObject = evalObject(scope, args, context);\n        var value = evalValue(scope, args, context);\n        var index = evalIndex(scope, args, childObject); // Important:  we pass childObject instead of context\n\n        setSafeProperty(scope, name, assign(childObject, index, value));\n        return value;\n      };\n    } else {\n      // type.isAccessorNode(node.object) === true\n      // update a matrix subset, for example `a.b[2]=3`\n      // we will not use the compile function of the AccessorNode, but compile it\n      // ourselves here as we need the parent object of the AccessorNode:\n      // wee need to apply the updated object to parent object\n      var evalParentObject = this.object.object._compile(math, argNames);\n\n      if (this.object.index.isObjectProperty()) {\n        var parentProp = this.object.index.getObjectProperty();\n        return function evalAssignmentNode(scope, args, context) {\n          var parent = evalParentObject(scope, args, context);\n          var childObject = getSafeProperty(parent, parentProp);\n          var index = evalIndex(scope, args, childObject); // Important: we pass childObject instead of context\n\n          var value = evalValue(scope, args, context);\n          setSafeProperty(parent, parentProp, assign(childObject, index, value));\n          return value;\n        };\n      } else {\n        // if some parameters use the 'end' parameter, we need to calculate the size\n        var evalParentIndex = this.object.index._compile(math, argNames);\n\n        return function evalAssignmentNode(scope, args, context) {\n          var parent = evalParentObject(scope, args, context);\n          var parentIndex = evalParentIndex(scope, args, parent); // Important: we pass parent instead of context\n\n          var childObject = access(parent, parentIndex);\n          var index = evalIndex(scope, args, childObject); // Important:  we pass childObject instead of context\n\n          var value = evalValue(scope, args, context);\n          assign(parent, parentIndex, assign(childObject, index, value));\n          return value;\n        };\n      }\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  AssignmentNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n\n    if (this.index) {\n      callback(this.index, 'index', this);\n    }\n\n    callback(this.value, 'value', this);\n  };\n  /**\n   * Create a new AssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  AssignmentNode.prototype.map = function (callback) {\n    var object = this._ifNode(callback(this.object, 'object', this));\n\n    var index = this.index ? this._ifNode(callback(this.index, 'index', this)) : null;\n\n    var value = this._ifNode(callback(this.value, 'value', this));\n\n    return new AssignmentNode(object, index, value);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AssignmentNode}\n   */\n\n\n  AssignmentNode.prototype.clone = function () {\n    return new AssignmentNode(this.object, this.index, this.value);\n  };\n  /*\n   * Is parenthesis needed?\n   * @param {node} node\n   * @param {string} [parenthesis='keep']\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    if (!parenthesis) {\n      parenthesis = 'keep';\n    }\n\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var exprPrecedence = operators.getPrecedence(node.value, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AssignmentNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n    var index = this.index ? this.index.toString(options) : '';\n    var value = this.value.toString(options);\n\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = '(' + value + ')';\n    }\n\n    return object + index + ' = ' + value;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  AssignmentNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'AssignmentNode',\n      object: this.object,\n      index: this.index,\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"AssignmentNode\", object: ..., index: ..., value: ...}`,\n   *                       where mathjs is optional\n   * @returns {AssignmentNode}\n   */\n\n\n  AssignmentNode.fromJSON = function (json) {\n    return new AssignmentNode(json.object, json.index, json.value);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AssignmentNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n    var index = this.index ? this.index.toHTML(options) : '';\n    var value = this.value.toHTML(options);\n\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = '<span class=\"math-paranthesis math-round-parenthesis\">(</span>' + value + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + index + '<span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + value;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AssignmentNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n    var index = this.index ? this.index.toTex(options) : '';\n    var value = this.value.toTex(options);\n\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = \"\\\\left(\".concat(value, \"\\\\right)\");\n    }\n\n    return object + index + ':=' + value;\n  };\n\n  return AssignmentNode;\n}\n\nexports.name = 'AssignmentNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}