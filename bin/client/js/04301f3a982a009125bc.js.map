{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/function/matrix.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/function/index.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/function/sparse.js"],"names":["exports","name","factory","type","config","load","typed","matrix","","_create","string","format","string, string","datatype","Array","data","Matrix","storage","Array | Matrix, string","Array | Matrix, string, string","toTex","0","1","2","...number | string | BigNumber | Range | Array | Matrix","args","ranges","map","arg","isBigNumber","toNumber","isArray","isMatrix","elem","res","Index","apply","SparseMatrix","sparse","Array | Matrix"],"mappings":"yFA6EAA,EAAAC,KAAA,SACAD,EAAAE,QA5EA,SAAAC,EAAAC,EAAAC,EAAAC,GAiCA,IAAAC,EAAAD,EAAA,UACAE,GAAA,WACA,OAAAC,EAAA,KAEAC,OAAA,SAAAC,GACA,OAAAF,EAAA,GAAAE,IAEAC,iBAAA,SAAAD,EAAAE,GACA,OAAAJ,EAAA,GAAAE,EAAAE,IAEAC,MAAA,SAAAC,GACA,OAAAN,EAAAM,IAEAC,OAAA,SAAAD,GACA,OAAAN,EAAAM,IAAAE,YAEAC,yBAAAT,EACAU,iCAAAV,IAOA,OALAF,EAAAa,MAAA,CACAC,EAAA,iCACAC,EAAA,4BACAC,EAAA,6BAEAhB,EAUA,SAAAE,EAAAM,EAAAJ,EAAAE,GAIA,WAFAV,EAAAa,OAAAC,QAAAN,GAAA,WAEA,CAAAI,EAAAF,uCCdAb,EAAAC,KAAA,QACAD,EAAAE,QA1DA,SAAAC,EAAAC,EAAAC,EAAAC,GAoCA,OAAAA,EAAA,SACAkB,0DAAA,SAAAC,GACA,IAAAC,EAAAD,EAAAE,IAAA,SAAAC,GACA,OAAAzB,EAAA0B,YAAAD,GACAA,EAAAE,WACShB,MAAAiB,QAAAH,IAAAzB,EAAA6B,SAAAJ,GACTA,EAAAD,IAAA,SAAAM,GAEA,OAAA9B,EAAA0B,YAAAI,KAAAH,WAAAG,IAGAL,IAGAM,EAAA,IAAA/B,EAAAgC,MAEA,OADAhC,EAAAgC,MAAAC,MAAAF,EAAAR,GACAQ,wCCDAlC,EAAAC,KAAA,SACAD,EAAAE,QApDA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAA+B,EAAAlC,EAAAkC,aA6BAC,EAAAhC,EAAA,UACAE,GAAA,WACA,WAAA6B,EAAA,KAEA3B,OAAA,SAAAG,GACA,WAAAwB,EAAA,GAAAxB,IAEA0B,iBAAA,SAAAxB,GACA,WAAAsB,EAAAtB,IAEAG,yBAAA,SAAAH,EAAAF,GACA,WAAAwB,EAAAtB,EAAAF,MAOA,OAJAyB,EAAAlB,MAAA,CACAC,EAAA,iCACAC,EAAA,6BAEAgB","file":"js/04301f3a982a009125bc.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Create a Matrix. The function creates a new `math.type.Matrix` object from\n   * an `Array`. A Matrix has utility functions to manipulate the data in the\n   * matrix, like getting the size and getting or setting values in the matrix.\n   * Supported storage formats are 'dense' and 'sparse'.\n   *\n   * Syntax:\n   *\n   *    math.matrix()                         // creates an empty matrix using default storage format (dense).\n   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).\n   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.\n   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.\n   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.\n   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.\n   *\n   * Examples:\n   *\n   *    let m = math.matrix([[1, 2], [3, 4]])\n   *    m.size()                        // Array [2, 2]\n   *    m.resize([3, 2], 5)\n   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]\n   *    m.get([1, 0])                    // number 3\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, index, number, string, unit, sparse\n   *\n   * @param {Array | Matrix} [data]    A multi dimensional array\n   * @param {string} [format]          The Matrix storage format\n   *\n   * @return {Matrix} The created matrix\n   */\n  var matrix = typed('matrix', {\n    '': function _() {\n      return _create([]);\n    },\n    'string': function string(format) {\n      return _create([], format);\n    },\n    'string, string': function stringString(format, datatype) {\n      return _create([], format, datatype);\n    },\n    'Array': function Array(data) {\n      return _create(data);\n    },\n    'Matrix': function Matrix(data) {\n      return _create(data, data.storage());\n    },\n    'Array | Matrix, string': _create,\n    'Array | Matrix, string, string': _create\n  });\n  matrix.toTex = {\n    0: '\\\\begin{bmatrix}\\\\end{bmatrix}',\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(${args[0]}\\\\right)\"\n  };\n  return matrix;\n  /**\n   * Create a new Matrix with given storage format\n   * @param {Array} data\n   * @param {string} [format]\n   * @param {string} [datatype]\n   * @returns {Matrix} Returns a new Matrix\n   * @private\n   */\n\n  function _create(data, format, datatype) {\n    // get storage format constructor\n    var M = type.Matrix.storage(format || 'default'); // create instance\n\n    return new M(data, datatype);\n  }\n}\n\nexports.name = 'matrix';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Create an index. An Index can store ranges having start, step, and end\n   * for multiple dimensions.\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\n   *\n   * Syntax:\n   *\n   *     math.index(range1, range2, ...)\n   *\n   * Where each range can be any of:\n   *\n   * - A number\n   * - A string for getting/setting an object property\n   * - An instance of `Range`\n   * - A one-dimensional Array or a Matrix with numbers\n   *\n   * Indexes must be zero-based, integer numbers.\n   *\n   * Examples:\n   *\n   *    const math = require('mathjs')\n   *\n   *    const b = [1, 2, 3, 4, 5]\n   *    math.subset(b, math.index([1, 2, 3]))     // returns [2, 3, 4]\n   *\n   *    const a = math.matrix([[1, 2], [3, 4]])\n   *    a.subset(math.index(0, 1))             // returns 2\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, matrix, number, string, unit\n   *\n   * @param {...*} ranges   Zero or more ranges or numbers.\n   * @return {Index}        Returns the created index\n   */\n  return typed('index', {\n    '...number | string | BigNumber | Range | Array | Matrix': function numberStringBigNumberRangeArrayMatrix(args) {\n      var ranges = args.map(function (arg) {\n        if (type.isBigNumber(arg)) {\n          return arg.toNumber(); // convert BigNumber to Number\n        } else if (Array.isArray(arg) || type.isMatrix(arg)) {\n          return arg.map(function (elem) {\n            // convert BigNumber to Number\n            return type.isBigNumber(elem) ? elem.toNumber() : elem;\n          });\n        } else {\n          return arg;\n        }\n      });\n      var res = new type.Index();\n      type.Index.apply(res, ranges);\n      return res;\n    }\n  });\n}\n\nexports.name = 'index';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Create a Sparse Matrix. The function creates a new `math.type.Matrix` object from\n   * an `Array`. A Matrix has utility functions to manipulate the data in the\n   * matrix, like getting the size and getting or setting values in the matrix.\n   *\n   * Syntax:\n   *\n   *    math.sparse()               // creates an empty sparse matrix.\n   *    math.sparse(data)           // creates a sparse matrix with initial data.\n   *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.\n   *\n   * Examples:\n   *\n   *    let m = math.sparse([[1, 2], [3, 4]])\n   *    m.size()                        // Array [2, 2]\n   *    m.resize([3, 2], 5)\n   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]\n   *    m.get([1, 0])                    // number 3\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, index, number, string, unit, matrix\n   *\n   * @param {Array | Matrix} [data]    A two dimensional array\n   *\n   * @return {Matrix} The created matrix\n   */\n\n  var sparse = typed('sparse', {\n    '': function _() {\n      return new SparseMatrix([]);\n    },\n    'string': function string(datatype) {\n      return new SparseMatrix([], datatype);\n    },\n    'Array | Matrix': function ArrayMatrix(data) {\n      return new SparseMatrix(data);\n    },\n    'Array | Matrix, string': function ArrayMatrixString(data, datatype) {\n      return new SparseMatrix(data, datatype);\n    }\n  });\n  sparse.toTex = {\n    0: '\\\\begin{bsparse}\\\\end{bsparse}',\n    1: \"\\\\left(${args[0]}\\\\right)\"\n  };\n  return sparse;\n}\n\nexports.name = 'sparse';\nexports.factory = factory;"],"sourceRoot":""}