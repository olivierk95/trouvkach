{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/solver/lsolve.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/solver/usolve.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/solver/lusolve.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/solver/utils/solveValidation.js"],"names":["exports","name","factory","type","config","load","typed","matrix","__webpack_require__","divideScalar","multiplyScalar","subtract","equalScalar","solveValidation","DenseMatrix","_denseForwardSubstitution","m","b","bdata","_data","rows","_size","columns","x","data","j","bj","xj","vjj","Error","i","size","SparseMatrix, Array | Matrix","k","values","_values","index","_index","ptr","_ptr","jvalues","jindex","l","push","length","_sparseForwardSubstitution","DenseMatrix, Array | Matrix","Array, Array | Matrix","a","valueOf","_denseBackwardSubstitution","f","_sparseBackwardSubstitution","isArray","Array","lup","slu","csIpvec","usolve","lsolve","lusolve","d","_lusolve","L","U","p","SparseMatrix, Array | Matrix, number, number","order","threshold","q","Object, Array | Matrix","_toMatrix","isMatrix","TypeError","u","y","util","string","array","copy","RangeError","format","msize","datatype","_datatype","isDenseMatrix","k1","asize"],"mappings":"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","file":"js/f365fab320786edaa67b.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  var equalScalar = load(require('../../relational/equalScalar'));\n  var solveValidation = load(require('./utils/solveValidation'));\n  var DenseMatrix = type.DenseMatrix;\n  /**\n   * Solves the linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  var lsolve = typed('lsolve', {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // create dense matrix from array\n      var m = matrix(a); // use matrix implementation\n\n      var r = _denseForwardSubstitution(m, b); // result\n\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = []; // data\n\n    var data = m._data; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = data[j][j]; // check vjj\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];\n        }\n      } else {\n        // zero @ j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // matrix arrays\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // vars\n\n    var i, k; // result\n\n    var x = []; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = 0; // lower triangular matrix values & index (column j)\n\n        var jvalues = [];\n        var jindex = []; // last index in column\n\n        var l = ptr[j + 1]; // values in column, find value @ [j, j]\n\n        for (k = ptr[j]; k < l; k++) {\n          // row\n          i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            // update vjj\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jvalues.push(values[k]);\n            jindex.push(i);\n          }\n        } // at this point we must have a value @ [j, j]\n\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved, there is no value @ [j, j]\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        var xj = divideScalar(bj, vjj); // loop lower triangular\n\n        for (k = 0, l = jindex.length; k < l; k++) {\n          // row\n          i = jindex[k]; // update copy of b\n\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, jvalues[k]))];\n        } // update x\n\n\n        x[j] = [xj];\n      } else {\n        // update x\n        x[j] = [0];\n      }\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  return lsolve;\n}\n\nexports.name = 'lsolve';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  var equalScalar = load(require('../../relational/equalScalar'));\n  var solveValidation = load(require('./utils/solveValidation'));\n  var DenseMatrix = type.DenseMatrix;\n  /**\n   * Solves the linear equation system by backward substitution. Matrix must be an upper triangular matrix.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [[8], [9]]\n   *\n   * See also:\n   *\n   *    lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  var usolve = typed('usolve', {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // create dense matrix from array\n      var m = matrix(a); // use matrix implementation\n\n      var r = _denseBackwardSubstitution(m, b); // result\n\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = []; // arrays\n\n    var data = m._data; // backward solve m * x = b, loop columns (backwards)\n\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0; // backward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = data[j][j]; // check vjj\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];\n        }\n      } else {\n        // zero value @ j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    } // return column vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // matrix arrays\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // vars\n\n    var i, k; // result\n\n    var x = []; // backward solve m * x = b, loop columns (backwards)\n\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // backward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = 0; // upper triangular matrix values & index (column j)\n\n        var jvalues = [];\n        var jindex = []; // first & last indeces in column\n\n        var f = ptr[j];\n        var l = ptr[j + 1]; // values in column, find value @ [j, j], loop backwards\n\n        for (k = l - 1; k >= f; k--) {\n          // row\n          i = index[k]; // check row\n\n          if (i === j) {\n            // update vjj\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jvalues.push(values[k]);\n            jindex.push(i);\n          }\n        } // at this point we must have a value @ [j, j]\n\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved, there is no value @ [j, j]\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        var xj = divideScalar(bj, vjj); // loop upper triangular\n\n        for (k = 0, l = jindex.length; k < l; k++) {\n          // row\n          i = jindex[k]; // update copy of b\n\n          bdata[i] = [subtract(bdata[i][0], multiplyScalar(xj, jvalues[k]))];\n        } // update x\n\n\n        x[j] = [xj];\n      } else {\n        // update x\n        x[j] = [0];\n      }\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  return usolve;\n}\n\nexports.name = 'usolve';\nexports.factory = factory;","'use strict';\n\nvar isArray = Array.isArray;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n  var lup = load(require('../decomposition/lup'));\n  var slu = load(require('../decomposition/slu'));\n  var csIpvec = load(require('../sparse/csIpvec'));\n  var solveValidation = load(require('./utils/solveValidation'));\n  var usolve = load(require('./usolve'));\n  var lsolve = load(require('./lsolve'));\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  var lusolve = typed('lusolve', {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // convert a to matrix\n      a = matrix(a); // matrix lup decomposition\n\n      var d = lup(a); // solve\n\n      var x = _lusolve(d.L, d.U, d.p, null, b); // convert result to array\n\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      // matrix lu decomposition\n      var d = slu(a, order, threshold); // solve\n\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      // solve\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  var _toMatrix = function _toMatrix(a) {\n    // check it is a matrix\n    if (type.isMatrix(a)) {\n      return a;\n    } // check array\n\n\n    if (isArray(a)) {\n      return matrix(a);\n    } // throw\n\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  };\n\n  function _lusolve(l, u, p, q, b) {\n    // verify L, U, P\n    l = _toMatrix(l);\n    u = _toMatrix(u); // validate matrix and vector\n\n    b = solveValidation(l, b, false); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b._data = csIpvec(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    } // return solution\n\n\n    return x;\n  }\n\n  return lusolve;\n}\n\nexports.name = 'lusolve';\nexports.factory = factory;","'use strict';\n\nvar util = require('../../../../utils/index');\n\nvar string = util.string;\nvar array = util.array;\nvar isArray = Array.isArray;\n\nfunction factory(type) {\n  var DenseMatrix = type.DenseMatrix;\n  /**\n   * Validates matrix and column vector b for backward/forward substitution algorithms.\n   *\n   * @param {Matrix} m            An N x N matrix\n   * @param {Array | Matrix} b    A column vector\n   * @param {Boolean} copy        Return a copy of vector b\n   *\n   * @return {DenseMatrix}        Dense column vector b\n   */\n\n  var solveValidation = function solveValidation(m, b, copy) {\n    // matrix size\n    var size = m.size(); // validate matrix dimensions\n\n    if (size.length !== 2) {\n      throw new RangeError('Matrix must be two dimensional (size: ' + string.format(size) + ')');\n    } // rows & columns\n\n\n    var rows = size[0];\n    var columns = size[1]; // validate rows & columns\n\n    if (rows !== columns) {\n      throw new RangeError('Matrix must be square (size: ' + string.format(size) + ')');\n    } // vars\n\n\n    var data, i, bdata; // check b is matrix\n\n    if (type.isMatrix(b)) {\n      // matrix size\n      var msize = b.size(); // vector\n\n      if (msize.length === 1) {\n        // check vector length\n        if (msize[0] !== rows) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        } // create data array\n\n\n        data = []; // matrix data (DenseMatrix)\n\n        bdata = b._data; // loop b data\n\n        for (i = 0; i < rows; i++) {\n          // row array\n          data[i] = [bdata[i]];\n        } // return Dense Matrix\n\n\n        return new DenseMatrix({\n          data: data,\n          size: [rows, 1],\n          datatype: b._datatype\n        });\n      } // two dimensions\n\n\n      if (msize.length === 2) {\n        // array must be a column vector\n        if (msize[0] !== rows || msize[1] !== 1) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        } // check matrix type\n\n\n        if (type.isDenseMatrix(b)) {\n          // check a copy is needed\n          if (copy) {\n            // create data array\n            data = []; // matrix data (DenseMatrix)\n\n            bdata = b._data; // loop b data\n\n            for (i = 0; i < rows; i++) {\n              // row array\n              data[i] = [bdata[i][0]];\n            } // return Dense Matrix\n\n\n            return new DenseMatrix({\n              data: data,\n              size: [rows, 1],\n              datatype: b._datatype\n            });\n          } // b is already a column vector\n\n\n          return b;\n        } // create data array\n\n\n        data = [];\n\n        for (i = 0; i < rows; i++) {\n          data[i] = [0];\n        } // sparse matrix arrays\n\n\n        var values = b._values;\n        var index = b._index;\n        var ptr = b._ptr; // loop values in column 0\n\n        for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {\n          // row\n          i = index[k]; // add to data\n\n          data[i][0] = values[k];\n        } // return Dense Matrix\n\n\n        return new DenseMatrix({\n          data: data,\n          size: [rows, 1],\n          datatype: b._datatype\n        });\n      } // throw error\n\n\n      throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n    } // check b is array\n\n\n    if (isArray(b)) {\n      // size\n      var asize = array.size(b); // check matrix dimensions, vector\n\n      if (asize.length === 1) {\n        // check vector length\n        if (asize[0] !== rows) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        } // create data array\n\n\n        data = []; // loop b\n\n        for (i = 0; i < rows; i++) {\n          // row array\n          data[i] = [b[i]];\n        } // return Dense Matrix\n\n\n        return new DenseMatrix({\n          data: data,\n          size: [rows, 1]\n        });\n      }\n\n      if (asize.length === 2) {\n        // array must be a column vector\n        if (asize[0] !== rows || asize[1] !== 1) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        } // create data array\n\n\n        data = []; // loop b data\n\n        for (i = 0; i < rows; i++) {\n          // row array\n          data[i] = [b[i][0]];\n        } // return Dense Matrix\n\n\n        return new DenseMatrix({\n          data: data,\n          size: [rows, 1]\n        });\n      } // throw error\n\n\n      throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n    }\n  };\n\n  return solveValidation;\n}\n\nexports.factory = factory;"],"sourceRoot":""}