{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/simplify/simplifyConstant.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/simplify/simplifyCore.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/simplify/resolve.js"],"names":["exports","math","name","path","factory","type","config","load","typed","util","__webpack_require__","isCommutative","isAssociative","allChildren","createMakeNodeFunction","ConstantNode","expression","node","OperatorNode","FunctionNode","_eval","fnname","args","options","_toNumber","apply","ignore","map","x","isFraction","valueOf","_toNode","Fraction","f","n","vn","s","d","number","unaryMinusNode","BigNumber","Complex","Error","_exactFraction","exactFractions","isFinite","fraction","string, Object","bignumber","parseFloat","Fraction, Object","BigNumber, Object","number, Object","Complex, Object","im","re","foldOp","fn","makeNode","reduce","a","b","isNode","ignoreandcontinue","expr","res","foldFraction","value","isNaN","rawArgs","indexOf","_args","arg","some","ignoreandcontine","toString","isUnary","consts","vars","i","length","push","unshift","content","concat","equal","isZero","add","subtract","multiply","divide","pow","ParenthesisNode","node0","node1","simplifyCore","isOperatorNode","a0","op","isBinary","_a","a1","isConstantNode","a00","a00a1","implicit","a01","isParenthesisNode","c","isSymbolNode","isFunctionNode","Node","resolve","scope","parse","String"],"mappings":"2FAqSAA,EAAAC,MAAA,EACAD,EAAAE,KAAA,mBACAF,EAAAG,KAAA,mBACAH,EAAAI,QAtSA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAP,GACA,IAAAQ,EAAAF,EAAkBG,EAAQ,MAC1BC,EAAAF,EAAAE,cACAC,EAAAH,EAAAG,cACAC,EAAAJ,EAAAI,YACAC,EAAAL,EAAAK,uBACAC,EAAAd,EAAAe,WAAAC,KAAAF,aACAG,EAAAjB,EAAAe,WAAAC,KAAAC,aACAC,EAAAlB,EAAAe,WAAAC,KAAAE,aAOA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IACA,OAAAC,EAAAvB,EAAAoB,GAAAI,MAAA,KAAAH,GAAAC,GACK,MAAAG,GASL,OAPAJ,IAAAK,IAAA,SAAAC,GACA,OAAAvB,EAAAwB,WAAAD,GACAA,EAAAE,UAGAF,IAEAJ,EAAAvB,EAAAoB,GAAAI,MAAA,KAAAH,GAAAC,IAIA,IAAAQ,EAAAvB,EAAA,CACAwB,SAwEA,SAAAC,GACA,IAAAC,EACAC,EAAAF,EAAAG,EAAAH,EAAAC,EAQA,OALAA,EADAC,EAAA,EACA,IAAAjB,EAAA,sBAAAH,GAAAoB,KAEA,IAAApB,EAAAoB,GAGA,IAAAF,EAAAI,EACAH,EAGA,IAAAhB,EAAA,cAAAgB,EAAA,IAAAnB,EAAAkB,EAAAI,MArFAC,OAAA,SAAAJ,GACA,OAAAA,EAAA,EACAK,EAAA,IAAAxB,GAAAmB,IAGA,IAAAnB,EAAAmB,IAEAM,UAAA,SAAAN,GACA,OAAAA,EAAA,EACAK,EAAA,IAAAxB,GAAAmB,IAGA,IAAAnB,EAAAmB,IAEAO,QAAA,SAAAL,GACA,UAAAM,MAAA,4CAKA,SAAAC,EAAAT,EAAAX,GAGA,GAFAA,IAAA,IAAAA,EAAAqB,gBAEAC,SAAAX,GAAA,CACA,IAAAD,EAAAhC,EAAA6C,SAAAZ,GAEA,GAAAD,EAAAH,YAAAI,EACA,OAAAD,EAIA,OAAAC,EAKA,IAAAV,EAAAhB,EAAA,CACAuC,iBAAA,SAAAX,EAAAb,GACA,oBAAAjB,EAAAgC,OACArC,EAAA+C,UAAAZ,GACO,aAAA9B,EAAAgC,OACPrC,EAAA6C,SAAAV,GAGAO,EADAM,WAAAb,GACAb,IAGA2B,mBAAA,SAAAd,EAAAb,GACA,OAAAa,GAGAe,oBAAA,SAAAf,EAAAb,GACA,OAAAa,GAGAgB,iBAAA,SAAAhB,EAAAb,GACA,OAAAoB,EAAAP,EAAAb,IAEA8B,kBAAA,SAAAjB,EAAAb,GACA,WAAAa,EAAAkB,GACAlB,EAGAO,EAAAP,EAAAmB,GAAAhC,MAIA,SAAAgB,EAAAL,GACA,WAAAhB,EAAA,kBAAAgB,IA+BA,SAAAsB,EAAAC,EAAAnC,EAAAoC,EAAAnC,GACA,OAAAD,EAAAqC,OAAA,SAAAC,EAAAC,GACA,GAAAxD,EAAAyD,OAAAF,IAAAvD,EAAAyD,OAAAD,GAOOxD,EAAAyD,OAAAF,GAEAvD,EAAAyD,OAAAD,KACPA,EAAA9B,EAAA8B,IAFAD,EAAA7B,EAAA6B,OARA,CACA,IACA,OAAAxC,EAAAqC,EAAA,CAAAG,EAAAC,GAAAtC,GACS,MAAAwC,IAETH,EAAA7B,EAAA6B,GACAC,EAAA9B,EAAA8B,GAOA,OAAAH,EAAA,CAAAE,EAAAC,MA6IA,OAtRA,SAAAG,EAAAzC,GACA,IAAA0C,EA6IA,SAAAC,EAAAjD,EAAAM,GACA,OAAAN,EAAAZ,MACA,iBACA,OAAAY,EAEA,mBACA,uBAAAA,EAAAkD,OAAAC,MAAAnD,EAAAkD,OAIAlD,EAHAO,EAAAP,EAAAkD,MAAA5C,GAKA,mBACA,GAAAtB,EAAAgB,EAAAf,OAAAD,EAAAgB,EAAAf,MAAAmE,QACA,OAAApD,EAMA,QAFA,mBAEAqD,QAAArD,EAAAf,MAAA,CACA,IAAAqE,EAAAtD,EAAAK,KAAAK,IAAA,SAAA6C,GACA,OAAAN,EAAAM,EAAAjD,KAIA,IAAAgD,EAAAE,KAAApE,EAAAyD,QACA,IACA,OAAA1C,EAAAH,EAAAf,KAAAqE,EAAAhD,GACa,MAAAmD,IAOb,OAHAH,IAAA5C,IAAA,SAAA6C,GACA,OAAAnE,EAAAyD,OAAAU,KAAAzC,EAAAyC,KAEA,IAAArD,EAAAF,EAAAf,KAAAqE,GAMA,mBACA,IACAjD,EACA2C,EAFAR,EAAAxC,EAAAwC,GAAAkB,WAGAjB,EAAA5C,EAAAG,GAEA,GAAAA,EAAA2D,UACAtD,EAAA,CAAA4C,EAAAjD,EAAAK,KAAA,GAAAC,IAKA0C,EAHA5D,EAAAyD,OAAAxC,EAAA,IAGAoC,EAAApC,GAFAF,EAAAqC,EAAAnC,EAAAC,QAIS,GAAAX,EAAAK,GAMT,GAJAK,GADAA,EAAAT,EAAAI,IACAU,IAAA,SAAA6C,GACA,OAAAN,EAAAM,EAAAjD,KAGAZ,EAAA8C,GAAA,CAKA,IAHA,IAAAoB,EAAA,GACAC,EAAA,GAEAC,EAAA,EAA2BA,EAAAzD,EAAA0D,OAAiBD,IAC5C1E,EAAAyD,OAAAxC,EAAAyD,IAGAD,EAAAG,KAAA3D,EAAAyD,IAFAF,EAAAI,KAAA3D,EAAAyD,IAMAF,EAAAG,OAAA,GACAf,EAAAT,EAAAC,EAAAoB,EAAAnB,EAAAnC,GACAuD,EAAAI,QAAAjB,GACAA,EAAAT,EAAAC,EAAAqB,EAAApB,EAAAnC,IAGA0C,EAAAT,EAAAC,EAAAnC,EAAAoC,EAAAnC,QAIA0C,EAAAT,EAAAC,EAAAnC,EAAAoC,EAAAnC,QAIAD,EAAAL,EAAAK,KAAAK,IAAA,SAAA6C,GACA,OAAAN,EAAAM,EAAAjD,KAEA0C,EAAAT,EAAAC,EAAAnC,EAAAoC,EAAAnC,GAGA,OAAA0C,EAEA,sBAEA,OAAAC,EAAAjD,EAAAkE,QAAA5D,GAEA,mBAGA,gBAGA,qBAGA,gBAGA,6BAGA,gBAGA,iBAGA,gBAGA,iBAGA,sBAGA,QACA,UAAAmB,MAAA,gDAAA0C,OAAAnE,EAAAZ,QAjRA6D,CAAAF,EAAAzC,GACA,OAAAlB,EAAAyD,OAAAG,KAAAlC,EAAAkC,uCC8KAjE,EAAAC,MAAA,EACAD,EAAAE,KAAA,eACAF,EAAAG,KAAA,mBACAH,EAAAI,QA7LA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAP,GACA,IAAAoF,EAAA9E,EAAmBG,EAAQ,KAC3B4E,EAAA/E,EAAoBG,EAAQ,KAC5B6E,EAAAhF,EAAiBG,EAAQ,KACzB8E,EAAAjF,EAAsBG,EAAQ,KAC9B+E,EAAAlF,EAAsBG,EAAQ,KAC9BgF,EAAAnF,EAAoBG,EAAQ,KAC5BiF,EAAApF,EAAiBG,EAAQ,KACzBK,EAAAd,EAAAe,WAAAC,KAAAF,aACAG,EAAAjB,EAAAe,WAAAC,KAAAC,aACAC,EAAAlB,EAAAe,WAAAC,KAAAE,aACAyE,EAAA3F,EAAAe,WAAAC,KAAA2E,gBACAC,EAAA,IAAA9E,EAAA,GACA+E,EAAA,IAAA/E,EAAA,GA0KA,OAjJA,SAAAgF,EAAA9E,GACA,GAAAZ,EAAA2F,eAAA/E,MAAA2D,UAAA,CACA,IAAAqB,EAAAF,EAAA9E,EAAAK,KAAA,IAEA,SAAAL,EAAAiF,GAEA,OAAAD,EAGA,SAAAhF,EAAAiF,GAAA,CAEA,GAAA7F,EAAA2F,eAAAC,GAAA,CACA,GAAAA,EAAArB,WAAA,MAAAqB,EAAAC,GACA,OAAAD,EAAA3E,KAAA,GACW,GAAA2E,EAAAE,YAAA,aAAAF,EAAAxC,GACX,WAAAvC,EAAA,gBAAA+E,EAAA3E,KAAA,GAAA2E,EAAA3E,KAAA,KAIA,WAAAJ,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAAwC,UAEK,GAAA5F,EAAA2F,eAAA/E,MAAAkF,WAAA,CACL,IAAAC,EAAAL,EAAA9E,EAAAK,KAAA,IAEA+E,EAAAN,EAAA9E,EAAAK,KAAA,IAEA,SAAAL,EAAAiF,GAAA,CACA,GAAA7F,EAAAiG,eAAAF,GAAA,CACA,GAAAd,EAAAc,EAAAjC,OACA,OAAAkC,EACW,GAAAhG,EAAAiG,eAAAD,GACX,WAAAtF,EAAAwE,EAAAa,EAAAjC,MAAAkC,EAAAlC,QAIA,OAAA9D,EAAAiG,eAAAD,IAAAf,EAAAe,EAAAlC,OACAiC,EAGA/F,EAAA2F,eAAAK,MAAAzB,WAAA,MAAAyB,EAAAH,GACA,IAAAhF,EAAA,gBAAAkF,EAAAC,EAAA/E,KAAA,KAGA,IAAAJ,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA4C,EAAA,CAAAD,EAAAC,GAAA,CAAAD,IACO,SAAAnF,EAAAiF,GAAA,CACP,GAAA7F,EAAAiG,eAAAF,IAAAC,EAAA,CACA,GAAAhG,EAAAiG,eAAAD,GACA,WAAAtF,EAAAyE,EAAAY,EAAAjC,MAAAkC,EAAAlC,QACW,GAAAmB,EAAAc,EAAAjC,OACX,WAAAjD,EAAA,kBAAAmF,IAKA,gBAAApF,EAAAwC,GACA,OAAApD,EAAAiG,eAAAD,IAAAf,EAAAe,EAAAlC,OACAiC,EAGA/F,EAAA2F,eAAAK,MAAAzB,WAAA,MAAAyB,EAAAH,GACAH,EAAA,IAAA7E,EAAA,WAAAkF,EAAAC,EAAA/E,KAAA,MAGA,IAAAJ,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA2C,EAAAC,QAEO,UAAApF,EAAAiF,GAAA,CACP,GAAA7F,EAAAiG,eAAAF,GAAA,CACA,GAAAd,EAAAc,EAAAjC,OACA,OAAA0B,EACW,GAAAR,EAAAe,EAAAjC,MAAA,GACX,OAAAkC,EACW,GAAAhG,EAAAiG,eAAAD,GACX,WAAAtF,EAAA0E,EAAAW,EAAAjC,MAAAkC,EAAAlC,QAIA,GAAA9D,EAAAiG,eAAAD,GAAA,CACA,GAAAf,EAAAe,EAAAlC,OACA,OAAA0B,EACW,GAAAR,EAAAgB,EAAAlC,MAAA,GACX,OAAAiC,EACW,GAAA/F,EAAA2F,eAAAI,MAAAD,YAAAC,EAAAF,KAAAjF,EAAAiF,GAAA,CACX,IAAAK,EAAAH,EAAA9E,KAAA,GAEA,GAAAjB,EAAAiG,eAAAC,GAAA,CACA,IAAAC,EAAA,IAAAzF,EAAA0E,EAAAc,EAAApC,MAAAkC,EAAAlC,QACA,WAAAjD,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA+C,EAAAJ,EAAA9E,KAAA,IAAAL,EAAAwF,WAIA,WAAAvF,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA4C,EAAAD,GAAAnF,EAAAwF,UAGA,WAAAvF,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA2C,EAAAC,GAAApF,EAAAwF,UACO,SAAAxF,EAAAiF,GAAA,CACP,GAAA7F,EAAAiG,eAAAF,GAAA,CACA,GAAAd,EAAAc,EAAAjC,OACA,OAAA0B,EACW,GAAAxF,EAAAiG,eAAAD,KAAAhB,EAAAgB,EAAAlC,MAAA,IAAAkB,EAAAgB,EAAAlC,MAAA,IAAAkB,EAAAgB,EAAAlC,MAAA,IACX,WAAApD,EAAA2E,EAAAU,EAAAjC,MAAAkC,EAAAlC,QAIA,WAAAjD,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA2C,EAAAC,IACO,SAAApF,EAAAiF,GAAA,CACP,GAAA7F,EAAAiG,eAAAD,GAAA,CACA,GAAAf,EAAAe,EAAAlC,OACA,OAAA2B,EACW,GAAAT,EAAAgB,EAAAlC,MAAA,GACX,OAAAiC,EAEA,GAAA/F,EAAAiG,eAAAF,GAEA,WAAArF,EAAA4E,EAAAS,EAAAjC,MAAAkC,EAAAlC,QACa,GAAA9D,EAAA2F,eAAAI,MAAAD,YAAA,MAAAC,EAAAF,GAAA,CACb,IAAAQ,EAAAN,EAAA9E,KAAA,GAEA,GAAAjB,EAAAiG,eAAAI,GACA,WAAAxF,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA2C,EAAA9E,KAAA,OAAAP,EAAA0E,EAAAiB,EAAAvC,MAAAkC,EAAAlC,WAMA,WAAAjD,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAA,CAAA2C,EAAAC,UAEK,IAAAhG,EAAAsG,kBAAA1F,GAAA,CACL,IAAA2F,EAAAb,EAAA9E,EAAAkE,SAEA,OAAA9E,EAAAsG,kBAAAC,IAAAvG,EAAAwG,aAAAD,IAAAvG,EAAAiG,eAAAM,GACAA,EAGA,IAAAhB,EAAAgB,GACK,GAAAvG,EAAAyG,eAAA7F,GAAA,CACL,IAAAK,EAAAL,EAAAK,KAAAK,IAAAoE,GAAApE,IAAA,SAAA6C,GACA,OAAAnE,EAAAsG,kBAAAnC,KAAAW,QAAAX,IAEA,WAAArD,EAAA4E,EAAA9E,EAAAwC,IAAAnC,IAIA,OAAAL,sCC3HAjB,EAAAC,MAAA,EACAD,EAAAE,KAAA,UACAF,EAAAG,KAAA,mBACAH,EAAAI,QA5DA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAP,GACA,IAAA8G,EAAA9G,EAAAe,WAAAC,KAAA8F,KACA7F,EAAAjB,EAAAe,WAAAC,KAAAC,aACAC,EAAAlB,EAAAe,WAAAC,KAAAE,aACAyE,EAAA3F,EAAAe,WAAAC,KAAA2E,gBAkDA,OA/BA,SAAAoB,EAAA/F,EAAAgG,GACA,IAAAA,EACA,OAAAhG,EAGA,GAAAZ,EAAAwG,aAAA5F,GAAA,CACA,IAAAkD,EAAA8C,EAAAhG,EAAAf,MAEA,GAAAiE,aAAA4C,EACA,OAAAC,EAAA7C,EAAA8C,GACO,oBAAA9C,EACP,OAAAlE,EAAAiH,MAAAC,OAAAhD,QAEK,IAAA9D,EAAA2F,eAAA/E,GAAA,CACL,IAAAK,EAAAL,EAAAK,KAAAK,IAAA,SAAA6C,GACA,OAAAwC,EAAAxC,EAAAyC,KAEA,WAAA/F,EAAAD,EAAAiF,GAAAjF,EAAAwC,GAAAnC,EAAAL,EAAAwF,UACK,GAAApG,EAAAsG,kBAAA1F,GACL,WAAA2E,EAAAoB,EAAA/F,EAAAkE,QAAA8B,IACK,GAAA5G,EAAAyG,eAAA7F,GAAA,CACL,IAAAsD,EAAAtD,EAAAK,KAAAK,IAAA,SAAA6C,GACA,OAAAwC,EAAAxC,EAAAyC,KAGA,WAAA9F,EAAAF,EAAAf,KAAAqE,IAGA,OAAAtD","file":"js/87739af3a5face34a649.js","sourcesContent":["'use strict'; // TODO this could be improved by simplifying seperated constants under associative and commutative operators\n\nfunction factory(type, config, load, typed, math) {\n  var util = load(require('./util'));\n  var isCommutative = util.isCommutative;\n  var isAssociative = util.isAssociative;\n  var allChildren = util.allChildren;\n  var createMakeNodeFunction = util.createMakeNodeFunction;\n  var ConstantNode = math.expression.node.ConstantNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return type.isNode(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(math[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if (type.isFraction(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(math[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    'Fraction': _fractionToNode,\n    'number': function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    'BigNumber': function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    'Complex': function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n)) {\n      var f = math.fraction(n);\n\n      if (f.valueOf() === n) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        return math.bignumber(s);\n      } else if (config.number === 'Fraction') {\n        return math.fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!type.isNode(a) && !type.isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!type.isNode(a)) {\n        a = _toNode(a);\n      } else if (!type.isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (math[node.name] && math[node.name].rawArgs) {\n          return node;\n        } // Process operators as OperatorNode\n\n\n        var operatorFunctions = ['add', 'multiply'];\n\n        if (operatorFunctions.indexOf(node.name) === -1) {\n          var _args = node.args.map(function (arg) {\n            return foldFraction(arg, options);\n          }); // If all args are numbers\n\n\n          if (!_args.some(type.isNode)) {\n            try {\n              return _eval(node.name, _args, options);\n            } catch (ignoreandcontine) {}\n          } // Convert all args to nodes and construct a symbolic function call\n\n\n          _args = _args.map(function (arg) {\n            return type.isNode(arg) ? arg : _toNode(arg);\n          });\n          return new FunctionNode(node.name, _args);\n        } else {} // treat as operator\n\n        /* falls through */\n\n\n      case 'OperatorNode':\n        var fn = node.fn.toString();\n        var args;\n        var res;\n        var makeNode = createMakeNodeFunction(node);\n\n        if (node.isUnary()) {\n          args = [foldFraction(node.args[0], options)];\n\n          if (!type.isNode(args[0])) {\n            res = _eval(fn, args, options);\n          } else {\n            res = makeNode(args);\n          }\n        } else if (isAssociative(node)) {\n          args = allChildren(node);\n          args = args.map(function (arg) {\n            return foldFraction(arg, options);\n          });\n\n          if (isCommutative(fn)) {\n            // commutative binary operator\n            var consts = [];\n            var vars = [];\n\n            for (var i = 0; i < args.length; i++) {\n              if (!type.isNode(args[i])) {\n                consts.push(args[i]);\n              } else {\n                vars.push(args[i]);\n              }\n            }\n\n            if (consts.length > 1) {\n              res = foldOp(fn, consts, makeNode, options);\n              vars.unshift(res);\n              res = foldOp(fn, vars, makeNode, options);\n            } else {\n              // we won't change the children order since it's not neccessary\n              res = foldOp(fn, args, makeNode, options);\n            }\n          } else {\n            // non-commutative binary operator\n            res = foldOp(fn, args, makeNode, options);\n          }\n        } else {\n          // non-associative binary operator\n          args = node.args.map(function (arg) {\n            return foldFraction(arg, options);\n          });\n          res = foldOp(fn, args, makeNode, options);\n        }\n\n        return res;\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'UpdateNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n}\n\nexports.math = true;\nexports.name = 'simplifyConstant';\nexports.path = 'algebra.simplify';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var equal = load(require('../../relational/equal'));\n  var isZero = load(require('../../utils/isZero'));\n  var add = load(require('../../arithmetic/add'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  var multiply = load(require('../../arithmetic/multiply'));\n  var divide = load(require('../../arithmetic/divide'));\n  var pow = load(require('../../arithmetic/pow'));\n  var ConstantNode = math.expression.node.ConstantNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n  var ParenthesisNode = math.expression.node.ParenthesisNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (type.isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (type.isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (type.isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (type.isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (type.isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (type.isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (type.isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (type.isConstantNode(_a) && a1) {\n          if (type.isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (type.isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (type.isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (type.isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (type.isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (type.isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (type.isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (type.isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (type.isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (type.isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (type.isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (type.isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (type.isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (type.isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (type.isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (type.isParenthesisNode(c) || type.isSymbolNode(c) || type.isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (type.isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return type.isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n}\n\nexports.math = true;\nexports.name = 'simplifyCore';\nexports.path = 'algebra.simplify';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var Node = math.expression.node.Node;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n  var ParenthesisNode = math.expression.node.ParenthesisNode;\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     simplify.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // \"6\"\n   *\n   * @param {Node} node\n   *     The expression tree to be simplified\n   * @param {Object} scope with variables to be resolved\n   */\n\n  function resolve(node, scope) {\n    if (!scope) {\n      return node;\n    }\n\n    if (type.isSymbolNode(node)) {\n      var value = scope[node.name];\n\n      if (value instanceof Node) {\n        return resolve(value, scope);\n      } else if (typeof value === 'number') {\n        return math.parse(String(value));\n      }\n    } else if (type.isOperatorNode(node)) {\n      var args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if (type.isParenthesisNode(node)) {\n      return new ParenthesisNode(resolve(node.content, scope));\n    } else if (type.isFunctionNode(node)) {\n      var _args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n\n      return new FunctionNode(node.name, _args);\n    }\n\n    return node;\n  }\n\n  return resolve;\n}\n\nexports.math = true;\nexports.name = 'resolve';\nexports.path = 'algebra.simplify';\nexports.factory = factory;"],"sourceRoot":""}