{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/algebra/derivative.js"],"names":["exports","name","factory","type","config","load","typed","parse","__webpack_require__","simplify","equal","isZero","getType","numeric","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode","derivative","Node, SymbolNode, Object","expr","variable","options","constNodes","constTag","res","_derivative","Node, SymbolNode","string, SymbolNode","string, SymbolNode, Object","string, string","string, string, Object","Node, string","Node, string, Object","_simplify","toTex","deriv","_derivTex","apply","args","x","isConstantNode","value","toString","Node, ConstantNode","Error","Node, SymbolNode, ConstantNode","order","string, string, number","concat","Object, ConstantNode, string","node","Object, SymbolNode, string","varName","Object, ParenthesisNode, string","content","Object, FunctionAssignmentNode, string","params","indexOf","Object, FunctionNode | OperatorNode, string","length","isConst","i","ConstantNode, Object","createConstantNode","SymbolNode, Object","undefined","ParenthesisNode, Object","FunctionAssignmentNode, Object","FunctionNode, Object","compile","eval","funcArgsCheck","arg1","funcDerivative","op","func","arg0","div","negative","clone","chainDerivative","OperatorNode, Object","fn","map","arg","isUnary","isBinary","constantTerms","filter","nonConstantTerms","nonConstantNode","newArgs","argOuter","argInner","_arg","_arg2","powMinusOne","valueType","number"],"mappings":"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","file":"js/6bf85c91859e230bf82e.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  var parse = load(require('../../expression/parse'));\n  var simplify = load(require('./simplify'));\n  var equal = load(require('../relational/equal'));\n  var isZero = load(require('../utils/isZero'));\n  var getType = load(require('../utils/typeof'));\n  var numeric = load(require('../../type/numeric'));\n  var ConstantNode = load(require('../../expression/node/ConstantNode'));\n  var FunctionNode = load(require('../../expression/node/FunctionNode'));\n  var OperatorNode = load(require('../../expression/node/OperatorNode'));\n  var ParenthesisNode = load(require('../../expression/node/ParenthesisNode'));\n  var SymbolNode = load(require('../../expression/node/SymbolNode'));\n  /**\n   * Takes the derivative of an expression expressed in parser Nodes.\n   * The derivative will be taken over the supplied variable in the\n   * second parameter. If there are multiple variables in the expression,\n   * it will return a partial derivative.\n   *\n   * This uses rules of differentiation which can be found here:\n   *\n   * - [Differentiation rules (Wikipedia)](http://en.wikipedia.org/wiki/Differentiation_rules)\n   *\n   * Syntax:\n   *\n   *     derivative(expr, variable)\n   *     derivative(expr, variable, options)\n   *\n   * Examples:\n   *\n   *     math.derivative('x^2', 'x')                     // Node {2 * x}\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)\n   *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}\n   *     math.derivative('2*x', 'x').eval()              // number 2\n   *     math.derivative('x^2', 'x').eval({x: 4})        // number 8\n   *     const f = math.parse('x^2')\n   *     const x = math.parse('x')\n   *     math.derivative(f, x)                           // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, parse, eval\n   *\n   * @param  {Node | string} expr           The expression to differentiate\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\n   * @param  {{simplify: boolean}} [options]\n   *                         There is one option available, `simplify`, which\n   *                         is true by default. When false, output will not\n   *                         be simplified.\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n\n  var derivative = typed('derivative', {\n    'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {\n      var constNodes = {};\n      constTag(constNodes, expr, variable.name);\n\n      var res = _derivative(expr, constNodes);\n\n      return options.simplify ? simplify(res) : res;\n    },\n    'Node, SymbolNode': function NodeSymbolNode(expr, variable) {\n      return derivative(expr, variable, {\n        simplify: true\n      });\n    },\n    'string, SymbolNode': function stringSymbolNode(expr, variable) {\n      return derivative(parse(expr), variable);\n    },\n    'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {\n      return derivative(parse(expr), variable, options);\n    },\n    'string, string': function stringString(expr, variable) {\n      return derivative(parse(expr), parse(variable));\n    },\n    'string, string, Object': function stringStringObject(expr, variable, options) {\n      return derivative(parse(expr), parse(variable), options);\n    },\n    'Node, string': function NodeString(expr, variable) {\n      return derivative(expr, parse(variable));\n    },\n    'Node, string, Object': function NodeStringObject(expr, variable, options) {\n      return derivative(expr, parse(variable), options);\n    } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\n      let res = expr\n      for (let i = 0; i < order; i++) {\n        let constNodes = {}\n        constTag(constNodes, expr, variable.name)\n        res = _derivative(res, constNodes)\n      }\n      return res\n    }\n    */\n\n  });\n  derivative._simplify = true;\n\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  }; // NOTE: the optional \"order\" parameter here is currently unused\n\n\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function NodeSymbolNode(expr, x) {\n      if (type.isConstantNode(expr) && getType(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toString(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function NodeConstantNode(expr, x) {\n      if (getType(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function stringStringNumber(expr, x, order) {\n      var d;\n\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n  /**\n   * Does a depth-first search on the expression tree to identify what Nodes\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\n   * constNodes. Classification is done as follows:\n   *\n   *   1. ConstantNodes are constants.\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\n   *      in the subtree it is not constant.\n   *\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {string} varName     Variable that we are differentiating\n   * @return {boolean}  if node is constant\n   */\n  // TODO: can we rewrite constTag into a pure function?\n\n\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return false;\n    },\n    'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {\n      if (node.params.indexOf(varName) === -1) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  /**\n   * Applies differentiation rules.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNodeObject(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {\n      if (node.args.length !== 1) {\n        funcArgsCheck(node);\n      }\n\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?\n\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n\n          break;\n\n        case 'log10':\n          arg1 = createConstantNode(10);\n\n        /* fall through! */\n\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n\n          break;\n\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n\n        default:\n          throw new Error('Function \"' + node.name + '\" is not supported by derivative, or a wrong number of arguments is passed');\n      }\n\n      var op, func;\n\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n      /* Apply chain rule to all functions:\n         F(x)  = f(g(x))\n         F'(x) = g'(x)*f'(g(x)) */\n\n\n      var chainDerivative = _derivative(arg0, constNodes);\n\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n\n\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n\n\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c\n\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n\n\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n\n\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if (type.isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n\n\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n\n        if (constNodes[_arg2] !== undefined) {\n          if (type.isConstantNode(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            } // Ignore exponent; f(x)^1 = f(x)\n\n\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n\n\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n\n\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n\n      throw new Error('Operator \"' + node.op + '\" is not supported by derivative, or a wrong number of arguments is passed');\n    }\n  });\n  /**\n   * Ensures the number of arguments for a function are correct,\n   * and will throw an error otherwise.\n   *\n   * @param {FunctionNode} node\n   */\n\n\n  function funcArgsCheck(node) {\n    // TODO add min, max etc\n    if ((node.name === 'log' || node.name === 'nthRoot') && node.args.length === 2) {\n      return;\n    } // There should be an incorrect number of arguments if we reach here\n    // Change all args to constants to avoid unidentified\n    // symbol error when compiling function\n\n\n    for (var i = 0; i < node.args.length; ++i) {\n      node.args[i] = createConstantNode(0);\n    }\n\n    node.compile().eval();\n    throw new Error('Expected TypeError, but none found');\n  }\n  /**\n   * Helper function to create a constant node with a specific type\n   * (number, BigNumber, Fraction)\n   * @param {number} value\n   * @param {string} [valueType]\n   * @return {ConstantNode}\n   */\n\n\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || config.number));\n  }\n\n  return derivative;\n}\n\nexports.name = 'derivative';\nexports.factory = factory;"],"sourceRoot":""}