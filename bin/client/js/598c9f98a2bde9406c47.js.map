{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/ConstantNode.js"],"names":["format","__webpack_require__","escapeLatex","escape","exports","name","path","factory","type","config","load","typed","Node","getType","ConstantNode","value","this","SyntaxError","arguments","length","prototype","isConstantNode","_compile","math","argNames","forEach","callback","map","clone","_toString","options","toHTML","toJSON","mathjs","fromJSON","json","_toTex","index","toLowerCase","indexOf","substring","toLatex"],"mappings":"0FAEA,IAAAA,EAAaC,EAAQ,GAAoBD,OAEzCE,EAAkBD,EAAQ,GAAmBE,OAuL7CC,EAAAC,KAAA,eACAD,EAAAE,KAAA,kBACAF,EAAAG,QAvLA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAkBT,EAAQ,KAC1BY,EAAAH,EAAqBT,EAAQ,KAc7B,SAAAa,EAAAC,GACA,KAAAC,gBAAAF,GACA,UAAAG,YAAA,oDAGA,OAAAC,UAAAC,OAEA,UAAAF,YAAA,kKAGAD,KAAAD,QAwJA,OArJAD,EAAAM,UAAA,IAAAR,EACAE,EAAAM,UAAAZ,KAAA,eACAM,EAAAM,UAAAC,gBAAA,EAeAP,EAAAM,UAAAE,SAAA,SAAAC,EAAAC,GACA,IAAAT,EAAAC,KAAAD,MACA,kBACA,OAAAA,IASAD,EAAAM,UAAAK,QAAA,SAAAC,KAUAZ,EAAAM,UAAAO,IAAA,SAAAD,GACA,OAAAV,KAAAY,SAQAd,EAAAM,UAAAQ,MAAA,WACA,WAAAd,EAAAE,KAAAD,QASAD,EAAAM,UAAAS,UAAA,SAAAC,GACA,OAAA9B,EAAAgB,KAAAD,MAAAe,IASAhB,EAAAM,UAAAW,OAAA,SAAAD,GACA,IAAAf,EAAAC,KAAAa,UAAAC,GAEA,OAAAjB,EAAAG,KAAAD,QACA,aACA,gBACA,eACA,mCAAAA,EAAA,UAEA,aACA,mCAAAA,EAAA,UAEA,cACA,oCAAAA,EAAA,UAEA,WACA,wCAAAA,EAAA,UAEA,gBACA,sCAAAA,EAAA,UAEA,QACA,mCAAAA,EAAA,YASAD,EAAAM,UAAAY,OAAA,WACA,OACAC,OAAA,eACAlB,MAAAC,KAAAD,QAYAD,EAAAoB,SAAA,SAAAC,GACA,WAAArB,EAAAqB,EAAApB,QASAD,EAAAM,UAAAgB,OAAA,SAAAN,GACA,IAAAf,EAAAC,KAAAa,UAAAC,GAEA,OAAAjB,EAAAG,KAAAD,QACA,aACA,kBAAyBb,EAAAa,GAAA,IAEzB,aACA,gBACA,IAAAsB,EAAAtB,EAAAuB,cAAAC,QAAA,KAEA,WAAAF,EACAtB,EAAAyB,UAAA,EAAAH,GAAA,aAAwDtB,EAAAyB,UAAAH,EAAA,OAGxDtB,EAEA,eACA,OAAAC,KAAAD,MAAA0B,UAEA,QACA,OAAA1B,IAIAD","file":"js/598c9f98a2bde9406c47.js","sourcesContent":["'use strict';\n\nvar format = require('../../utils/string').format;\n\nvar escapeLatex = require('../../utils/latex').escape;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var getType = load(require('../../function/utils/typeof'));\n  /**\n   * A ConstantNode holds a constant value like a number or string.\n   *\n   * Usage:\n   *\n   *     new ConstantNode(2.3)\n   *     new ConstantNode('hello')\n   *\n   * @param {*} value    Value can be any type (number, BigNumber, string, ...)\n   * @constructor ConstantNode\n   * @extends {Node}\n   */\n\n  function ConstantNode(value) {\n    if (!(this instanceof ConstantNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (arguments.length === 2) {\n      // TODO: remove deprecation error some day (created 2018-01-23)\n      throw new SyntaxError('new ConstantNode(valueStr, valueType) is not supported anymore since math v4.0.0. Use new ConstantNode(value) instead, where value is a non-stringified value.');\n    }\n\n    this.value = value;\n  }\n\n  ConstantNode.prototype = new Node();\n  ConstantNode.prototype.type = 'ConstantNode';\n  ConstantNode.prototype.isConstantNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConstantNode.prototype._compile = function (math, argNames) {\n    var value = this.value;\n    return function evalConstantNode() {\n      return value;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConstantNode.prototype.forEach = function (callback) {} // nothing to do, we don't have childs\n\n  /**\n   * Create a new ConstantNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ConstantNode} Returns a clone of the node\n   */\n  ;\n\n  ConstantNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConstantNode}\n   */\n\n\n  ConstantNode.prototype.clone = function () {\n    return new ConstantNode(this.value);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConstantNode.prototype._toString = function (options) {\n    return format(this.value, options);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConstantNode.prototype.toHTML = function (options) {\n    var value = this._toString(options);\n\n    switch (getType(this.value)) {\n      case 'number':\n      case 'BigNumber':\n      case 'Fraction':\n        return '<span class=\"math-number\">' + value + '</span>';\n\n      case 'string':\n        return '<span class=\"math-string\">' + value + '</span>';\n\n      case 'boolean':\n        return '<span class=\"math-boolean\">' + value + '</span>';\n\n      case 'null':\n        return '<span class=\"math-null-symbol\">' + value + '</span>';\n\n      case 'undefined':\n        return '<span class=\"math-undefined\">' + value + '</span>';\n\n      default:\n        return '<span class=\"math-symbol\">' + value + '</span>';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConstantNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConstantNode',\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate a ConstantNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", value: 2.3}`,\n   *                       where mathjs is optional\n   * @returns {ConstantNode}\n   */\n\n\n  ConstantNode.fromJSON = function (json) {\n    return new ConstantNode(json.value);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConstantNode.prototype._toTex = function (options) {\n    var value = this._toString(options);\n\n    switch (getType(this.value)) {\n      case 'string':\n        return '\\\\mathtt{' + escapeLatex(value) + '}';\n\n      case 'number':\n      case 'BigNumber':\n        var index = value.toLowerCase().indexOf('e');\n\n        if (index !== -1) {\n          return value.substring(0, index) + '\\\\cdot10^{' + value.substring(index + 1) + '}';\n        }\n\n        return value;\n\n      case 'Fraction':\n        return this.value.toLatex();\n\n      default:\n        return value;\n    }\n  };\n\n  return ConstantNode;\n}\n\nexports.name = 'ConstantNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}