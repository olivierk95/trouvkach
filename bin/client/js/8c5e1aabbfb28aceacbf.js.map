{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/Parser.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/Help.js"],"names":["extend","__webpack_require__","customs","exports","name","path","factory","type","config","load","typed","math","_parse","Parser","this","SyntaxError","scope","prototype","isParser","parse","expr","Error","compile","eval","get","getSafeProperty","undefined","getAll","set","value","setSafeProperty","remove","clear","hasOwnProperty","object","string","parser","Help","doc","isHelp","toString","desc","category","description","syntax","join","examples","i","length","res","e","format","precision","seealso","toJSON","obj","clone","mathjs","fromJSON","json","prop","valueOf"],"mappings":"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","file":"js/8c5e1aabbfb28aceacbf.js","sourcesContent":["'use strict';\n\nvar extend = require('../utils/object').extend;\n\nvar customs = require('../utils/customs');\n\nfunction factory(type, config, load, typed, math) {\n  var _parse = load(require('./parse'));\n  /**\n   * @constructor Parser\n   * Parser contains methods to evaluate or parse expressions, and has a number\n   * of convenience methods to get, set, and remove variables from memory. Parser\n   * keeps a scope containing variables in memory, which is used for all\n   * evaluations.\n   *\n   * Methods:\n   *    const result = parser.eval(expr)  // evaluate an expression\n   *    const value = parser.get(name)    // retrieve a variable from the parser\n   *    const values = parser.getAll()    // retrieve all defined variables\n   *    parser.set(name, value)           // set a variable in the parser\n   *    parser.remove(name)               // clear a variable from the\n   *                                      // parsers scope\n   *    parser.clear()                    // clear the parsers scope\n   *\n   * Example usage:\n   *    const parser = new Parser()\n   *    // Note: there is a convenience method which can be used instead:\n   *    // const parser = new math.parser()\n   *\n   *    // evaluate expressions\n   *    parser.eval('sqrt(3^2 + 4^2)')         // 5\n   *    parser.eval('sqrt(-4)')                // 2i\n   *    parser.eval('2 inch in cm')            // 5.08 cm\n   *    parser.eval('cos(45 deg)')             // 0.7071067811865476\n   *\n   *    // define variables and functions\n   *    parser.eval('x = 7 / 2')               // 3.5\n   *    parser.eval('x + 3')                   // 6.5\n   *    parser.eval('function f(x, y) = x^y')  // f(x, y)\n   *    parser.eval('f(2, 3)')                 // 8\n   *\n   *    // get and set variables and functions\n   *    const x = parser.get('x')              // 7\n   *    const f = parser.get('f')              // function\n   *    const g = f(3, 2)                      // 9\n   *    parser.set('h', 500)\n   *    const i = parser.eval('h / 2')         // 250\n   *    parser.set('hello', function (name) {\n   *        return 'hello, ' + name + '!'\n   *    })\n   *    parser.eval('hello(\"user\")')           // \"hello, user!\"\n   *\n   *    // clear defined functions and variables\n   *    parser.clear()\n   *\n   */\n\n\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.scope = {};\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\n   * Parse an expression and return the parsed function node.\n   * The node tree can be compiled via `code = node.compile(math)`,\n   * and the compiled code can be executed as `code.eval([scope])`\n   * @param {string} expr\n   * @return {Node} node\n   * @throws {Error}\n   */\n\n  Parser.prototype.parse = function (expr) {\n    throw new Error('Parser.parse is deprecated. Use math.parse instead.');\n  };\n  /**\n   * Parse and compile an expression, return the compiled javascript code.\n   * The node can be evaluated via code.eval([scope])\n   * @param {string} expr\n   * @return {{eval: function}} code\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.compile = function (expr) {\n    throw new Error('Parser.compile is deprecated. Use math.compile instead.');\n  };\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.eval = function (expr) {\n    // TODO: validate arguments\n    return _parse(expr).compile().eval(this.scope);\n  };\n  /**\n   * Get a variable (a function or variable) by name from the parsers scope.\n   * Returns undefined when not found\n   * @param {string} name\n   * @return {* | undefined} value\n   */\n\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    return name in this.scope ? customs.getSafeProperty(this.scope, name) : undefined;\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Object} values\n   */\n\n\n  Parser.prototype.getAll = function () {\n    return extend({}, this.scope);\n  };\n  /**\n   * Set a symbol (a function or variable) by name from the parsers scope.\n   * @param {string} name\n   * @param {* | undefined} value\n   */\n\n\n  Parser.prototype.set = function (name, value) {\n    // TODO: validate arguments\n    return customs.setSafeProperty(this.scope, name, value);\n  };\n  /**\n   * Remove a variable from the parsers scope\n   * @param {string} name\n   */\n\n\n  Parser.prototype.remove = function (name) {\n    // TODO: validate arguments\n    delete this.scope[name];\n  };\n  /**\n   * Clear the scope with variables and functions\n   */\n\n\n  Parser.prototype.clear = function () {\n    for (var name in this.scope) {\n      if (this.scope.hasOwnProperty(name)) {\n        delete this.scope[name];\n      }\n    }\n  };\n\n  return Parser;\n}\n\nexports.name = 'Parser';\nexports.path = 'expression';\nexports.factory = factory;\nexports.math = true; // requires the math namespace as 5th argument","'use strict';\n\nvar object = require('../utils/object');\n\nvar string = require('../utils/string');\n\nfunction factory(type, config, load, typed) {\n  var parser = load(require('./function/parser'))();\n  /**\n   * Documentation object\n   * @param {Object} doc  Object containing properties:\n   *                      {string} name\n   *                      {string} category\n   *                      {string} description\n   *                      {string[]} syntax\n   *                      {string[]} examples\n   *                      {string[]} seealso\n   * @constructor\n   */\n\n  function Help(doc) {\n    if (!(this instanceof Help)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!doc) throw new Error('Argument \"doc\" missing');\n    this.doc = doc;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Help.prototype.type = 'Help';\n  Help.prototype.isHelp = true;\n  /**\n   * Generate a string representation of the Help object\n   * @return {string} Returns a string\n   * @private\n   */\n\n  Help.prototype.toString = function () {\n    var doc = this.doc || {};\n    var desc = '\\n';\n\n    if (doc.name) {\n      desc += 'Name: ' + doc.name + '\\n\\n';\n    }\n\n    if (doc.category) {\n      desc += 'Category: ' + doc.category + '\\n\\n';\n    }\n\n    if (doc.description) {\n      desc += 'Description:\\n    ' + doc.description + '\\n\\n';\n    }\n\n    if (doc.syntax) {\n      desc += 'Syntax:\\n    ' + doc.syntax.join('\\n    ') + '\\n\\n';\n    }\n\n    if (doc.examples) {\n      desc += 'Examples:\\n';\n\n      for (var i = 0; i < doc.examples.length; i++) {\n        var expr = doc.examples[i];\n        desc += '    ' + expr + '\\n';\n        var res = void 0;\n\n        try {\n          // note: res can be undefined when `expr` is an empty string\n          res = parser.eval(expr);\n        } catch (e) {\n          res = e;\n        }\n\n        if (res !== undefined && !type.isHelp(res)) {\n          desc += '        ' + string.format(res, {\n            precision: 14\n          }) + '\\n';\n        }\n      }\n\n      desc += '\\n';\n    }\n\n    if (doc.seealso && doc.seealso.length) {\n      desc += 'See also: ' + doc.seealso.join(', ') + '\\n';\n    }\n\n    return desc;\n  };\n  /**\n   * Export the help object to JSON\n   */\n\n\n  Help.prototype.toJSON = function () {\n    var obj = object.clone(this.doc);\n    obj.mathjs = 'Help';\n    return obj;\n  };\n  /**\n   * Instantiate a Help object from a JSON object\n   * @param {Object} json\n   * @returns {Help} Returns a new Help object\n   */\n\n\n  Help.fromJSON = function (json) {\n    var doc = {};\n\n    for (var prop in json) {\n      if (prop !== 'mathjs') {\n        // ignore mathjs field\n        doc[prop] = json[prop];\n      }\n    }\n\n    return new Help(doc);\n  };\n  /**\n   * Returns a string representation of the Help object\n   */\n\n\n  Help.prototype.valueOf = Help.prototype.toString;\n  return Help;\n}\n\nexports.name = 'Help';\nexports.path = 'type';\nexports.factory = factory;"],"sourceRoot":""}