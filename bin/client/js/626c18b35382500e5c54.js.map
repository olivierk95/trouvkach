{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csTdfs.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csSqr.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csSpsolve.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csUnflip.js"],"names":["exports","name","path","factory","j","k","w","head","next","post","stack","top","p","i","type","config","load","csAmd","__webpack_require__","csPermute","csEtree","csPost","csCounts","order","a","qr","aptr","_ptr","n","_size","s","q","c","parent","cp","aindex","_index","asize","m","pinv","leftmost","p0","p1","tail","nque","lnz","m2","pa","_vcount","unz","divideScalar","multiply","subtract","csReach","g","b","xi","x","lo","gvalues","_values","gindex","gptr","bvalues","bindex","bptr","px","J","csFlip"],"mappings":"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","file":"js/626c18b35382500e5c54.js","sourcesContent":["'use strict';\n\nfunction factory() {\n  /**\n   * Depth-first search and postorder of a tree rooted at node j\n   *\n   * @param {Number}  j               The tree node\n   * @param {Number}  k\n   * @param {Array}   w               The workspace array\n   * @param {Number}  head            The index offset within the workspace for the head array\n   * @param {Number}  next            The index offset within the workspace for the next array\n   * @param {Array}   post            The post ordering array\n   * @param {Number}  stack           The index offset within the workspace for the stack array\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csTdfs = function csTdfs(j, k, w, head, next, post, stack) {\n    // variables\n    var top = 0; // place j on the stack\n\n    w[stack] = j; // while (stack is not empty)\n\n    while (top >= 0) {\n      // p = top of stack\n      var p = w[stack + top]; // i = youngest child of p\n\n      var i = w[head + p];\n\n      if (i === -1) {\n        // p has no unordered children left\n        top--; // node p is the kth postordered node\n\n        post[k++] = p;\n      } else {\n        // remove i from children of p\n        w[head + p] = w[next + i]; // increment top\n\n        ++top; // start dfs on child node i\n\n        w[stack + top] = i;\n      }\n    }\n\n    return k;\n  };\n\n  return csTdfs;\n}\n\nexports.name = 'csTdfs';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var csAmd = load(require('./csAmd'));\n  var csPermute = load(require('./csPermute'));\n  var csEtree = load(require('./csEtree'));\n  var csPost = load(require('./csPost'));\n  var csCounts = load(require('./csCounts'));\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csSqr = function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? csPermute(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = csEtree(c, 1); // post order elimination tree\n\n      var post = csPost(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n\n  return csSqr;\n}\n\nexports.name = 'csSqr';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiply = load(require('../../arithmetic/multiply'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  var csReach = load(require('./csReach'));\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csSpsolve = function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n\n  return csSpsolve;\n}\n\nexports.name = 'csSpsolve';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var csFlip = load(require('./csFlip'));\n  /**\n   * Flips the value if it is negative of returns the same value otherwise.\n   *\n   * @param {Number}  i               The value to flip\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csUnflip = function csUnflip(i) {\n    // flip the value if it is negative\n    return i < 0 ? csFlip(i) : i;\n  };\n\n  return csUnflip;\n}\n\nexports.name = 'csUnflip';\nexports.path = 'algebra.sparse';\nexports.factory = factory;"],"sourceRoot":""}