{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csMarked.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csMark.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csPermute.js"],"names":["exports","name","path","factory","w","j","type","config","load","csFlip","__webpack_require__","SparseMatrix","a","pinv","q","values","avalues","_values","aindex","_index","aptr","_ptr","asize","_size","adt","_datatype","m","n","cvalues","cindex","cptr","nz","k","t0","t1","t","r","index","ptr","size","datatype"],"mappings":"2FAmBAA,EAAAC,KAAA,WACAD,EAAAE,KAAA,iBACAF,EAAAG,QAnBA,WAcA,OALA,SAAAC,EAAAC,GAEA,OAAAD,EAAAC,GAAA,sCCQAL,EAAAC,KAAA,SACAD,EAAAE,KAAA,iBACAF,EAAAG,QArBA,SAAAG,EAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAoBE,EAAQ,KAe5B,OALA,SAAAN,EAAAC,GAEAD,EAAAC,GAAAI,EAAAL,EAAAC,wCCyDAL,EAAAC,KAAA,YACAD,EAAAE,KAAA,iBACAF,EAAAG,QAxEA,SAAAG,GACA,IAAAK,EAAAL,EAAAK,aAkEA,OApDA,SAAAC,EAAAC,EAAAC,EAAAC,GAmBA,IAjBA,IAAAC,EAAAJ,EAAAK,QACAC,EAAAN,EAAAO,OACAC,EAAAR,EAAAS,KACAC,EAAAV,EAAAW,MACAC,EAAAZ,EAAAa,UAEAC,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GAEAM,EAAAb,GAAAH,EAAAK,QAAA,QACAY,EAAA,GAEAC,EAAA,GAGAC,EAAA,EAEAC,EAAA,EAAmBA,EAAAL,EAAOK,IAAA,CAE1BF,EAAAE,GAAAD,EAIA,IAFA,IAAA1B,EAAAS,IAAAkB,KAEAC,EAAAb,EAAAf,GAAA6B,EAAAd,EAAAf,EAAA,GAAA8B,EAAAF,EAAsDE,EAAAD,EAAQC,IAAA,CAE9D,IAAAC,EAAAvB,IAAAK,EAAAiB,IAAAjB,EAAAiB,GAEAN,EAAAE,GAAAK,EAEAR,IACAA,EAAAG,GAAAf,EAAAmB,IAIAJ,KAOA,OAFAD,EAAAH,GAAAI,EAEA,IAAApB,EAAA,CACAI,OAAAa,EACAS,MAAAR,EACAS,IAAAR,EACAS,KAAA,CAAAb,EAAAC,GACAa,SAAAhB","file":"js/dff0ffb54755f2a478e4.js","sourcesContent":["'use strict';\n\nfunction factory() {\n  /**\n   * Checks if the node at w[j] is marked\n   *\n   * @param {Array}   w               The array\n   * @param {Number}  j               The array index\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csMarked = function csMarked(w, j) {\n    // check node is marked\n    return w[j] < 0;\n  };\n\n  return csMarked;\n}\n\nexports.name = 'csMarked';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var csFlip = load(require('./csFlip'));\n  /**\n   * Marks the node at w[j]\n   *\n   * @param {Array}   w               The array\n   * @param {Number}  j               The array index\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csMark = function csMark(w, j) {\n    // mark w[j]\n    w[j] = csFlip(w[j]);\n  };\n\n  return csMark;\n}\n\nexports.name = 'csMark';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type) {\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Permutes a sparse matrix C = P * A * Q\n   *\n   * @param {Matrix}  a               The Matrix A\n   * @param {Array}   pinv            The row permutation vector\n   * @param {Array}   q               The column permutation vector\n   * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n   *\n   * @return {Matrix}                 C = P * A * Q, null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csPermute = function csPermute(a, pinv, q, values) {\n    // a arrays\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var asize = a._size;\n    var adt = a._datatype; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // c arrays\n\n    var cvalues = values && a._values ? [] : null;\n    var cindex = []; // (aptr[n])\n\n    var cptr = []; // (n + 1)\n    // initialize vars\n\n    var nz = 0; // loop columns\n\n    for (var k = 0; k < n; k++) {\n      // column k of C is column q[k] of A\n      cptr[k] = nz; // apply column permutation\n\n      var j = q ? q[k] : k; // loop values in column j of A\n\n      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n        // row i of A is row pinv[i] of C\n        var r = pinv ? pinv[aindex[t]] : aindex[t]; // index\n\n        cindex[nz] = r; // check we need to populate values\n\n        if (cvalues) {\n          cvalues[nz] = avalues[t];\n        } // increment number of nonzero elements\n\n\n        nz++;\n      }\n    } // finalize the last column of C\n\n\n    cptr[n] = nz; // return C matrix\n\n    return new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [m, n],\n      datatype: adt\n    });\n  };\n\n  return csPermute;\n}\n\nexports.name = 'csPermute';\nexports.path = 'algebra.sparse';\nexports.factory = factory;"],"sourceRoot":""}