{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/matrix/subset.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/matrix/trace.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/matrix/zeros.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/function/matrix/transpose.js"],"names":["clone","__webpack_require__","validateIndex","getSafeProperty","setSafeProperty","DimensionError","_getObjectProperty","object","index","size","length","key","dimension","TypeError","_setObjectProperty","replacement","updated","exports","name","factory","type","config","load","typed","matrix","subset","Array, Index","value","isScalar","valueOf","Matrix, Index","Object, Index","string, Index","str","isIndex","strLen","min","max","range","substr","forEach","v","charAt","Array, Index, any","undefined","Array, Index, any, any","defaultValue","Matrix, Index, any","Matrix, Index, any, any","string, Index, string","_setSubstring","string, Index, string, string","Object, Index, any","toTex","chars","i","_i","_len","join","format","add","trace","Array","x","_denseTrace","SparseMatrix","m","values","_values","_index","ptr","_ptr","_size","rows","columns","sum","j","k0","k1","k","RangeError","DenseMatrix","any","data","_data","1","isInteger","resize","zeros","","_zeros","...number | BigNumber | string","pop","Matrix","storage","Array | Matrix, string","hasBigNumbers","arr","isBigNumber","toNumber","_normalize","BigNumber","Error","_validate","latex","transpose","c","transposedRow","transposed","datatype","_datatype","_denseTranspose","p","l","cvalues","cindex","cptr","w","push","q","_sparseTranspose","this","concat","operators"],"mappings":"2FAEA,IAAAA,EAAYC,EAAQ,GAAoBD,MAExCE,EAAoBD,EAAQ,GAAmBC,cAE/CC,EAAsBF,EAAQ,IAAqBE,gBAEnDC,EAAsBH,EAAQ,IAAqBG,gBAEnDC,EAAqBJ,EAAQ,IA6K7B,SAAAK,EAAAC,EAAAC,GACA,OAAAA,EAAAC,OAAAC,OACA,UAAAL,EAAAG,EAAAC,OAAA,GAGA,IAAAE,EAAAH,EAAAI,UAAA,GAEA,oBAAAD,EACA,UAAAE,UAAA,2DAGA,OAAAV,EAAAI,EAAAI,GAYA,SAAAG,EAAAP,EAAAC,EAAAO,GACA,OAAAP,EAAAC,OAAAC,OACA,UAAAL,EAAAG,EAAAC,OAAA,GAGA,IAAAE,EAAAH,EAAAI,UAAA,GAEA,oBAAAD,EACA,UAAAE,UAAA,2DAIA,IAAAG,EAAAhB,EAAAO,GAEA,OADAH,EAAAY,EAAAL,EAAAI,GACAC,EAGAC,EAAAC,KAAA,SACAD,EAAAE,QApNA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAoBrB,EAAQ,IAoC5BwB,EAAAF,EAAA,UAEAG,eAAA,SAAAC,EAAAnB,GACA,IACAiB,EADAD,EAAAG,GACAF,OAAAjB,GAEA,OAAAA,EAAAoB,WAAAH,IAAAI,WAEAC,gBAAA,SAAAH,EAAAnB,GACA,OAAAmB,EAAAF,OAAAjB,IAEAuB,gBAAAzB,EACA0B,gBA6BA,SAAAC,EAAAzB,GACA,IAAAY,EAAAc,QAAA1B,GAEA,UAAAK,UAAA,kBAGA,OAAAL,EAAAC,OAAAC,OACA,UAAAL,EAAAG,EAAAC,OAAAC,OAAA,GAIA,IAAAyB,EAAAF,EAAAvB,OACAR,EAAAM,EAAA4B,MAAA,GAAAD,GACAjC,EAAAM,EAAA6B,MAAA,GAAAF,GACA,IAAAG,EAAA9B,EAAAI,UAAA,GACA2B,EAAA,GAIA,OAHAD,EAAAE,QAAA,SAAAC,GACAF,GAAAN,EAAAS,OAAAD,KAEAF,GA9CAI,oBAAA,SAAAhB,EAAAnB,EAAAO,GACA,OAAAS,EAAAxB,EAAA2B,IAAAF,OAAAjB,EAAAO,OAAA6B,GAAAf,WAEAgB,yBAAA,SAAAlB,EAAAnB,EAAAO,EAAA+B,GACA,OAAAtB,EAAAxB,EAAA2B,IAAAF,OAAAjB,EAAAO,EAAA+B,GAAAjB,WAEAkB,qBAAA,SAAApB,EAAAnB,EAAAO,GACA,OAAAY,EAAA3B,QAAAyB,OAAAjB,EAAAO,IAEAiC,0BAAA,SAAArB,EAAAnB,EAAAO,EAAA+B,GACA,OAAAnB,EAAA3B,QAAAyB,OAAAjB,EAAAO,EAAA+B,IAEAG,wBAAAC,EACAC,gCAAAD,EACAE,qBAAAtC,IAIA,OAFAW,EAAA4B,WAAAT,EAEAnB,EA0CA,SAAAyB,EAAAjB,EAAAzB,EAAAO,EAAA+B,GACA,IAAAtC,IAAA,IAAAA,EAAA0B,QAEA,UAAArB,UAAA,kBAGA,OAAAL,EAAAC,OAAAC,OACA,UAAAL,EAAAG,EAAAC,OAAAC,OAAA,GAGA,QAAAkC,IAAAE,GACA,oBAAAA,GAAA,IAAAA,EAAApC,OACA,UAAAG,UAAA,kDAGAiC,EAAA,IAGA,IAAAR,EAAA9B,EAAAI,UAAA,GAGA,GAFA0B,EAAA7B,OAAA,KAEAM,EAAAL,OACA,UAAAL,EAAAiC,EAAA7B,OAAA,GAAAM,EAAAL,QAIA,IAAAyB,EAAAF,EAAAvB,OACAR,EAAAM,EAAA4B,MAAA,IACAlC,EAAAM,EAAA6B,MAAA,IAIA,IAFA,IAAAiB,EAAA,GAEAC,EAAA,EAAmBA,EAAApB,EAAYoB,IAC/BD,EAAAC,GAAAtB,EAAAS,OAAAa,GAOA,GAJAjB,EAAAE,QAAA,SAAAC,EAAAc,GACAD,EAAAb,GAAA1B,EAAA2B,OAAAa,EAAA,MAGAD,EAAA5C,OAAAyB,EACA,QAAAqB,EAAArB,EAAA,EAAAsB,EAAAH,EAAA5C,OAAoD8C,EAAAC,EAAWD,IAC/DF,EAAAE,KACAF,EAAAE,GAAAV,GAKA,OAAAQ,EAAAI,KAAA,wCCzKA,IAAA1D,EAAYC,EAAQ,GAAoBD,MAExC2D,EAAa1D,EAAQ,GAAoB0D,OAwIzC1C,EAAAC,KAAA,QACAD,EAAAE,QAvIA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAoBrB,EAAQ,IAC5B2D,EAAAtC,EAAiBrB,EAAQ,KA6BzB4D,EAAAtC,EAAA,SACAuC,MAAA,SAAAC,GAEA,OAAAC,EAAAxC,EAAAuC,KAEAE,aA6CA,SAAAC,GAEA,IAAAC,EAAAD,EAAAE,QACA5D,EAAA0D,EAAAG,OACAC,EAAAJ,EAAAK,KACA9D,EAAAyD,EAAAM,MAEAC,EAAAhE,EAAA,GACAiE,EAAAjE,EAAA,GAEA,GAAAgE,IAAAC,EAAA,CAEA,IAAAC,EAAA,EAEA,GAAAR,EAAAzD,OAAA,EAEA,QAAAkE,EAAA,EAAuBA,EAAAF,EAAaE,IAKpC,IAHA,IAAAC,EAAAP,EAAAM,GACAE,EAAAR,EAAAM,EAAA,GAEAG,EAAAF,EAA0BE,EAAAD,EAAQC,IAAA,CAElC,IAAAxB,EAAA/C,EAAAuE,GAEA,GAAAxB,IAAAqB,EAAA,CAEAD,EAAAf,EAAAe,EAAAR,EAAAY,IAEA,MAGA,GAAAxB,EAAAqB,EAEA,MAOA,OAAAD,EAGA,UAAAK,WAAA,gCAAArB,EAAAlD,GAAA,MAxFAwE,YAAAjB,EACAkB,IAAAlF,IAGA,SAAAgE,EAAAE,GAEA,IAAAzD,EAAAyD,EAAAM,MACAW,EAAAjB,EAAAkB,MAEA,OAAA3E,EAAAC,QACA,OAEA,OAAAD,EAAA,GAEA,OAAAT,EAAAmF,EAAA,IAGA,UAAAH,WAAA,gCAAArB,EAAAlD,GAAA,KAEA,OAEA,IAAAgE,EAAAhE,EAAA,GAGA,GAAAgE,IAFAhE,EAAA,GAEA,CAIA,IAFA,IAAAkE,EAAA,EAEApB,EAAA,EAAyBA,EAAAkB,EAAUlB,IACnCoB,EAAAf,EAAAe,EAAAQ,EAAA5B,OAIA,OAAAoB,EAGA,UAAAK,WAAA,gCAAArB,EAAAlD,GAAA,KAEA,QAEA,UAAAuE,WAAA,yCAAArB,EAAAlD,GAAA,MAsDA,OAHAoD,EAAAR,MAAA,CACAgC,EAAA,yCAEAxB,oCCvIA,IAAAyB,EAAgBrF,EAAQ,GAAoBqF,UAE5CC,EAAatF,EAAQ,GAAmBsF,OA6HxCtE,EAAAC,KAAA,QACAD,EAAAE,QA5HA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAoBrB,EAAQ,IAiC5BuF,EAAAjE,EAAA,SACAkE,GAAA,WACA,gBAAApE,EAAAG,OAAAkE,EAAA,IAAAA,EAAA,eAIAC,iCAAA,SAAAlF,GAGA,oBAFAA,IAAAC,OAAA,GAEA,CACA,IAAAiD,EAAAlD,EAAAmF,MACA,OAAAF,EAAAjF,EAAAkD,GACO,gBAAAtC,EAAAG,OACPkE,EAAAjF,GAEAiF,EAAAjF,EAAA,YAGAqD,MAAA4B,EACAG,OAAA,SAAApF,GACA,IAAAkD,EAAAlD,EAAAqF,UACA,OAAAJ,EAAAjF,EAAAoB,UAAA8B,IAEAoC,yBAAA,SAAAtF,EAAAkD,GACA,OAAA+B,EAAAjF,EAAAoB,UAAA8B,MAKA,OAFA6B,EAAAnC,WAAAT,EAEA4C,EASA,SAAAE,EAAAjF,EAAAkD,GACA,IAEAb,EA0BA,SAAArC,GACA,IAAAuF,GAAA,EAOA,OANAvF,EAAA+B,QAAA,SAAAb,EAAAnB,EAAAyF,GACA7E,EAAA8E,YAAAvE,KACAqE,GAAA,EACAC,EAAAzF,GAAAmB,EAAAwE,cAGAH,EApCAI,CAAA3F,GAEA,IAAAW,EAAAiF,UAAA,KAIA,GAkCA,SAAA5F,GACAA,EAAA+B,QAAA,SAAAb,GACA,oBAAAA,IAAA2D,EAAA3D,MAAA,EACA,UAAA2E,MAAA,4DAvCAC,CAAA9F,GAEAkD,EAAA,CAEA,IAAAO,EAAA1C,EAAAmC,GAEA,OAAAlD,EAAAC,OAAA,EACAwD,EAAAqB,OAAA9E,EAAAqC,GAGAoB,EAGA,IAAA+B,EAAA,GAEA,OAAAxF,EAAAC,OAAA,EACA6E,EAAAU,EAAAxF,EAAAqC,GAGAmD,qCCpGA,IAAAjG,EAAYC,EAAQ,GAAoBD,MAExC2D,EAAa1D,EAAQ,GAAoB0D,OAkLzC1C,EAAAC,KAAA,YACAD,EAAAE,QAjLA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAiF,EAAcvG,EAAQ,GAEtBuB,EAAAF,EAAoBrB,EAAQ,IAC5BgF,EAAA7D,EAAA6D,YACAhB,EAAA7C,EAAA6C,aAwBAwC,EAAAlF,EAAA,aACAuC,MAAA,SAAAC,GAEA,OAAA0C,EAAAjF,EAAAuC,IAAAlC,WAEAgE,OAAA,SAAA9B,GAEA,IAEA2C,EAFAjG,EAAAsD,EAAAtD,OAIA,OAAAA,EAAAC,QACA,OAEAgG,EAAA3C,EAAA/D,QACA,MAEA,OAEA,IAAAyE,EAAAhE,EAAA,GACAiE,EAAAjE,EAAA,GAEA,OAAAiE,EAEA,UAAAM,WAAA,uDAAArB,EAAAlD,GAAA,KAIA,OAAAsD,EAAA+B,WACA,YACAY,EAuBA,SAAAxC,EAAAO,EAAAC,GAOA,IALA,IAGAiC,EAHAxB,EAAAjB,EAAAkB,MAEAwB,EAAA,GAGAhC,EAAA,EAAmBA,EAAAF,EAAaE,IAAA,CAEhC+B,EAAAC,EAAAhC,GAAA,GAEA,QAAArB,EAAA,EAAqBA,EAAAkB,EAAUlB,IAE/BoD,EAAApD,GAAAvD,EAAAmF,EAAA5B,GAAAqB,IAKA,WAAAK,EAAA,CACAE,KAAAyB,EACAnG,KAAA,CAAAiE,EAAAD,GACAoC,SAAA3C,EAAA4C,YA5CAC,CAAAhD,EAAAU,EAAAC,GACA,MAEA,aACAgC,EA4CA,SAAAxC,EAAAO,EAAAC,GAYA,IAVA,IAeAsC,EAAAC,EAAArC,EAfAT,EAAAD,EAAAE,QACA5D,EAAA0D,EAAAG,OACAC,EAAAJ,EAAAK,KAEA2C,EAAA/C,EAAA,QAAAvB,EACAuE,EAAA,GACAC,EAAA,GAEAC,EAAA,GAEAtD,EAAA,EAAmBA,EAAAU,EAAUV,IAC7BsD,EAAAtD,GAAA,EAMA,IAAAiD,EAAA,EAAAC,EAAAzG,EAAAE,OAAiCsG,EAAAC,EAAOD,IAExCK,EAAA7G,EAAAwG,MAMA,IAFA,IAAArC,EAAA,EAEApB,EAAA,EAAmBA,EAAAkB,EAAUlB,IAE7B6D,EAAAE,KAAA3C,GAEAA,GAAA0C,EAAA9D,GAEA8D,EAAA9D,GAAA6D,EAAA7D,GAMA,IAFA6D,EAAAE,KAAA3C,GAEAC,EAAA,EAAeA,EAAAF,EAAaE,IAE5B,QAAAC,EAAAP,EAAAM,GAAAE,EAAAR,EAAAM,EAAA,GAAAG,EAAAF,EAAoDE,EAAAD,EAAQC,IAAA,CAE5D,IAAAwC,EAAAF,EAAA7G,EAAAuE,MAEAoC,EAAAI,GAAA3C,EAEAT,IACA+C,EAAAK,GAAAvH,EAAAmE,EAAAY,KAMA,WAAAd,EAAA,CACAE,OAAA+C,EACA1G,MAAA2G,EACA7C,IAAA8C,EACA3G,KAAA,CAAAiE,EAAAD,GACAoC,SAAA3C,EAAA4C,YAvGAU,CAAAzD,EAAAU,EAAAC,GAIA,MAEA,QAEA,UAAAM,WAAA,qDAAArB,EAAA8D,KAAAjD,OAAA,KAGA,OAAAkC,GAGAxB,IAAA,SAAAnB,GACA,OAAA/D,EAAA+D,MA+FA,OAHA0C,EAAApD,MAAA,CACAgC,EAAA,4BAAyBqC,OAAAlB,EAAAmB,UAAA,YAEzBlB","file":"js/3a954a721fb38a255187.js","sourcesContent":["'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar validateIndex = require('../../utils/array').validateIndex;\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\n\nvar DimensionError = require('../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Get or set a subset of a matrix or string.\n   *\n   * Syntax:\n   *     math.subset(value, index)                                // retrieve a subset\n   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset\n   *\n   * Examples:\n   *\n   *     // get a subset\n   *     const d = [[1, 2], [3, 4]]\n   *     math.subset(d, math.index(1, 0))        // returns 3\n   *     math.subset(d, math.index([0, 1], 1))   // returns [[2], [4]]\n   *\n   *     // replace a subset\n   *     const e = []\n   *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 6]]\n   *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 6], [0, 7]]\n   *\n   * See also:\n   *\n   *     size, resize, squeeze, index\n   *\n   * @param {Array | Matrix | string} matrix  An array, matrix, or string\n   * @param {Index} index                     An index containing ranges for each\n   *                                          dimension\n   * @param {*} [replacement]                 An array, matrix, or scalar.\n   *                                          If provided, the subset is replaced with replacement.\n   *                                          If not provided, the subset is returned\n   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when\n   *                                          the matrix is resized. If not provided,\n   *                                          math.matrix elements will be left undefined.\n   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.\n   */\n\n  var subset = typed('subset', {\n    // get subset\n    'Array, Index': function ArrayIndex(value, index) {\n      var m = matrix(value);\n      var subset = m.subset(index); // returns a Matrix\n\n      return index.isScalar() ? subset : subset.valueOf(); // return an Array (like the input)\n    },\n    'Matrix, Index': function MatrixIndex(value, index) {\n      return value.subset(index);\n    },\n    'Object, Index': _getObjectProperty,\n    'string, Index': _getSubstring,\n    // set subset\n    'Array, Index, any': function ArrayIndexAny(value, index, replacement) {\n      return matrix(clone(value)).subset(index, replacement, undefined).valueOf();\n    },\n    'Array, Index, any, any': function ArrayIndexAnyAny(value, index, replacement, defaultValue) {\n      return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();\n    },\n    'Matrix, Index, any': function MatrixIndexAny(value, index, replacement) {\n      return value.clone().subset(index, replacement);\n    },\n    'Matrix, Index, any, any': function MatrixIndexAnyAny(value, index, replacement, defaultValue) {\n      return value.clone().subset(index, replacement, defaultValue);\n    },\n    'string, Index, string': _setSubstring,\n    'string, Index, string, string': _setSubstring,\n    'Object, Index, any': _setObjectProperty\n  });\n  subset.toTex = undefined; // use default template\n\n  return subset;\n  /**\n   * Retrieve a subset of a string\n   * @param {string} str            string from which to get a substring\n   * @param {Index} index           An index containing ranges for each dimension\n   * @returns {string} substring\n   * @private\n   */\n\n  function _getSubstring(str, index) {\n    if (!type.isIndex(index)) {\n      // TODO: better error message\n      throw new TypeError('Index expected');\n    }\n\n    if (index.size().length !== 1) {\n      throw new DimensionError(index.size().length, 1);\n    } // validate whether the range is out of range\n\n\n    var strLen = str.length;\n    validateIndex(index.min()[0], strLen);\n    validateIndex(index.max()[0], strLen);\n    var range = index.dimension(0);\n    var substr = '';\n    range.forEach(function (v) {\n      substr += str.charAt(v);\n    });\n    return substr;\n  }\n  /**\n   * Replace a substring in a string\n   * @param {string} str            string to be replaced\n   * @param {Index} index           An index containing ranges for each dimension\n   * @param {string} replacement    Replacement string\n   * @param {string} [defaultValue] Default value to be uses when resizing\n   *                                the string. is ' ' by default\n   * @returns {string} result\n   * @private\n   */\n\n\n  function _setSubstring(str, index, replacement, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      // TODO: better error message\n      throw new TypeError('Index expected');\n    }\n\n    if (index.size().length !== 1) {\n      throw new DimensionError(index.size().length, 1);\n    }\n\n    if (defaultValue !== undefined) {\n      if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {\n        throw new TypeError('Single character expected as defaultValue');\n      }\n    } else {\n      defaultValue = ' ';\n    }\n\n    var range = index.dimension(0);\n    var len = range.size()[0];\n\n    if (len !== replacement.length) {\n      throw new DimensionError(range.size()[0], replacement.length);\n    } // validate whether the range is out of range\n\n\n    var strLen = str.length;\n    validateIndex(index.min()[0]);\n    validateIndex(index.max()[0]); // copy the string into an array with characters\n\n    var chars = [];\n\n    for (var i = 0; i < strLen; i++) {\n      chars[i] = str.charAt(i);\n    }\n\n    range.forEach(function (v, i) {\n      chars[v] = replacement.charAt(i[0]);\n    }); // initialize undefined characters with a space\n\n    if (chars.length > strLen) {\n      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {\n        if (!chars[_i]) {\n          chars[_i] = defaultValue;\n        }\n      }\n    }\n\n    return chars.join('');\n  }\n}\n/**\n * Retrieve a property from an object\n * @param {Object} object\n * @param {Index} index\n * @return {*} Returns the value of the property\n * @private\n */\n\n\nfunction _getObjectProperty(object, index) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n\n  var key = index.dimension(0);\n\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  }\n\n  return getSafeProperty(object, key);\n}\n/**\n * Set a property on an object\n * @param {Object} object\n * @param {Index} index\n * @param {*} replacement\n * @return {*} Returns the updated object\n * @private\n */\n\n\nfunction _setObjectProperty(object, index, replacement) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n\n  var key = index.dimension(0);\n\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  } // clone the object, and apply the property to the clone\n\n\n  var updated = clone(object);\n  setSafeProperty(updated, key, replacement);\n  return updated;\n}\n\nexports.name = 'subset';\nexports.factory = factory;","'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar format = require('../../utils/string').format;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var add = load(require('../arithmetic/add'));\n  /**\n   * Calculate the trace of a matrix: the sum of the elements on the main\n   * diagonal of a square matrix.\n   *\n   * Syntax:\n   *\n   *    math.trace(x)\n   *\n   * Examples:\n   *\n   *    math.trace([[1, 2], [3, 4]]) // returns 5\n   *\n   *    const A = [\n   *      [1, 2, 3],\n   *      [-1, 2, 3],\n   *      [2, 0, 3]\n   *    ]\n   *    math.trace(A) // returns 6\n   *\n   * See also:\n   *\n   *    diag\n   *\n   * @param {Array | Matrix} x  A matrix\n   *\n   * @return {number} The trace of `x`\n   */\n\n  var trace = typed('trace', {\n    'Array': function _arrayTrace(x) {\n      // use dense matrix implementation\n      return _denseTrace(matrix(x));\n    },\n    'SparseMatrix': _sparseTrace,\n    'DenseMatrix': _denseTrace,\n    'any': clone\n  });\n\n  function _denseTrace(m) {\n    // matrix size & data\n    var size = m._size;\n    var data = m._data; // process dimensions\n\n    switch (size.length) {\n      case 1:\n        // vector\n        if (size[0] === 1) {\n          // return data[0]\n          return clone(data[0]);\n        }\n\n        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n\n      case 2:\n        // two dimensional\n        var rows = size[0];\n        var cols = size[1];\n\n        if (rows === cols) {\n          // calulate sum\n          var sum = 0; // loop diagonal\n\n          for (var i = 0; i < rows; i++) {\n            sum = add(sum, data[i][i]);\n          } // return trace\n\n\n          return sum;\n        }\n\n        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');\n    }\n  }\n\n  function _sparseTrace(m) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    var size = m._size; // check dimensions\n\n    var rows = size[0];\n    var columns = size[1]; // matrix must be square\n\n    if (rows === columns) {\n      // calulate sum\n      var sum = 0; // check we have data (avoid looping columns)\n\n      if (values.length > 0) {\n        // loop columns\n        for (var j = 0; j < columns; j++) {\n          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n          var k0 = ptr[j];\n          var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n          for (var k = k0; k < k1; k++) {\n            // row index\n            var i = index[k]; // check row\n\n            if (i === j) {\n              // accumulate value\n              sum = add(sum, values[k]); // exit loop\n\n              break;\n            }\n\n            if (i > j) {\n              // exit loop, no value on the diagonal for column j\n              break;\n            }\n          }\n        }\n      } // return trace\n\n\n      return sum;\n    }\n\n    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n  }\n\n  trace.toTex = {\n    1: \"\\\\mathrm{tr}\\\\left(${args[0]}\\\\right)\"\n  };\n  return trace;\n}\n\nexports.name = 'trace';\nexports.factory = factory;","'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar resize = require('../../utils/array').resize;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Create a matrix filled with zeros. The created matrix can have one or\n   * multiple dimensions.\n   *\n   * Syntax:\n   *\n   *    math.zeros(m)\n   *    math.zeros(m, format)\n   *    math.zeros(m, n)\n   *    math.zeros(m, n, format)\n   *    math.zeros([m, n])\n   *    math.zeros([m, n], format)\n   *\n   * Examples:\n   *\n   *    math.zeros(3)                  // returns [0, 0, 0]\n   *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]\n   *    math.zeros(3, 'dense')         // returns [0, 0, 0]\n   *\n   *    const A = [[1, 2, 3], [4, 5, 6]]\n   *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]\n   *\n   * See also:\n   *\n   *    ones, identity, size, range\n   *\n   * @param {...number | Array} size    The size of each dimension of the matrix\n   * @param {string} [format]           The Matrix storage format\n   *\n   * @return {Array | Matrix}           A matrix filled with zeros\n   */\n\n  var zeros = typed('zeros', {\n    '': function _() {\n      return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');\n    },\n    // math.zeros(m, n, p, ..., format)\n    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this\n    '...number | BigNumber | string': function numberBigNumberString(size) {\n      var last = size[size.length - 1];\n\n      if (typeof last === 'string') {\n        var format = size.pop();\n        return _zeros(size, format);\n      } else if (config.matrix === 'Array') {\n        return _zeros(size);\n      } else {\n        return _zeros(size, 'default');\n      }\n    },\n    'Array': _zeros,\n    'Matrix': function Matrix(size) {\n      var format = size.storage();\n      return _zeros(size.valueOf(), format);\n    },\n    'Array | Matrix, string': function ArrayMatrixString(size, format) {\n      return _zeros(size.valueOf(), format);\n    }\n  });\n  zeros.toTex = undefined; // use default template\n\n  return zeros;\n  /**\n   * Create an Array or Matrix with zeros\n   * @param {Array} size\n   * @param {string} [format='default']\n   * @return {Array | Matrix}\n   * @private\n   */\n\n  function _zeros(size, format) {\n    var hasBigNumbers = _normalize(size);\n\n    var defaultValue = hasBigNumbers ? new type.BigNumber(0) : 0;\n\n    _validate(size);\n\n    if (format) {\n      // return a matrix\n      var m = matrix(format);\n\n      if (size.length > 0) {\n        return m.resize(size, defaultValue);\n      }\n\n      return m;\n    } else {\n      // return an Array\n      var arr = [];\n\n      if (size.length > 0) {\n        return resize(arr, size, defaultValue);\n      }\n\n      return arr;\n    }\n  } // replace BigNumbers with numbers, returns true if size contained BigNumbers\n\n\n  function _normalize(size) {\n    var hasBigNumbers = false;\n    size.forEach(function (value, index, arr) {\n      if (type.isBigNumber(value)) {\n        hasBigNumbers = true;\n        arr[index] = value.toNumber();\n      }\n    });\n    return hasBigNumbers;\n  } // validate arguments\n\n\n  function _validate(size) {\n    size.forEach(function (value) {\n      if (typeof value !== 'number' || !isInteger(value) || value < 0) {\n        throw new Error('Parameters in function zeros must be positive integers');\n      }\n    });\n  }\n} // TODO: zeros contains almost the same code as ones. Reuse this?\n\n\nexports.name = 'zeros';\nexports.factory = factory;","'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar format = require('../../utils/string').format;\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var DenseMatrix = type.DenseMatrix;\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n\n  var transpose = typed('transpose', {\n    'Array': function Array(x) {\n      // use dense matrix implementation\n      return transpose(matrix(x)).valueOf();\n    },\n    'Matrix': function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          // rows and columns\n          var rows = size[0];\n          var columns = size[1]; // check columns\n\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          } // process storage format\n\n\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    'any': function any(x) {\n      return clone(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    } // return matrix\n\n\n    return new DenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  transpose.toTex = {\n    1: \"\\\\left(${args[0]}\\\\right)\".concat(latex.operators['transpose'])\n  };\n  return transpose;\n}\n\nexports.name = 'transpose';\nexports.factory = factory;"],"sourceRoot":""}