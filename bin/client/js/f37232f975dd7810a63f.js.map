{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/bitwise/bitAnd.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/bitwise/bitNot.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/bitwise/bitOr.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/bitwise/bitXor.js"],"names":["isInteger","__webpack_require__","bigBitAnd","exports","name","factory","type","config","load","typed","latex","matrix","algorithm02","algorithm06","algorithm11","algorithm13","algorithm14","bitAnd","number, number","x","y","Error","BigNumber, BigNumber","SparseMatrix, SparseMatrix","SparseMatrix, DenseMatrix","DenseMatrix, SparseMatrix","DenseMatrix, DenseMatrix","Array, Array","valueOf","Array, Matrix","Matrix, Array","SparseMatrix, any","DenseMatrix, any","any, SparseMatrix","any, DenseMatrix","Array, any","any, Array","toTex","2","concat","operators","deepMap","bigBitNot","bitNot","number","BigNumber","Array | Matrix","1","bigBitOr","algorithm01","algorithm04","algorithm10","bitOr","bigBitXor","algorithm03","algorithm07","algorithm12","bitXor"],"mappings":"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","file":"js/f37232f975dd7810a63f.js","sourcesContent":["'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar bigBitAnd = require('../../utils/bignumber/bitAnd');\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));\n  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));\n  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Bitwise AND two values, `x & y`.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.bitAnd(x, y)\n   *\n   * Examples:\n   *\n   *    math.bitAnd(53, 131)               // returns number 1\n   *\n   *    math.bitAnd([1, 12, 31], 42)       // returns Array [0, 8, 10]\n   *\n   * See also:\n   *\n   *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift\n   *\n   * @param  {number | BigNumber | Array | Matrix} x First value to and\n   * @param  {number | BigNumber | Array | Matrix} y Second value to and\n   * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`\n   */\n\n  var bitAnd = typed('bitAnd', {\n    'number, number': function numberNumber(x, y) {\n      if (!isInteger(x) || !isInteger(y)) {\n        throw new Error('Integers expected in function bitAnd');\n      }\n\n      return x & y;\n    },\n    'BigNumber, BigNumber': bigBitAnd,\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm06(x, y, bitAnd, false);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      return algorithm02(y, x, bitAnd, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm02(x, y, bitAnd, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, bitAnd);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      // use matrix implementation\n      return bitAnd(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use matrix implementation\n      return bitAnd(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use matrix implementation\n      return bitAnd(x, matrix(y));\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, bitAnd, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, bitAnd, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm11(y, x, bitAnd, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, bitAnd, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, bitAnd, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, bitAnd, true).valueOf();\n    }\n  });\n  bitAnd.toTex = {\n    2: \"\\\\left(${args[0]}\".concat(latex.operators['bitAnd'], \"${args[1]}\\\\right)\")\n  };\n  return bitAnd;\n}\n\nexports.name = 'bitAnd';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nvar bigBitNot = require('../../utils/bignumber/bitNot');\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n  /**\n   * Bitwise NOT value, `~x`.\n   * For matrices, the function is evaluated element wise.\n   * For units, the function is evaluated on the best prefix base.\n   *\n   * Syntax:\n   *\n   *    math.bitNot(x)\n   *\n   * Examples:\n   *\n   *    math.bitNot(1)               // returns number -2\n   *\n   *    math.bitNot([2, -3, 4])      // returns Array [-3, 2, 5]\n   *\n   * See also:\n   *\n   *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift\n   *\n   * @param  {number | BigNumber | Array | Matrix} x Value to not\n   * @return {number | BigNumber | Array | Matrix} NOT of `x`\n   */\n\n\n  var bitNot = typed('bitNot', {\n    'number': function number(x) {\n      if (!isInteger(x)) {\n        throw new Error('Integer expected in function bitNot');\n      }\n\n      return ~x;\n    },\n    'BigNumber': bigBitNot,\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, bitNot);\n    }\n  });\n  bitNot.toTex = {\n    1: latex.operators['bitNot'] + \"\\\\left(${args[0]}\\\\right)\"\n  };\n  return bitNot;\n}\n\nexports.name = 'bitNot';\nexports.factory = factory;","'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar bigBitOr = require('../../utils/bignumber/bitOr');\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));\n  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));\n  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Bitwise OR two values, `x | y`.\n   * For matrices, the function is evaluated element wise.\n   * For units, the function is evaluated on the lowest print base.\n   *\n   * Syntax:\n   *\n   *    math.bitOr(x, y)\n   *\n   * Examples:\n   *\n   *    math.bitOr(1, 2)               // returns number 3\n   *\n   *    math.bitOr([1, 2, 3], 4)       // returns Array [5, 6, 7]\n   *\n   * See also:\n   *\n   *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift\n   *\n   * @param  {number | BigNumber | Array | Matrix} x First value to or\n   * @param  {number | BigNumber | Array | Matrix} y Second value to or\n   * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`\n   */\n\n  var bitOr = typed('bitOr', {\n    'number, number': function numberNumber(x, y) {\n      if (!isInteger(x) || !isInteger(y)) {\n        throw new Error('Integers expected in function bitOr');\n      }\n\n      return x | y;\n    },\n    'BigNumber, BigNumber': bigBitOr,\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm04(x, y, bitOr);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      return algorithm01(y, x, bitOr, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm01(x, y, bitOr, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, bitOr);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      // use matrix implementation\n      return bitOr(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use matrix implementation\n      return bitOr(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use matrix implementation\n      return bitOr(x, matrix(y));\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm10(x, y, bitOr, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, bitOr, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm10(y, x, bitOr, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, bitOr, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, bitOr, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, bitOr, true).valueOf();\n    }\n  });\n  bitOr.toTex = {\n    2: \"\\\\left(${args[0]}\".concat(latex.operators['bitOr'], \"${args[1]}\\\\right)\")\n  };\n  return bitOr;\n}\n\nexports.name = 'bitOr';\nexports.factory = factory;","'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar bigBitXor = require('../../utils/bignumber/bitXor');\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));\n  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));\n  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Bitwise XOR two values, `x ^ y`.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.bitXor(x, y)\n   *\n   * Examples:\n   *\n   *    math.bitXor(1, 2)               // returns number 3\n   *\n   *    math.bitXor([2, 3, 4], 4)       // returns Array [6, 7, 0]\n   *\n   * See also:\n   *\n   *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift\n   *\n   * @param  {number | BigNumber | Array | Matrix} x First value to xor\n   * @param  {number | BigNumber | Array | Matrix} y Second value to xor\n   * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`\n   */\n\n  var bitXor = typed('bitXor', {\n    'number, number': function numberNumber(x, y) {\n      if (!isInteger(x) || !isInteger(y)) {\n        throw new Error('Integers expected in function bitXor');\n      }\n\n      return x ^ y;\n    },\n    'BigNumber, BigNumber': bigBitXor,\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm07(x, y, bitXor);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      return algorithm03(y, x, bitXor, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm03(x, y, bitXor, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, bitXor);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      // use matrix implementation\n      return bitXor(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use matrix implementation\n      return bitXor(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use matrix implementation\n      return bitXor(x, matrix(y));\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm12(x, y, bitXor, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, bitXor, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm12(y, x, bitXor, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, bitXor, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, bitXor, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, bitXor, true).valueOf();\n    }\n  });\n  bitXor.toTex = {\n    2: \"\\\\left(${args[0]}\".concat(latex.operators['bitXor'], \"${args[1]}\\\\right)\")\n  };\n  return bitXor;\n}\n\nexports.name = 'bitXor';\nexports.factory = factory;"],"sourceRoot":""}