{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/DenseMatrix.js"],"names":["util","__webpack_require__","DimensionError","string","array","object","number","isArray","Array","isNumber","isInteger","isString","validateIndex","exports","name","path","factory","type","config","load","typed","getArrayDataType","Matrix","DenseMatrix","data","datatype","this","SyntaxError","Error","isMatrix","_data","clone","_size","_datatype","toArray","size","preprocess","i","ii","length","elem","valueOf","validate","TypeError","types","_resize","matrix","defaultValue","v","slice","resize","_fit","newSize","changed","push","prototype","isDenseMatrix","getDataType","storage","create","subset","index","replacement","arguments","isIndex","isScalar","get","min","max","_getSubmatrix","dims","dim","last","range","dimension","map","child","_get","submatrix","sSize","iSize","set","outer","unsqueeze","deepEqual","_setSubmatrix","forEach","dataIndex","subIndex","_set","x","indexI","value","copy","reshape","m","callback","me","recurse","concat","format","options","toString","toJSON","mathjs","diagonal","k","isBigNumber","toNumber","kSuper","kSub","rows","columns","n","Math","s","convert","_value","ms","BigNumber","d","fromJSON","json","swapRows","j","_swapRows","vi","_storage","dense","lazy"],"mappings":"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","file":"js/4082dba61cc5cafdee23.js","sourcesContent":["'use strict';\n\nvar util = require('../../utils/index');\n\nvar DimensionError = require('../../error/DimensionError');\n\nvar string = util.string;\nvar array = util.array;\nvar object = util.object;\nvar number = util.number;\nvar isArray = Array.isArray;\nvar isNumber = number.isNumber;\nvar isInteger = number.isInteger;\nvar isString = string.isString;\nvar validateIndex = array.validateIndex;\n\nfunction factory(type, config, load, typed) {\n  var getArrayDataType = load(require('./utils/getArrayDataType'));\n  var Matrix = load(require('./Matrix')); // force loading Matrix (do not use via type.Matrix)\n\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (type.isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = object.clone(data._data);\n        this._size = object.clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = array.size(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      array.validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Attach type information\n   */\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | DenseMatrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n\n  function _get(matrix, index) {\n    if (!type.isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (type.isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = array.size(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = array.unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!object.deepEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    } // matrix to resize\n\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, size, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = array.resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = array.reshape(m._data, size);\n    m._size = size.slice(0);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: object.clone(this._data),\n      size: object.clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // return dense format\n\n\n    return new DenseMatrix({\n      data: recurse(this._data, []),\n      size: object.clone(this._size),\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return object.clone(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return string.format(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return string.format(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Array}                      The array vector with the diagonal values.\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (type.isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                   The matrix size.\n   * @param {number | Array} value          The values for the diagonal.\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]        The default value for non-diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (type.isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (type.isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    if (defaultValue && isString(datatype)) {\n      // convert defaultValue to the same datatype\n      defaultValue = typed.convert(defaultValue, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (type.isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = type.isBigNumber(_value(0)) ? new type.BigNumber(0) : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = array.resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  } // register this type in the base class Matrix\n\n\n  type.Matrix._storage.dense = DenseMatrix;\n  type.Matrix._storage['default'] = DenseMatrix; // exports\n\n  return DenseMatrix;\n}\n\nexports.name = 'DenseMatrix';\nexports.path = 'type';\nexports.factory = factory;\nexports.lazy = false; // no lazy loading, as we alter type.Matrix._storage"],"sourceRoot":""}