{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/typed-function/typed-function.js"],"names":["__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","ok","notOk","undef","create","_types","name","test","x","Array","isArray","Date","RegExp","constructor","Object","anyType","_ignore","_conversions","typed","types","conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","toLowerCase","TypeError","findTypeIndex","type","indexOf","findTypeName","value","stringifyParams","params","map","param","typeNames","getTypeName","restParam","join","parseParam","length","slice","split","trim","filter","notEmpty","notIgnore","matchingConversions","matches","forEach","conversion","from","to","keys","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","concat","hasRestParam","last","hasConversions","some","compileTest","test0","test1","tests","i","compileTests","arr","varIndex","lastTest","args","testRestParam","getParamAtIndex","signature","index","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","signatures","entries","uniq","flatMap","getLowestTypeIndex","min","Math","getLowestConversionIndex","compareParams","param1","param2","c","compareSignatures","signature1","signature2","len","compileArgConversion","conversion0","conversion1","push","convert","arg","splitParams","ignoreConversionTypes","_splitParams","typeGroups","filteredTypes","typeGroup","splittedParams","createTypedFunction","signaturesMap","SyntaxError","parsedSignatures","fn","array","parsedParam","isInvalidParam","parseSignature","notNull","parsedSignature","conflictingSignature","s","ii","max","typesNames1","typesNames2","hasOverlap","len1","len2","restParam1","restParam2","hasConflictingParams","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fnConvert","compiledConversions","arguments","apply","fnPreprocess","offset","compileArgsPreprocessing","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","err","expected","_name","matchingSignatures","nextMatchingDefs","actualType","data","category","actual","lengths","Infinity","maxLength","expectedLength","createError","arg0","arg1","defineProperty","createSignaturesMap","str","start","end","prototype","call","array1","array2","item","callback","getName","Error","extractSignatures","validateUnique","_signature","_fn","hasOwnProperty","string, Object","...Function","string, ...Function","find","match","addType","beforeObjectTest","splice","addConversion","exports","module"],"mappings":"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","file":"js/bc374efad4696a075c5e.js","sourcesContent":["/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(null,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn)\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }\n\n        return generic.apply(null, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));"],"sourceRoot":""}