{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/arithmetic/pow.js"],"names":["isInteger","__webpack_require__","size","exports","name","factory","type","config","load","typed","latex","identity","multiply","matrix","fraction","number","pow","number, number","_pow","Complex, Complex","x","y","BigNumber, BigNumber","predictable","Complex","toNumber","Fraction, Fraction","d","Error","valueOf","Array, number","_powArray","Array, BigNumber","Matrix, number","_powMatrix","Matrix, BigNumber","Unit, number | BigNumber","yFrac","yNum","Math","abs","n","ex","Infinity","NaN","TypeError","s","length","res","px","toTex","2","concat","operators"],"mappings":"0FAEA,IAAAA,EAAgBC,EAAQ,GAAoBD,UAE5CE,EAAWD,EAAQ,GAAmBC,KAsLtCC,EAAAC,KAAA,MACAD,EAAAE,QArLA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAcT,EAAQ,GAEtBU,EAAAH,EAAsBP,EAAQ,KAC9BW,EAAAJ,EAAsBP,EAAQ,KAC9BY,EAAAL,EAAoBP,EAAQ,IAC5Ba,EAAAN,EAAsBP,EAAQ,KAC9Bc,EAAAP,EAAoBP,EAAQ,KAkC5Be,EAAAP,EAAA,OACAQ,iBAAAC,EACAC,mBAAA,SAAAC,EAAAC,GACA,OAAAD,EAAAJ,IAAAK,IAEAC,uBAAA,SAAAF,EAAAC,GACA,OAAAA,EAAArB,aAAAoB,GAAA,GAAAb,EAAAgB,YACAH,EAAAJ,IAAAK,GAEA,IAAAf,EAAAkB,QAAAJ,EAAAK,WAAA,GAAAT,IAAAK,EAAAI,WAAA,IAGAC,qBAAA,SAAAN,EAAAC,GACA,OAAAA,EAAAM,EAAA,CACA,GAAApB,EAAAgB,YACA,UAAAK,MAAA,sEAEA,OAAAV,EAAAE,EAAAS,UAAAR,EAAAQ,WAGA,OAAAT,EAAAJ,IAAAK,IAGAS,gBAAAC,EACAC,mBAAA,SAAAZ,EAAAC,GACA,OAAAU,EAAAX,EAAAC,EAAAI,aAEAQ,iBAAAC,EACAC,oBAAA,SAAAf,EAAAC,GACA,OAAAa,EAAAd,EAAAC,EAAAI,aAEAW,2BAAA,SAAAhB,EAAAC,GACA,OAAAD,EAAAJ,IAAAK,MAWA,SAAAH,EAAAE,EAAAC,GAGA,GAAAd,EAAAgB,cAAAvB,EAAAqB,IAAAD,EAAA,EAEA,IACA,IAAAiB,EAAAvB,EAAAO,GACAiB,EAAAvB,EAAAsB,GAEA,IAAAhB,IAAAiB,GAAAC,KAAAC,KAAAnB,EAAAiB,GAAAjB,GAAA,QACAgB,EAAAV,EAAA,KACA,OAAAU,EAAAI,EAAA,WAAAF,KAAAvB,KAAAI,EAAAC,GAGO,MAAAqB,IAOP,OAAAtB,IAAA,GAAAC,IAAAsB,KAAAvB,IAAA,GAAAC,KAAA,IACA,EAMAd,EAAAgB,cAAAH,GAAA,GAAAC,IAAAsB,KAAAvB,GAAA,GAAAA,EAAA,GAAAC,KAAA,KACAuB,IAGA5C,EAAAqB,IAAAD,GAAA,GAAAb,EAAAgB,YACAgB,KAAAvB,IAAAI,EAAAC,GAEA,IAAAf,EAAAkB,QAAAJ,EAAA,GAAAJ,IAAAK,EAAA,GAYA,SAAAU,EAAAX,EAAAC,GACA,IAAArB,EAAAqB,MAAA,EACA,UAAAwB,UAAA,mDAAAxB,EAAA,KAIA,IAAAyB,EAAA5C,EAAAkB,GAEA,OAAA0B,EAAAC,OACA,UAAAnB,MAAA,2CAAAkB,EAAAC,OAAA,gBAGA,GAAAD,EAAA,KAAAA,EAAA,GACA,UAAAlB,MAAA,sCAAAkB,EAAA,OAAAA,EAAA,QAMA,IAHA,IAAAE,EAAArC,EAAAmC,EAAA,IAAAjB,UACAoB,EAAA7B,EAEAC,GAAA,GACA,MAAAA,KACA2B,EAAApC,EAAAqC,EAAAD,IAGA3B,IAAA,EACA4B,EAAArC,EAAAqC,KAGA,OAAAD,EAWA,SAAAd,EAAAd,EAAAC,GACA,OAAAR,EAAAkB,EAAAX,EAAAS,UAAAR,IAMA,OAHAL,EAAAkC,MAAA,CACAC,EAAA,4BAAyBC,OAAA1C,EAAA2C,UAAA,qBAEzBrC","file":"js/f0b330c7aa56ced295f5.js","sourcesContent":["'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar size = require('../../utils/array').size;\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var identity = load(require('../matrix/identity'));\n  var multiply = load(require('./multiply'));\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var fraction = load(require('../../type/fraction/function/fraction'));\n  var number = load(require('../../type/number'));\n  /**\n   * Calculates the power of x to y, `x ^ y`.\n   * Matrix exponentiation is supported for square matrices `x`, and positive\n   * integer exponents `y`.\n   *\n   * For cubic roots of negative numbers, the function returns the principal\n   * root by default. In order to let the function return the real root,\n   * math.js can be configured with `math.config({predictable: true})`.\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\n   *\n   * Syntax:\n   *\n   *    math.pow(x, y)\n   *\n   * Examples:\n   *\n   *    math.pow(2, 3)               // returns number 8\n   *\n   *    const a = math.complex(2, 3)\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\n   *\n   *    const b = [[1, 2], [4, 3]]\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\n   *\n   * See also:\n   *\n   *    multiply, sqrt, cbrt, nthRoot\n   *\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\n   * @param  {number | BigNumber | Complex} y                          The exponent\n   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`\n   */\n\n  var pow = typed('pow', {\n    'number, number': _pow,\n    'Complex, Complex': function ComplexComplex(x, y) {\n      return x.pow(y);\n    },\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\n      if (y.isInteger() || x >= 0 || config.predictable) {\n        return x.pow(y);\n      } else {\n        return new type.Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\n      }\n    },\n    'Fraction, Fraction': function FractionFraction(x, y) {\n      if (y.d !== 1) {\n        if (config.predictable) {\n          throw new Error('Function pow does not support non-integer exponents for fractions.');\n        } else {\n          return _pow(x.valueOf(), y.valueOf());\n        }\n      } else {\n        return x.pow(y);\n      }\n    },\n    'Array, number': _powArray,\n    'Array, BigNumber': function ArrayBigNumber(x, y) {\n      return _powArray(x, y.toNumber());\n    },\n    'Matrix, number': _powMatrix,\n    'Matrix, BigNumber': function MatrixBigNumber(x, y) {\n      return _powMatrix(x, y.toNumber());\n    },\n    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {\n      return x.pow(y);\n    }\n  });\n  /**\n   * Calculates the power of x to y, x^y, for two numbers.\n   * @param {number} x\n   * @param {number} y\n   * @return {number | Complex} res\n   * @private\n   */\n\n  function _pow(x, y) {\n    // Alternatively could define a 'realmode' config option or something, but\n    // 'predictable' will work for now\n    if (config.predictable && !isInteger(y) && x < 0) {\n      // Check to see if y can be represented as a fraction\n      try {\n        var yFrac = fraction(y);\n        var yNum = number(yFrac);\n\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\n          if (yFrac.d % 2 === 1) {\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\n          }\n        }\n      } catch (ex) {} // fraction() throws an error if y is Infinity, etc.\n      // Unable to express y as a fraction, so continue on\n\n    } // x^Infinity === 0 if -1 < x < 1\n    // A real number 0 is returned instead of complex(0)\n\n\n    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\n      return 0;\n    } // **for predictable mode** x^Infinity === NaN if x < -1\n    // N.B. this behavour is different from `Math.pow` which gives\n    // (-2)^Infinity === Infinity\n\n\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\n      return NaN;\n    }\n\n    if (isInteger(y) || x >= 0 || config.predictable) {\n      return Math.pow(x, y);\n    } else {\n      return new type.Complex(x, 0).pow(y, 0);\n    }\n  }\n  /**\n   * Calculate the power of a 2d array\n   * @param {Array} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a positive, integer value\n   * @returns {Array}\n   * @private\n   */\n\n\n  function _powArray(x, y) {\n    if (!isInteger(y) || y < 0) {\n      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');\n    } // verify that A is a 2 dimensional square matrix\n\n\n    var s = size(x);\n\n    if (s.length !== 2) {\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\n    }\n\n    if (s[0] !== s[1]) {\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\n    }\n\n    var res = identity(s[0]).valueOf();\n    var px = x;\n\n    while (y >= 1) {\n      if ((y & 1) === 1) {\n        res = multiply(px, res);\n      }\n\n      y >>= 1;\n      px = multiply(px, px);\n    }\n\n    return res;\n  }\n  /**\n   * Calculate the power of a 2d matrix\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a positive, integer value\n   * @returns {Matrix}\n   * @private\n   */\n\n\n  function _powMatrix(x, y) {\n    return matrix(_powArray(x.valueOf(), y));\n  }\n\n  pow.toTex = {\n    2: \"\\\\left(${args[0]}\\\\right)\".concat(latex.operators['pow'], \"{${args[1]}}\")\n  };\n  return pow;\n}\n\nexports.name = 'pow';\nexports.factory = factory;"],"sourceRoot":""}