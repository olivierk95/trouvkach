{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/deepMap.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/emitter.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/customs.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/boolean.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/scatter.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/index.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/function.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/deepForEach.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/latex.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/isCollection.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/containsCollections.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/isMatrix.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/collection/reduce.js"],"names":["module","exports","deepMap","array","callback","skipZeros","map","x","Emitter","__webpack_require__","mixin","obj","emitter","on","bind","off","once","emit","_typeof","Symbol","iterator","constructor","prototype","hasOwnProperty","isSafeProperty","object","prop","safeNativeProperties","Object","Function","isSafeMethod","method","getPrototypeOf","safeNativeMethods","isPlainObject","length","name","toString","valueOf","toLocaleString","getSafeProperty","Error","setSafeProperty","value","validateSafeMethod","isBoolean","a","j","w","u","mark","c","f","inverse","update","k","k0","k1","i","avalues","_values","aindex","_index","aptr","_ptr","cindex","push","number","string","memoize","fn","hasher","cache","args","arguments","hash","JSON","stringify","apply","maxArgumentCount","keys","signatures","reduce","signature","count","match","Math","max","callWithRightArgumentCount","argCount","isMatrix","deepForEach","ii","Array","isArray","escapeLatex","symbols","Alpha","alpha","Beta","beta","Gamma","gamma","Delta","delta","Epsilon","epsilon","varepsilon","Zeta","zeta","Eta","eta","Theta","theta","vartheta","Iota","iota","Kappa","kappa","varkappa","Lambda","lambda","Mu","mu","Nu","nu","Xi","xi","Omicron","omicron","Pi","pi","varpi","Rho","rho","varrho","Sigma","sigma","varsigma","Tau","tau","Upsilon","upsilon","Phi","phi","varphi","Chi","chi","Psi","psi","Omega","omega","true","false","inf","Inf","infinity","Infinity","oo","lim","undefined","operators","transpose","ctranspose","factorial","pow","dotPow","unaryPlus","unaryMinus","bitNot","not","multiply","divide","dotMultiply","dotDivide","mod","add","subtract","to","leftShift","rightArithShift","rightLogShift","equal","unequal","smaller","larger","smallerEq","largerEq","bitAnd","bitXor","bitOr","and","xor","or","defaultTemplate","units","deg","escape","preserveFormatting","toSymbol","isUnit","isCollection","arraySize","size","IndexError","_reduce","mat","dim","ret","val","tran","I","J","tmp","_switch","create"],"mappings":"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","file":"js/87b1aa35063205ad724f.js","sourcesContent":["'use strict';\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\nmodule.exports = function deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n};","'use strict';\n\nvar Emitter = require('tiny-emitter');\n/**\n * Extend given object with emitter functions `on`, `off`, `once`, `emit`\n * @param {Object} obj\n * @return {Object} obj\n */\n\n\nexports.mixin = function (obj) {\n  // create event emitter\n  var emitter = new Emitter(); // bind methods to obj (we don't want to expose the emitter.e Array...)\n\n  obj.on = emitter.on.bind(emitter);\n  obj.off = emitter.off.bind(emitter);\n  obj.once = emitter.once.bind(emitter);\n  obj.emit = emitter.emit.bind(emitter);\n  return obj;\n};","'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar hasOwnProperty = require('./object').hasOwnProperty;\n/**\n * Get a property of a plain object\n * Throws an error in case the object is not a plain object or the\n * property is not defined on the object itself\n * @param {Object} object\n * @param {string} prop\n * @return {*} Returns the property value when safe\n */\n\n\nfunction getSafeProperty(object, prop) {\n  // only allow getting safe properties of a plain object\n  if (isPlainObject(object) && isSafeProperty(object, prop)) {\n    return object[prop];\n  }\n\n  if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {\n    throw new Error('Cannot access method \"' + prop + '\" as a property');\n  }\n\n  throw new Error('No access to property \"' + prop + '\"');\n}\n/**\n * Set a property on a plain object.\n * Throws an error in case the object is not a plain object or the\n * property would override an inherited property like .constructor or .toString\n * @param {Object} object\n * @param {string} prop\n * @param {*} value\n * @return {*} Returns the value\n */\n// TODO: merge this function into access.js?\n\n\nfunction setSafeProperty(object, prop, value) {\n  // only allow setting safe properties of a plain object\n  if (isPlainObject(object) && isSafeProperty(object, prop)) {\n    object[prop] = value;\n    return value;\n  }\n\n  throw new Error('No access to property \"' + prop + '\"');\n}\n/**\n * Test whether a property is safe to use for an object.\n * For example .toString and .constructor are not safe\n * @param {string} prop\n * @return {boolean} Returns true when safe\n */\n\n\nfunction isSafeProperty(object, prop) {\n  if (!object || _typeof(object) !== 'object') {\n    return false;\n  } // SAFE: whitelisted\n  // e.g length\n\n\n  if (hasOwnProperty(safeNativeProperties, prop)) {\n    return true;\n  } // UNSAFE: inherited from Object prototype\n  // e.g constructor\n\n\n  if (prop in Object.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Object.prototype is a root object\n    return false;\n  } // UNSAFE: inherited from Function prototype\n  // e.g call, apply\n\n\n  if (prop in Function.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Function.prototype is a root object\n    return false;\n  }\n\n  return true;\n}\n/**\n * Validate whether a method is safe.\n * Throws an error when that's not the case.\n * @param {Object} object\n * @param {string} method\n */\n// TODO: merge this function into assign.js?\n\n\nfunction validateSafeMethod(object, method) {\n  if (!isSafeMethod(object, method)) {\n    throw new Error('No access to method \"' + method + '\"');\n  }\n}\n/**\n * Check whether a method is safe.\n * Throws an error when that's not the case (for example for `constructor`).\n * @param {Object} object\n * @param {string} method\n * @return {boolean} Returns true when safe, false otherwise\n */\n\n\nfunction isSafeMethod(object, method) {\n  if (!object || typeof object[method] !== 'function') {\n    return false;\n  } // UNSAFE: ghosted\n  // e.g overridden toString\n  // Note that IE10 doesn't support __proto__ and we can't do this check there.\n\n\n  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {\n    return false;\n  } // SAFE: whitelisted\n  // e.g toString\n\n\n  if (hasOwnProperty(safeNativeMethods, method)) {\n    return true;\n  } // UNSAFE: inherited from Object prototype\n  // e.g constructor\n\n\n  if (method in Object.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Object.prototype is a root object\n    return false;\n  } // UNSAFE: inherited from Function prototype\n  // e.g call, apply\n\n\n  if (method in Function.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Function.prototype is a root object\n    return false;\n  }\n\n  return true;\n}\n\nfunction isPlainObject(object) {\n  return _typeof(object) === 'object' && object && object.constructor === Object;\n}\n\nvar safeNativeProperties = {\n  length: true,\n  name: true\n};\nvar safeNativeMethods = {\n  toString: true,\n  valueOf: true,\n  toLocaleString: true\n};\nexports.getSafeProperty = getSafeProperty;\nexports.setSafeProperty = setSafeProperty;\nexports.isSafeProperty = isSafeProperty;\nexports.validateSafeMethod = validateSafeMethod;\nexports.isSafeMethod = isSafeMethod;\nexports.isPlainObject = isPlainObject;","'use strict';\n/**\n * Test whether value is a boolean\n * @param {*} value\n * @return {boolean} isBoolean\n */\n\nexports.isBoolean = function (value) {\n  return typeof value === 'boolean';\n};","'use strict';\n\nmodule.exports = function scatter(a, j, w, x, u, mark, c, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // c arrays\n\n  var cindex = c._index; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n};","'use strict';\n\nexports.array = require('./array');\nexports['boolean'] = require('./boolean');\nexports['function'] = require('./function');\nexports.number = require('./number');\nexports.object = require('./object');\nexports.string = require('./string');\nexports.emitter = require('./emitter');","'use strict'; // function utils\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {function(args: Array)} [hasher]  A custom hash builder.\n *                                          Is JSON.stringify by default.\n * @return {function}                       Returns the memoized function\n */\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexports.memoize = function (fn, hasher) {\n  return function memoize() {\n    if (_typeof(memoize.cache) !== 'object') {\n      memoize.cache = {};\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher ? hasher(args) : JSON.stringify(args);\n\n    if (!(hash in memoize.cache)) {\n      memoize.cache[hash] = fn.apply(fn, args);\n    }\n\n    return memoize.cache[hash];\n  };\n};\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\n\nexports.maxArgumentCount = function (fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n};\n/**\n * Call a typed function with the\n * @param {function} fn   A function or typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\n\nexports.callWithRightArgumentCount = function (fn, args, argCount) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n};","'use strict';\n\nvar isMatrix = require('./isMatrix');\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\n\nmodule.exports = function deepForEach(array, callback) {\n  if (isMatrix(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n};","'use strict';\n\nvar escapeLatex = require('escape-latex');\n\nexports.symbols = {\n  // GREEK LETTERS\n  Alpha: 'A',\n  alpha: '\\\\alpha',\n  Beta: 'B',\n  beta: '\\\\beta',\n  Gamma: '\\\\Gamma',\n  gamma: '\\\\gamma',\n  Delta: '\\\\Delta',\n  delta: '\\\\delta',\n  Epsilon: 'E',\n  epsilon: '\\\\epsilon',\n  varepsilon: '\\\\varepsilon',\n  Zeta: 'Z',\n  zeta: '\\\\zeta',\n  Eta: 'H',\n  eta: '\\\\eta',\n  Theta: '\\\\Theta',\n  theta: '\\\\theta',\n  vartheta: '\\\\vartheta',\n  Iota: 'I',\n  iota: '\\\\iota',\n  Kappa: 'K',\n  kappa: '\\\\kappa',\n  varkappa: '\\\\varkappa',\n  Lambda: '\\\\Lambda',\n  lambda: '\\\\lambda',\n  Mu: 'M',\n  mu: '\\\\mu',\n  Nu: 'N',\n  nu: '\\\\nu',\n  Xi: '\\\\Xi',\n  xi: '\\\\xi',\n  Omicron: 'O',\n  omicron: 'o',\n  Pi: '\\\\Pi',\n  pi: '\\\\pi',\n  varpi: '\\\\varpi',\n  Rho: 'P',\n  rho: '\\\\rho',\n  varrho: '\\\\varrho',\n  Sigma: '\\\\Sigma',\n  sigma: '\\\\sigma',\n  varsigma: '\\\\varsigma',\n  Tau: 'T',\n  tau: '\\\\tau',\n  Upsilon: \"\\\\Upsilon\",\n  upsilon: \"\\\\upsilon\",\n  Phi: '\\\\Phi',\n  phi: '\\\\phi',\n  varphi: '\\\\varphi',\n  Chi: 'X',\n  chi: '\\\\chi',\n  Psi: '\\\\Psi',\n  psi: '\\\\psi',\n  Omega: '\\\\Omega',\n  omega: '\\\\omega',\n  // logic\n  'true': '\\\\mathrm{True}',\n  'false': '\\\\mathrm{False}',\n  // other\n  i: 'i',\n  // TODO use \\i ??\n  inf: '\\\\infty',\n  Inf: '\\\\infty',\n  infinity: '\\\\infty',\n  Infinity: '\\\\infty',\n  oo: '\\\\infty',\n  lim: '\\\\lim',\n  'undefined': '\\\\mathbf{?}'\n};\nexports.operators = {\n  'transpose': '^\\\\top',\n  'ctranspose': '^H',\n  'factorial': '!',\n  'pow': '^',\n  'dotPow': '.^\\\\wedge',\n  // TODO find ideal solution\n  'unaryPlus': '+',\n  'unaryMinus': '-',\n  'bitNot': '\\\\~',\n  // TODO find ideal solution\n  'not': '\\\\neg',\n  'multiply': '\\\\cdot',\n  'divide': '\\\\frac',\n  // TODO how to handle that properly?\n  'dotMultiply': '.\\\\cdot',\n  // TODO find ideal solution\n  'dotDivide': '.:',\n  // TODO find ideal solution\n  'mod': '\\\\mod',\n  'add': '+',\n  'subtract': '-',\n  'to': '\\\\rightarrow',\n  'leftShift': '<<',\n  'rightArithShift': '>>',\n  'rightLogShift': '>>>',\n  'equal': '=',\n  'unequal': '\\\\neq',\n  'smaller': '<',\n  'larger': '>',\n  'smallerEq': '\\\\leq',\n  'largerEq': '\\\\geq',\n  'bitAnd': '\\\\&',\n  'bitXor': \"\\\\underline{|}\",\n  'bitOr': '|',\n  'and': '\\\\wedge',\n  'xor': '\\\\veebar',\n  'or': '\\\\vee'\n};\nexports.defaultTemplate = \"\\\\mathrm{${name}}\\\\left(${args}\\\\right)\";\nvar units = {\n  deg: '^\\\\circ'\n};\n\nexports.escape = function (string) {\n  return escapeLatex(string, {\n    'preserveFormatting': true\n  });\n}; // @param {string} name\n// @param {boolean} isUnit\n\n\nexports.toSymbol = function (name, isUnit) {\n  isUnit = typeof isUnit === 'undefined' ? false : isUnit;\n\n  if (isUnit) {\n    if (units.hasOwnProperty(name)) {\n      return units[name];\n    }\n\n    return '\\\\mathrm{' + exports.escape(name) + '}';\n  }\n\n  if (exports.symbols.hasOwnProperty(name)) {\n    return exports.symbols[name];\n  }\n\n  return exports.escape(name);\n};","'use strict';\n\nvar isMatrix = require('./isMatrix');\n/**\n * Test whether a value is a collection: an Array or Matrix\n * @param {*} x\n * @returns {boolean} isCollection\n */\n\n\nmodule.exports = function isCollection(x) {\n  return Array.isArray(x) || isMatrix(x);\n};","'use strict';\n\nvar isCollection = require('./isCollection');\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\n\n\nmodule.exports = function containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if (isCollection(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};","'use strict';\n/**\n * Test whether a value is a Matrix\n * @param {*} x\n * @returns {boolean} returns true with input is a Matrix\n *                    (like a DenseMatrix or SparseMatrix)\n */\n\nmodule.exports = function isMatrix(x) {\n  return x && x.constructor.prototype.isMatrix || false;\n};","'use strict';\n\nvar arraySize = require('../array').size;\n\nvar isMatrix = require('../collection/isMatrix');\n\nvar IndexError = require('../../error/IndexError');\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\n\nmodule.exports = function (mat, dim, callback) {\n  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new IndexError(dim, size.length);\n  }\n\n  if (isMatrix(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n};\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n}"],"sourceRoot":""}