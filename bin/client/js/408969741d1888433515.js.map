{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/det.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/cross.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/ctranspose.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/concat.js"],"names":["util","__webpack_require__","object","string","exports","name","factory","type","config","load","typed","matrix","subtract","multiply","unaryMinus","lup","det","any","x","clone","Array | Matrix","size","isMatrix","Array","isArray","length","valueOf","RangeError","format","rows","cols","decomp","_det2","U","_i","evenCycles","i","visited","j","cycleLen","p","_det","toTex","1","array","cross","Matrix, Matrix","y","_cross","toArray","Matrix, Array","Array, Matrix","Array, Array","2","highestDimension","Math","max","squeeze","xSize","ySize","join","product","transpose","conj","latex","ctranspose","concat","operators","IndexError","DimensionError","_concat","a","b","concatDim","dim","c","isInteger","...Array | Matrix | number | BigNumber","args","prevDim","len","asMatrix","matrices","arg","isNumber","isBigNumber","Error","TypeError","m","SyntaxError","res","shift","...string","undefined"],"mappings":"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","file":"js/408969741d1888433515.js","sourcesContent":["'use strict';\n\nvar util = require('../../utils/index');\n\nvar object = util.object;\nvar string = util.string;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var subtract = load(require('../arithmetic/subtract'));\n  var multiply = load(require('../arithmetic/multiply'));\n  var unaryMinus = load(require('../arithmetic/unaryMinus'));\n  var lup = load(require('../algebra/decomposition/lup'));\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n\n  var det = typed('det', {\n    'any': function any(x) {\n      return object.clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (type.isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return object.clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return object.clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + string.format(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          var rows = size[0];\n          var cols = size[1];\n\n          if (rows === cols) {\n            return _det(x.clone().valueOf(), rows, cols);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + string.format(size) + ')');\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + string.format(size) + ')');\n      }\n    }\n  });\n  det.toTex = {\n    1: \"\\\\det\\\\left(${args[0]}\\\\right)\"\n  };\n  return det;\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return object.clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var _det2 = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        _det2 = multiply(_det2, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? _det2 : unaryMinus(_det2);\n    }\n  }\n}\n\nexports.name = 'det';\nexports.factory = factory;","'use strict';\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var subtract = load(require('../arithmetic/subtract'));\n  var multiply = load(require('../arithmetic/multiply'));\n  /**\n   * Calculate the cross product for two vectors in three dimensional space.\n   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined\n   * as:\n   *\n   *    cross(A, B) = [\n   *      a2 * b3 - a3 * b2,\n   *      a3 * b1 - a1 * b3,\n   *      a1 * b2 - a2 * b1\n   *    ]\n   *\n   * If one of the input vectors has a dimension greater than 1, the output\n   * vector will be a 1x3 (2-dimensional) matrix.\n   *\n   * Syntax:\n   *\n   *    math.cross(x, y)\n   *\n   * Examples:\n   *\n   *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]\n   *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]\n   *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]\n   *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]\n   *\n   * See also:\n   *\n   *    dot, multiply\n   *\n   * @param  {Array | Matrix} x   First vector\n   * @param  {Array | Matrix} y   Second vector\n   * @return {Array | Matrix}     Returns the cross product of `x` and `y`\n   */\n\n  var cross = typed('cross', {\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      return matrix(_cross(x.toArray(), y.toArray()));\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      return matrix(_cross(x.toArray(), y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      return matrix(_cross(x, y.toArray()));\n    },\n    'Array, Array': _cross\n  });\n  cross.toTex = {\n    2: \"\\\\left(${args[0]}\\\\right)\\\\times\\\\left(${args[1]}\\\\right)\"\n  };\n  return cross;\n  /**\n   * Calculate the cross product for two arrays\n   * @param {Array} x  First vector\n   * @param {Array} y  Second vector\n   * @returns {Array} Returns the cross product of x and y\n   * @private\n   */\n\n  function _cross(x, y) {\n    var highestDimension = Math.max(array.size(x).length, array.size(y).length);\n    x = array.squeeze(x);\n    y = array.squeeze(y);\n    var xSize = array.size(x);\n    var ySize = array.size(y);\n\n    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {\n      throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');\n    }\n\n    var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];\n\n    if (highestDimension > 1) {\n      return [product];\n    } else {\n      return product;\n    }\n  }\n}\n\nexports.name = 'cross';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var transpose = load(require('./transpose'));\n  var conj = load(require('../complex/conj'));\n\n  var latex = require('../../utils/latex');\n  /**\n   * Transpose and complex conjugate a matrix. All values of the matrix are\n   * reflected over its main diagonal and then the complex conjugate is\n   * taken. This is equivalent to complex conjugation for scalars and\n   * vectors.\n   *\n   * Syntax:\n   *\n   *     math.ctranspose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]\n   *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]\n   *\n   * See also:\n   *\n   *     transpose, diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be ctransposed\n   * @return {Array | Matrix}   The ctransposed matrix\n   */\n\n\n  var ctranspose = typed('ctranspose', {\n    'any': function any(x) {\n      return conj(transpose(x));\n    }\n  });\n  ctranspose.toTex = {\n    1: \"\\\\left(${args[0]}\\\\right)\".concat(latex.operators['ctranspose'])\n  };\n  return ctranspose;\n}\n\nexports.name = 'ctranspose';\nexports.factory = factory;","'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar array = require('../../utils/array');\n\nvar IndexError = require('../../error/IndexError');\n\nvar DimensionError = require('../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var isInteger = load(require('../utils/isInteger'));\n  /**\n   * Concatenate two or more matrices.\n   *\n   * Syntax:\n   *\n   *     math.concat(A, B, C, ...)\n   *     math.concat(A, B, C, ..., dim)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *   By default the last dimension of the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [5, 6]]\n   *    const B = [[3, 4], [7, 8]]\n   *\n   *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]\n   *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]\n   *    math.concat('hello', ' ', 'world') // returns 'hello world'\n   *\n   * See also:\n   *\n   *    size, squeeze, subset, transpose\n   *\n   * @param {... Array | Matrix} args     Two or more matrices\n   * @return {Array | Matrix} Concatenated matrix\n   */\n\n  var concat = typed('concat', {\n    // TODO: change signature to '...Array | Matrix, dim?' when supported\n    '...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumber(args) {\n      var i;\n      var len = args.length;\n      var dim = -1; // zero-based dimension\n\n      var prevDim;\n      var asMatrix = false;\n      var matrices = []; // contains multi dimensional arrays\n\n      for (i = 0; i < len; i++) {\n        var arg = args[i]; // test whether we need to return a Matrix (if not we return an Array)\n\n        if (type.isMatrix(arg)) {\n          asMatrix = true;\n        }\n\n        if (type.isNumber(arg) || type.isBigNumber(arg)) {\n          if (i !== len - 1) {\n            throw new Error('Dimension must be specified as last argument');\n          } // last argument contains the dimension on which to concatenate\n\n\n          prevDim = dim;\n          dim = arg.valueOf(); // change BigNumber to number\n\n          if (!isInteger(dim)) {\n            throw new TypeError('Integer number expected for dimension');\n          }\n\n          if (dim < 0 || i > 0 && dim > prevDim) {\n            // TODO: would be more clear when throwing a DimensionError here\n            throw new IndexError(dim, prevDim + 1);\n          }\n        } else {\n          // this is a matrix or array\n          var m = clone(arg).valueOf();\n          var size = array.size(m);\n          matrices[i] = m;\n          prevDim = dim;\n          dim = size.length - 1; // verify whether each of the matrices has the same number of dimensions\n\n          if (i > 0 && dim !== prevDim) {\n            throw new DimensionError(prevDim + 1, dim + 1);\n          }\n        }\n      }\n\n      if (matrices.length === 0) {\n        throw new SyntaxError('At least one matrix expected');\n      }\n\n      var res = matrices.shift();\n\n      while (matrices.length) {\n        res = _concat(res, matrices.shift(), dim, 0);\n      }\n\n      return asMatrix ? matrix(res) : res;\n    },\n    '...string': function string(args) {\n      return args.join('');\n    }\n  });\n  concat.toTex = undefined; // use default template\n\n  return concat;\n}\n/**\n * Recursively concatenate two matrices.\n * The contents of the matrices is not cloned.\n * @param {Array} a             Multi dimensional array\n * @param {Array} b             Multi dimensional array\n * @param {number} concatDim    The dimension on which to concatenate (zero-based)\n * @param {number} dim          The current dim (zero-based)\n * @return {Array} c            The concatenated matrix\n * @private\n */\n\n\nfunction _concat(a, b, concatDim, dim) {\n  if (dim < concatDim) {\n    // recurse into next dimension\n    if (a.length !== b.length) {\n      throw new DimensionError(a.length, b.length);\n    }\n\n    var c = [];\n\n    for (var i = 0; i < a.length; i++) {\n      c[i] = _concat(a[i], b[i], concatDim, dim + 1);\n    }\n\n    return c;\n  } else {\n    // concatenate this dimension\n    return a.concat(b);\n  }\n}\n\nexports.name = 'concat';\nexports.factory = factory;"],"sourceRoot":""}