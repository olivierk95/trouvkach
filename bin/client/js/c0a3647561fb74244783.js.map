{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/Spa.js"],"names":["exports","name","path","factory","type","config","load","add","__webpack_require__","equalScalar","Spa","this","SyntaxError","_values","_heap","FibonacciHeap","prototype","isSpa","set","i","v","value","node","insert","get","accumulate","forEach","from","to","callback","heap","values","nodes","extractMinimum","push","key","length","n","swap","j","nodei","nodej","remove","undefined"],"mappings":"2FAqJAA,EAAAC,KAAA,MACAD,EAAAE,KAAA,OACAF,EAAAG,QArJA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAiBE,EAAQ,KACzBC,EAAAH,EAAyBE,EAAQ,KAMjC,SAAAE,IACA,KAAAC,gBAAAD,GACA,UAAAE,YAAA,oDAIAD,KAAAE,QAAA,GACAF,KAAAG,MAAA,IAAAV,EAAAW,cAiIA,OA1HAL,EAAAM,UAAAZ,KAAA,MACAM,EAAAM,UAAAC,OAAA,EAQAP,EAAAM,UAAAE,IAAA,SAAAC,EAAAC,GAEA,GAAAT,KAAAE,QAAAM,GAQAR,KAAAE,QAAAM,GAAAE,MAAAD,MARA,CAEA,IAAAE,EAAAX,KAAAG,MAAAS,OAAAJ,EAAAC,GAGAT,KAAAE,QAAAM,GAAAG,IAOAZ,EAAAM,UAAAQ,IAAA,SAAAL,GACA,IAAAG,EAAAX,KAAAE,QAAAM,GAEA,OAAAG,EACAA,EAAAD,MAGA,GAGAX,EAAAM,UAAAS,WAAA,SAAAN,EAAAC,GAEA,IAAAE,EAAAX,KAAAE,QAAAM,GAEAG,EAOAA,EAAAD,MAAAd,EAAAe,EAAAD,MAAAD,IALAE,EAAAX,KAAAG,MAAAS,OAAAJ,EAAAC,GAEAT,KAAAE,QAAAM,GAAAG,IAOAZ,EAAAM,UAAAU,QAAA,SAAAC,EAAAC,EAAAC,GAEA,IAAAC,EAAAnB,KAAAG,MACAiB,EAAApB,KAAAE,QAEAmB,EAAA,GAEAV,EAAAQ,EAAAG,iBAOA,IALAX,GACAU,EAAAE,KAAAZ,GAIAA,KAAAa,KAAAP,GAEAN,EAAAa,KAAAR,IAEAlB,EAAAa,EAAAD,MAAA,IAEAQ,EAAAP,EAAAa,IAAAb,EAAAD,MAAAV,QAKAW,EAAAQ,EAAAG,mBAGAD,EAAAE,KAAAZ,GAKA,QAAAH,EAAA,EAAmBA,EAAAa,EAAAI,OAAkBjB,IAAA,CAErC,IAAAkB,EAAAL,EAAAb,GAIAY,GAFAT,EAAAQ,EAAAP,OAAAc,EAAAF,IAAAE,EAAAhB,QAEAc,KAAAb,IAIAZ,EAAAM,UAAAsB,KAAA,SAAAnB,EAAAoB,GAEA,IAAAC,EAAA7B,KAAAE,QAAAM,GACAsB,EAAA9B,KAAAE,QAAA0B,GAEA,IAAAC,GAAAC,EAEAD,EAAA7B,KAAAG,MAAAS,OAAAJ,EAAAsB,EAAApB,OAEAV,KAAAG,MAAA4B,OAAAD,GAGA9B,KAAAE,QAAAM,GAAAqB,EACA7B,KAAAE,QAAA0B,QAAAI,OACK,GAAAH,IAAAC,EAELA,EAAA9B,KAAAG,MAAAS,OAAAgB,EAAAC,EAAAnB,OAEAV,KAAAG,MAAA4B,OAAAF,GAGA7B,KAAAE,QAAA0B,GAAAE,EACA9B,KAAAE,QAAAM,QAAAwB,OACK,GAAAH,GAAAC,EAAA,CAEL,IAAArB,EAAAoB,EAAAnB,MACAmB,EAAAnB,MAAAoB,EAAApB,MACAoB,EAAApB,MAAAD,IAIAV","file":"js/c0a3647561fb74244783.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load) {\n  var add = load(require('../../function/arithmetic/add'));\n  var equalScalar = load(require('../../function/relational/equalScalar'));\n  /**\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\n   * of the vector elements and an ordered list of non-zero elements.\n   */\n\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // allocate vector, TODO use typed arrays\n\n\n    this._values = [];\n    this._heap = new type.FibonacciHeap();\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n  /**\n   * Set the value for index i.\n   *\n   * @param {number} i                       The index\n   * @param {number | BigNumber | Complex}   The value at index i\n   */\n\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v); // set the value @ i\n\n\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n\n    if (node) {\n      return node.value;\n    }\n\n    return 0;\n  };\n\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v); // initialize value\n\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = add(node.value, v);\n    }\n  };\n\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values; // nodes\n\n    var nodes = []; // node with minimum key, save it\n\n    var node = heap.extractMinimum();\n\n    if (node) {\n      nodes.push(node);\n    } // extract nodes from heap (ordered)\n\n\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      } // extract next node, save it\n\n\n      node = heap.extractMinimum();\n\n      if (node) {\n        nodes.push(node);\n      }\n    } // reinsert all nodes in heap\n\n\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i]; // insert node in heap\n\n      node = heap.insert(n.key, n.value); // update values\n\n      values[node.key] = node;\n    }\n  };\n\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j]; // check we need to insert indeces\n\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\n\n      this._heap.remove(nodej); // set values\n\n\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\n\n      this._heap.remove(nodei); // set values\n\n\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n\n  return Spa;\n}\n\nexports.name = 'Spa';\nexports.path = 'type';\nexports.factory = factory;"],"sourceRoot":""}