{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/utils/polyfills.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/utils/string.js"],"names":["Number","isFinite","value","isNaN","_typeof","obj","Symbol","iterator","constructor","prototype","formatNumber","__webpack_require__","format","formatBigNumber","isBigNumber","exports","isString","endsWith","text","search","start","length","end","substring","options","s","n","d","looksLikeFraction","fraction","toString","Array","isArray","formatArray","array","str","len","i","syntax","String","entries","key","hasOwnProperty","push","join","stringify","escaped","c","charAt","indexOf","escape","replace"],"mappings":"2FAKAA,OAAAC,SAAAD,OAAAC,UAAA,SAAAC,GACA,uBAAAA,GAAAD,SAAAC,IAKAF,OAAAG,MAAAH,OAAAG,OAAA,SAAAD,GACA,OAAAA,sCCVA,SAAAE,EAAAC,GAAwU,OAAtOD,EAA3E,mBAAAE,QAAA,iBAAAA,OAAAC,SAA2E,SAAAF,GAAkC,cAAAA,GAA+B,SAAAA,GAAkC,OAAAA,GAAA,mBAAAC,QAAAD,EAAAG,cAAAF,QAAAD,IAAAC,OAAAG,UAAA,gBAAAJ,IAAmIA,GAExU,IAAAK,EAAmBC,EAAQ,GAAUC,OAErCC,EAAsBF,EAAQ,KAAuBC,OAErDE,EAAkBH,EAAQ,IAQ1BI,EAAAC,SAAA,SAAAd,GACA,uBAAAA,GASAa,EAAAE,SAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAG,OAAAF,EAAAE,OACAC,EAAAJ,EAAAG,OACA,OAAAH,EAAAK,UAAAH,EAAAE,KAAAH,GAuCAJ,EAAAH,OAAA,SAAAV,EAAAsB,GACA,oBAAAtB,EACA,OAAAQ,EAAAR,EAAAsB,GAGA,GAAAV,EAAAZ,GACA,OAAAW,EAAAX,EAAAsB,GAKA,GAkIA,SAAAtB,GACA,OAAAA,GAAA,WAAAE,EAAAF,IAAA,iBAAAA,EAAAuB,GAAA,iBAAAvB,EAAAwB,GAAA,iBAAAxB,EAAAyB,IAAA,EAnIAC,CAAA1B,GACA,OAAAsB,GAAA,YAAAA,EAAAK,SAKA3B,EAAA4B,WAHA5B,EAAAuB,EAAAvB,EAAAwB,EAAA,IAAAxB,EAAAyB,EAOA,GAAAI,MAAAC,QAAA9B,GACA,OA6FA,SAAA+B,EAAAC,EAAAV,GACA,GAAAO,MAAAC,QAAAE,GAAA,CAIA,IAHA,IAAAC,EAAA,IACAC,EAAAF,EAAAb,OAEAgB,EAAA,EAAmBA,EAAAD,EAASC,IAC5B,IAAAA,IACAF,GAAA,MAGAA,GAAAF,EAAAC,EAAAG,GAAAb,GAIA,OADAW,GAAA,IAGA,OAAApB,EAAAH,OAAAsB,EAAAV,GA7GAS,CAAA/B,EAAAsB,GAGA,GAAAT,EAAAC,SAAAd,GACA,UAAAA,EAAA,IAGA,sBAAAA,EACA,OAAAA,EAAAoC,OAAAC,OAAArC,EAAAoC,QAAA,WAGA,GAAApC,GAAA,WAAAE,EAAAF,GAAA,CACA,sBAAAA,EAAAU,OACA,OAAAV,EAAAU,OAAAY,GACK,GAAAtB,KAAA4B,aAAA,GAA0CA,WAE/C,OAAA5B,EAAA4B,WAEA,IAAAU,EAAA,GAEA,QAAAC,KAAAvC,EACAA,EAAAwC,eAAAD,IACAD,EAAAG,KAAA,IAAAF,EAAA,MAAA1B,EAAAH,OAAAV,EAAAuC,GAAAjB,IAIA,UAAegB,EAAAI,KAAA,UAIf,OAAAL,OAAArC,IAUAa,EAAA8B,UAAA,SAAA3C,GAKA,IAJA,IAAAgB,EAAAqB,OAAArC,GACA4C,EAAA,GACAT,EAAA,EAEAA,EAAAnB,EAAAG,QAAA,CACA,IAAA0B,EAAA7B,EAAA8B,OAAAX,GAEA,OAAAU,GACAD,GAAAC,EACAV,IAGA,MAFAU,EAAA7B,EAAA8B,OAAAX,MAEA,iBAAAY,QAAAF,KACAD,GAAA,MAGAA,GAAAC,GAEAD,GADK,MAAAC,EACL,MAEAA,EAGAV,IAGA,UAAAS,EAAA,KASA/B,EAAAmC,OAAA,SAAAhD,GACA,IAAAgB,EAAAqB,OAAArC,GAEA,OADAgB,IAAAiC,QAAA,cAAkCA,QAAA,eAAwBA,QAAA,cAAuBA,QAAA,aAAsBA,QAAA","file":"js/bdf0a9c5b4e59a74d70e.js","sourcesContent":["\"use strict\";\n\n// TODO: remove these polyfills as soon as we have a build process that transpiles the code to ES5\n// Polyfill for IE 11 (Number.isFinite is used in `complex.js`)\n// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\nNumber.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n}; // Polyfill for IE 11\n// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n\n\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value; // eslint-disable-line no-self-compare\n};","'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar formatNumber = require('./number').format;\n\nvar formatBigNumber = require('./bignumber/formatter').format;\n\nvar isBigNumber = require('./bignumber/isBigNumber');\n/**\n * Test whether value is a string\n * @param {*} value\n * @return {boolean} isString\n */\n\n\nexports.isString = function (value) {\n  return typeof value === 'string';\n};\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\n\n\nexports.endsWith = function (text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return text.substring(start, end) === search;\n};\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7)                // '0.2857142857142857'\n *     math.format(math.pi, 3)         // '3.14'\n *     math.format(new Complex(2, 3))  // '2 + 3i'\n *     math.format('hello')            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\n\n\nexports.format = function (value, options) {\n  if (typeof value === 'number') {\n    return formatNumber(value, options);\n  }\n\n  if (isBigNumber(value)) {\n    return formatBigNumber(value, options);\n  } // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n\n\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return value.s * value.n + '/' + value.d;\n    } else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if (exports.isString(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && _typeof(value) === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    } else if (value && value.toString() !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString();\n    } else {\n      var entries = [];\n\n      for (var key in value) {\n        if (value.hasOwnProperty(key)) {\n          entries.push('\"' + key + '\": ' + exports.format(value[key], options));\n        }\n      }\n\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n};\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\n\n\nexports.stringify = function (value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n      c = text.charAt(i);\n\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\'; // no valid escape character -> escape it\n      }\n\n      escaped += c;\n    } else if (c === '\"') {\n      escaped += '\\\\\"';\n    } else {\n      escaped += c;\n    }\n\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n};\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\n\n\nexports.escape = function (value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return text;\n};\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\n\n\nfunction formatArray(array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n\n    for (var i = 0; i < len; i++) {\n      if (i !== 0) {\n        str += ', ';\n      }\n\n      str += formatArray(array[i], options);\n    }\n\n    str += ']';\n    return str;\n  } else {\n    return exports.format(array, options);\n  }\n}\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction looksLikeFraction(value) {\n  return value && _typeof(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\n}"],"sourceRoot":""}