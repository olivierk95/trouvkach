{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/partitionSelect.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/range.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/reshape.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/matrix/resize.js"],"names":["isInteger","__webpack_require__","exports","name","factory","type","config","load","typed","isNumeric","isNaN","asc","desc","a","b","Array | Matrix, number","x","k","_partitionSelect","Array | Matrix, number, string","compare","Error","Array | Matrix, number, function","isMatrix","size","length","quickSelect","valueOf","Array","isArray","arr","i","from","to","r","w","pivot","Math","floor","random","tmp","matrix","ZERO","BigNumber","ONE","range","string","_strRange","string, boolean","number, number","start","end","_out","_rangeEx","number, number, number","step","number, number, boolean","includeEnd","_rangeInc","number, number, number, boolean","BigNumber, BigNumber","_bigRangeEx","BigNumber, BigNumber, BigNumber","BigNumber, BigNumber, boolean","_bigRangeInc","BigNumber, BigNumber, BigNumber, boolean","toTex","undefined","str","nums","split","map","arg","Number","some","num","_parse","SyntaxError","number","array","push","gt","lt","plus","lte","gte","reshape","Matrix, Array","sizes","Array, Array","forEach","TypeError","DimensionError","ArgumentsError","format","clone","resize","defaultValue","arguments","isBigNumber","value","toNumber","defaultChar","len","substring","res","ii","_resizeString","asMatrix"],"mappings":"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","file":"js/d08872119403de8400a9.js","sourcesContent":["'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type, config, load, typed) {\n  var isNumeric = load(require('../utils/isNumeric'));\n  var isNaN = load(require('../utils/isNaN'));\n  var asc = load(require('../relational/compare'));\n\n  function desc(a, b) {\n    return -asc(a, b);\n  }\n  /**\n   * Partition-based selection of an array or 1D matrix.\n   * Will find the kth smallest value, and mutates the input array.\n   * Uses Quickselect.\n   *\n   * Syntax:\n   *\n   *    math.partitionSelect(x, k)\n   *    math.partitionSelect(x, k, compare)\n   *\n   * Examples:\n   *\n   *    math.partitionSelect([5, 10, 1], 2)           // returns 10\n   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1) // returns 'B'\n   *\n   *    function sortByLength (a, b) {\n   *      return a.length - b.length\n   *    }\n   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'\n   *\n   * See also:\n   *\n   *    sort\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to sort\n   * @param {Number} k            The kth smallest value to be retrieved zero-based index\n   * @param {Function | 'asc' | 'desc'} [compare='asc']\n   *        An optional comparator function. The function is called as\n   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,\n   *        and 0 when a == b.\n   * @return {*} Returns the kth lowest value.\n   */\n\n\n  return typed('partitionSelect', {\n    'Array | Matrix, number': function ArrayMatrixNumber(x, k) {\n      return _partitionSelect(x, k, asc);\n    },\n    'Array | Matrix, number, string': function ArrayMatrixNumberString(x, k, compare) {\n      if (compare === 'asc') {\n        return _partitionSelect(x, k, asc);\n      } else if (compare === 'desc') {\n        return _partitionSelect(x, k, desc);\n      } else {\n        throw new Error('Compare string must be \"asc\" or \"desc\"');\n      }\n    },\n    'Array | Matrix, number, function': _partitionSelect\n  });\n\n  function _partitionSelect(x, k, compare) {\n    if (!isInteger(k) || k < 0) {\n      throw new Error('k must be a non-negative integer');\n    }\n\n    if (type.isMatrix(x)) {\n      var size = x.size();\n\n      if (size.length > 1) {\n        throw new Error('Only one dimensional matrices supported');\n      }\n\n      return quickSelect(x.valueOf(), k, compare);\n    }\n\n    if (Array.isArray(x)) {\n      return quickSelect(x, k, compare);\n    }\n  }\n  /**\n   * Quickselect algorithm.\n   * Code adapted from:\n   * http://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html\n   *\n   * @param {Array} arr\n   * @param {Number} k\n   * @param {Function} compare\n   * @private\n   */\n\n\n  function quickSelect(arr, k, compare) {\n    if (k >= arr.length) {\n      throw new Error('k out of bounds');\n    } // check for NaN values since these can cause an infinite while loop\n\n\n    for (var i = 0; i < arr.length; i++) {\n      if (isNumeric(arr[i]) && isNaN(arr[i])) {\n        return arr[i]; // return NaN\n      }\n    }\n\n    var from = 0;\n    var to = arr.length - 1; // if from == to we reached the kth element\n\n    while (from < to) {\n      var r = from;\n      var w = to;\n      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from]; // stop if the reader and writer meets\n\n      while (r < w) {\n        // arr[r] >= pivot\n        if (compare(arr[r], pivot) >= 0) {\n          // put the large values at the end\n          var tmp = arr[w];\n          arr[w] = arr[r];\n          arr[r] = tmp;\n          --w;\n        } else {\n          // the value is smaller than the pivot, skip\n          ++r;\n        }\n      } // if we stepped up (r++) we need to step one down (arr[r] > pivot)\n\n\n      if (compare(arr[r], pivot) > 0) {\n        --r;\n      } // the r pointer is on the end of the first k elements\n\n\n      if (k <= r) {\n        to = r;\n      } else {\n        from = r + 1;\n      }\n    }\n\n    return arr[k];\n  }\n}\n\nexports.name = 'partitionSelect';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var ZERO = new type.BigNumber(0);\n  var ONE = new type.BigNumber(1);\n  /**\n   * Create an array from a range.\n   * By default, the range end is excluded. This can be customized by providing\n   * an extra parameter `includeEnd`.\n   *\n   * Syntax:\n   *\n   *     math.range(str [, includeEnd])               // Create a range from a string,\n   *                                                  // where the string contains the\n   *                                                  // start, optional step, and end,\n   *                                                  // separated by a colon.\n   *     math.range(start, end [, includeEnd])        // Create a range with start and\n   *                                                  // end and a step size of 1.\n   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,\n   *                                                  // and end.\n   *\n   * Where:\n   *\n   * - `str: string`\n   *   A string 'start:end' or 'start:step:end'\n   * - `start: {number | BigNumber}`\n   *   Start of the range\n   * - `end: number | BigNumber`\n   *   End of the range, excluded by default, included when parameter includeEnd=true\n   * - `step: number | BigNumber`\n   *   Step size. Default value is 1.\n   * - `includeEnd: boolean`\n   *   Option to specify whether to include the end or not. False by default.\n   *\n   * Examples:\n   *\n   *     math.range(2, 6)        // [2, 3, 4, 5]\n   *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]\n   *     math.range('2:1:6')     // [2, 3, 4, 5]\n   *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]\n   *\n   * See also:\n   *\n   *     ones, zeros, size, subset\n   *\n   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.\n   * @return {Array | Matrix} range\n   */\n\n  var range = typed('range', {\n    // TODO: simplify signatures when typed-function supports default values and optional arguments\n    // TODO: a number or boolean should not be converted to string here\n    'string': _strRange,\n    'string, boolean': _strRange,\n    'number, number': function numberNumber(start, end) {\n      return _out(_rangeEx(start, end, 1));\n    },\n    'number, number, number': function numberNumberNumber(start, end, step) {\n      return _out(_rangeEx(start, end, step));\n    },\n    'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {\n      return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));\n    },\n    'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {\n      return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));\n    },\n    'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {\n      return _out(_bigRangeEx(start, end, ONE));\n    },\n    'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {\n      return _out(_bigRangeEx(start, end, step));\n    },\n    'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {\n      return includeEnd ? _out(_bigRangeInc(start, end, ONE)) : _out(_bigRangeEx(start, end, ONE));\n    },\n    'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {\n      return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));\n    }\n  });\n  range.toTex = undefined; // use default template\n\n  return range;\n\n  function _out(arr) {\n    return config.matrix === 'Array' ? arr : matrix(arr);\n  }\n\n  function _strRange(str, includeEnd) {\n    var r = _parse(str);\n\n    if (!r) {\n      throw new SyntaxError('String \"' + str + '\" is no valid range');\n    }\n\n    var fn;\n\n    if (config.number === 'BigNumber') {\n      fn = includeEnd ? _bigRangeInc : _bigRangeEx;\n      return _out(fn(new type.BigNumber(r.start), new type.BigNumber(r.end), new type.BigNumber(r.step)));\n    } else {\n      fn = includeEnd ? _rangeInc : _rangeEx;\n      return _out(fn(r.start, r.end, r.step));\n    }\n  }\n  /**\n   * Create a range with numbers. End is excluded\n   * @param {number} start\n   * @param {number} end\n   * @param {number} step\n   * @returns {Array} range\n   * @private\n   */\n\n\n  function _rangeEx(start, end, step) {\n    var array = [];\n    var x = start;\n\n    if (step > 0) {\n      while (x < end) {\n        array.push(x);\n        x += step;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        array.push(x);\n        x += step;\n      }\n    }\n\n    return array;\n  }\n  /**\n   * Create a range with numbers. End is included\n   * @param {number} start\n   * @param {number} end\n   * @param {number} step\n   * @returns {Array} range\n   * @private\n   */\n\n\n  function _rangeInc(start, end, step) {\n    var array = [];\n    var x = start;\n\n    if (step > 0) {\n      while (x <= end) {\n        array.push(x);\n        x += step;\n      }\n    } else if (step < 0) {\n      while (x >= end) {\n        array.push(x);\n        x += step;\n      }\n    }\n\n    return array;\n  }\n  /**\n   * Create a range with big numbers. End is excluded\n   * @param {BigNumber} start\n   * @param {BigNumber} end\n   * @param {BigNumber} step\n   * @returns {Array} range\n   * @private\n   */\n\n\n  function _bigRangeEx(start, end, step) {\n    var array = [];\n    var x = start;\n\n    if (step.gt(ZERO)) {\n      while (x.lt(end)) {\n        array.push(x);\n        x = x.plus(step);\n      }\n    } else if (step.lt(ZERO)) {\n      while (x.gt(end)) {\n        array.push(x);\n        x = x.plus(step);\n      }\n    }\n\n    return array;\n  }\n  /**\n   * Create a range with big numbers. End is included\n   * @param {BigNumber} start\n   * @param {BigNumber} end\n   * @param {BigNumber} step\n   * @returns {Array} range\n   * @private\n   */\n\n\n  function _bigRangeInc(start, end, step) {\n    var array = [];\n    var x = start;\n\n    if (step.gt(ZERO)) {\n      while (x.lte(end)) {\n        array.push(x);\n        x = x.plus(step);\n      }\n    } else if (step.lt(ZERO)) {\n      while (x.gte(end)) {\n        array.push(x);\n        x = x.plus(step);\n      }\n    }\n\n    return array;\n  }\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @param {string} str\n   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step\n   * @private\n   */\n\n\n  function _parse(str) {\n    var args = str.split(':'); // number\n\n    var nums = args.map(function (arg) {\n      // use Number and not parseFloat as Number returns NaN on invalid garbage in the string\n      return Number(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return {\n          start: nums[0],\n          end: nums[1],\n          step: 1\n        };\n\n      case 3:\n        return {\n          start: nums[0],\n          end: nums[2],\n          step: nums[1]\n        };\n\n      default:\n        return null;\n    }\n  }\n}\n\nexports.name = 'range';\nexports.factory = factory;","'use strict';\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var isInteger = load(require('../utils/isInteger'));\n  /**\n   * Reshape a multi dimensional array to fit the specified dimensions\n   *\n   * Syntax:\n   *\n   *     math.reshape(x, sizes)\n   *\n   * Examples:\n   *\n   *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])\n   *     // returns Array  [[1, 2, 3], [4, 5, 6]]\n   *\n   *     math.reshape([[1, 2], [3, 4]], [1, 4])\n   *     // returns Array  [[1, 2, 3, 4]]\n   *\n   *     math.reshape([[1, 2], [3, 4]], [4])\n   *     // returns Array [1, 2, 3, 4]\n   *\n   *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])\n   *     math.reshape(x, [2, 2, 2])\n   *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n   *\n   * See also:\n   *\n   *     size, squeeze, resize\n   *\n   * @param {Array | Matrix | *} x  Matrix to be reshaped\n   * @param {number[]} sizes        One dimensional array with integral sizes for\n   *                                each dimension\n   *\n   * @return {* | Array | Matrix}   A reshaped clone of matrix `x`\n   *\n   * @throws {TypeError}            If `sizes` does not contain solely integers\n   * @throws {DimensionError}       If the product of the new dimension sizes does\n   *                                not equal that of the old ones\n   */\n\n  var reshape = typed('reshape', {\n    'Matrix, Array': function MatrixArray(x, sizes) {\n      if (x.reshape) {\n        return x.reshape(sizes);\n      } else {\n        return matrix(array.reshape(x.valueOf(), sizes));\n      }\n    },\n    'Array, Array': function ArrayArray(x, sizes) {\n      sizes.forEach(function (size) {\n        if (!isInteger(size)) {\n          throw new TypeError('Invalid size for dimension: ' + size);\n        }\n      });\n      return array.reshape(x, sizes);\n    }\n  });\n  reshape.toTex = undefined; // use default template\n\n  return reshape;\n}\n\nexports.name = 'reshape';\nexports.factory = factory;","'use strict';\n\nvar DimensionError = require('../../error/DimensionError');\n\nvar ArgumentsError = require('../../error/ArgumentsError');\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar format = require('../../utils/string').format;\n\nvar clone = require('../../utils/object').clone;\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Resize a matrix\n   *\n   * Syntax:\n   *\n   *     math.resize(x, size)\n   *     math.resize(x, size, defaultValue)\n   *\n   * Examples:\n   *\n   *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]\n   *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]\n   *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]\n   *     math.resize(\"hello\", [8], \"!\")    // returns string 'hello!!!'\n   *\n   * See also:\n   *\n   *     size, squeeze, subset, reshape\n   *\n   * @param {Array | Matrix | *} x             Matrix to be resized\n   * @param {Array | Matrix} size              One dimensional array with numbers\n   * @param {number | string} [defaultValue=0] Zero by default, except in\n   *                                           case of a string, in that case\n   *                                           defaultValue = ' '\n   * @return {* | Array | Matrix} A resized clone of matrix `x`\n   */\n  // TODO: rework resize to a typed-function\n\n  var resize = function resize(x, size, defaultValue) {\n    if (arguments.length !== 2 && arguments.length !== 3) {\n      throw new ArgumentsError('resize', arguments.length, 2, 3);\n    }\n\n    if (type.isMatrix(size)) {\n      size = size.valueOf(); // get Array\n    }\n\n    if (type.isBigNumber(size[0])) {\n      // convert bignumbers to numbers\n      size = size.map(function (value) {\n        return type.isBigNumber(value) ? value.toNumber() : value;\n      });\n    } // check x is a Matrix\n\n\n    if (type.isMatrix(x)) {\n      // use optimized matrix implementation, return copy\n      return x.resize(size, defaultValue, true);\n    }\n\n    if (typeof x === 'string') {\n      // resize string\n      return _resizeString(x, size, defaultValue);\n    } // check result should be a matrix\n\n\n    var asMatrix = Array.isArray(x) ? false : config.matrix !== 'Array';\n\n    if (size.length === 0) {\n      // output a scalar\n      while (Array.isArray(x)) {\n        x = x[0];\n      }\n\n      return clone(x);\n    } else {\n      // output an array/matrix\n      if (!Array.isArray(x)) {\n        x = [x];\n      }\n\n      x = clone(x);\n      var res = array.resize(x, size, defaultValue);\n      return asMatrix ? matrix(res) : res;\n    }\n  };\n\n  resize.toTex = undefined; // use default template\n\n  return resize;\n  /**\n   * Resize a string\n   * @param {string} str\n   * @param {number[]} size\n   * @param {string} [defaultChar=' ']\n   * @private\n   */\n\n  function _resizeString(str, size, defaultChar) {\n    if (defaultChar !== undefined) {\n      if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {\n        throw new TypeError('Single character expected as defaultValue');\n      }\n    } else {\n      defaultChar = ' ';\n    }\n\n    if (size.length !== 1) {\n      throw new DimensionError(size.length, 1);\n    }\n\n    var len = size[0];\n\n    if (typeof len !== 'number' || !isInteger(len)) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n\n    if (str.length > len) {\n      return str.substring(0, len);\n    } else if (str.length < len) {\n      var res = str;\n\n      for (var i = 0, ii = len - str.length; i < ii; i++) {\n        res += defaultChar;\n      }\n\n      return res;\n    } else {\n      return str;\n    }\n  }\n}\n\nexports.name = 'resize';\nexports.factory = factory;"],"sourceRoot":""}