{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/complex.js/complex.js"],"names":["__WEBPACK_AMD_DEFINE_RESULT__","root","cosh","x","Math","exp","sinh","parser_exit","SyntaxError","logHypot","a","b","_a","abs","_b","log","cos","atan2","parse","z","re","im","undefined","Number","isFinite","Complex","sin","length","tokens","match","plus","minus","i","c","isNaN","parseFloat","this","prototype","sign","add","sub","mul","div","t","d","pow","arg","loh","sqrt","r","tmp","expm1","limit","PI","xx","cosm1","y","tan","cot","sec","csc","asin","t1","t2","acos","atan","Infinity","acot","asec","acsc","tanh","coth","csch","sech","asinh","res","acosh","atanh","noIM","oneMinus","onePlus","temp","acoth","acsch","asech","inverse","conjugate","neg","ceil","places","floor","round","equals","clone","toString","ret","toVector","valueOf","isZero","isInfinite","E","NaN","apply","exports","module"],"mappings":"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","file":"js/feead48983ff44b01e0c.js","sourcesContent":["/**\n * @license Complex.js v2.0.11 11/02/2016\n *\n * Copyright (c) 2016, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n\n/**\n *\n * This class allows the manipulation of complex numbers.\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\n *\n * Object form\n * { re: <real>, im: <imaginary> }\n * { arg: <angle>, abs: <radius> }\n * { phi: <angle>, r: <radius> }\n *\n * Array / Vector form\n * [ real, imaginary ]\n *\n * Double form\n * 99.3 - Single double value\n *\n * String form\n * '23.1337' - Simple real number\n * '15+3i' - a simple complex number\n * '3-i' - a simple complex number\n *\n * Example:\n *\n * var c = new Complex('99.3+8i');\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\n *\n */\n\n(function(root) {\n\n  'use strict';\n\n  var cosh = function(x) {\n    return (Math.exp(x) + Math.exp(-x)) * 0.5;\n  };\n\n  var sinh = function(x) {\n    return (Math.exp(x) - Math.exp(-x)) * 0.5;\n  };\n\n  /**\n   * Calculates cos(x) - 1 using Taylor series if x is small.\n   *\n   * @param {number} x\n   * @returns {number} cos(x) - 1\n   */\n\n  var cosm1 = function(x) {\n    var limit = Math.PI/4;\n    if (x < -limit || x > limit) {\n      return (Math.cos(x) - 1.0);\n    }\n\n    var xx = x * x;\n    return xx *\n      (-0.5 + xx *\n        (1/24 + xx *\n          (-1/720 + xx *\n            (1/40320 + xx *\n              (-1/3628800 + xx *\n                (1/4790014600 + xx *\n                  (-1/87178291200 + xx *\n                    (1/20922789888000)\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n  };\n\n  var hypot = function(x, y) {\n\n    var a = Math.abs(x);\n    var b = Math.abs(y);\n\n    if (a < 3000 && b < 3000) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    if (a < b) {\n      a = b;\n      b = x / y;\n    } else {\n      b = y / x;\n    }\n    return a * Math.sqrt(1 + b * b);\n  };\n\n  var parser_exit = function() {\n    throw SyntaxError('Invalid Param');\n  };\n\n  /**\n   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\n   *\n   * @param {number} a\n   * @param {number} b\n   * @returns {number}\n   */\n  function logHypot(a, b) {\n\n    var _a = Math.abs(a);\n    var _b = Math.abs(b);\n\n    if (a === 0) {\n      return Math.log(_b);\n    }\n\n    if (b === 0) {\n      return Math.log(_a);\n    }\n\n    if (_a < 3000 && _b < 3000) {\n      return Math.log(a * a + b * b) * 0.5;\n    }\n\n    /* I got 4 ideas to compute this property without overflow:\n     *\n     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\n     *\n     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\n\n     Math.log(a * a + b * b) / 2\n\n     *\n     *\n     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\n\n     var fn = function(a, b) {\n     a = Math.abs(a);\n     b = Math.abs(b);\n     var t = Math.min(a, b);\n     a = Math.max(a, b);\n     t = t / a;\n\n     return Math.log(a) + Math.log(1 + t * t) / 2;\n     };\n\n     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\n\n     Math.log(a / Math.cos(Math.atan2(b, a)))\n\n     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\n\n     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\n\n     */\n\n    return Math.log(a / Math.cos(Math.atan2(b, a)));\n  }\n\n  var parse = function(a, b) {\n\n    var z = {'re': 0, 'im': 0};\n\n    if (a === undefined || a === null) {\n      z['re'] =\n              z['im'] = 0;\n    } else if (b !== undefined) {\n      z['re'] = a;\n      z['im'] = b;\n    } else\n      switch (typeof a) {\n\n        case 'object':\n\n          if ('im' in a && 're' in a) {\n            z['re'] = a['re'];\n            z['im'] = a['im'];\n          } else if ('abs' in a && 'arg' in a) {\n            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {\n              return Complex['INFINITY'];\n            }\n            z['re'] = a['abs'] * Math.cos(a['arg']);\n            z['im'] = a['abs'] * Math.sin(a['arg']);\n          } else if ('r' in a && 'phi' in a) {\n            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {\n              return Complex['INFINITY'];\n            }\n            z['re'] = a['r'] * Math.cos(a['phi']);\n            z['im'] = a['r'] * Math.sin(a['phi']);\n          } else if (a.length === 2) { // Quick array check\n            z['re'] = a[0];\n            z['im'] = a[1];\n          } else {\n            parser_exit();\n          }\n          break;\n\n        case 'string':\n\n          z['im'] = /* void */\n                  z['re'] = 0;\n\n          var tokens = a.match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\n          var plus = 1;\n          var minus = 0;\n\n          if (tokens === null) {\n            parser_exit();\n          }\n\n          for (var i = 0; i < tokens.length; i++) {\n\n            var c = tokens[i];\n\n            if (c === ' ' || c === '\\t' || c === '\\n') {\n              /* void */\n            } else if (c === '+') {\n              plus++;\n            } else if (c === '-') {\n              minus++;\n            } else if (c === 'i' || c === 'I') {\n\n              if (plus + minus === 0) {\n                parser_exit();\n              }\n\n              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\n                i++;\n              } else {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\n              }\n              plus = minus = 0;\n\n            } else {\n\n              if (plus + minus === 0 || isNaN(c)) {\n                parser_exit();\n              }\n\n              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\n                i++;\n              } else {\n                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\n              }\n              plus = minus = 0;\n            }\n          }\n\n          // Still something on the stack\n          if (plus + minus > 0) {\n            parser_exit();\n          }\n          break;\n\n        case 'number':\n          z['im'] = 0;\n          z['re'] = a;\n          break;\n\n        default:\n          parser_exit();\n      }\n\n    if (isNaN(z['re']) || isNaN(z['im'])) {\n      // If a calculation is NaN, we treat it as NaN and don't throw\n      //parser_exit();\n    }\n\n    return z;\n  };\n\n  /**\n   * @constructor\n   * @returns {Complex}\n   */\n  function Complex(a, b) {\n\n    if (!(this instanceof Complex)) {\n      return new Complex(a, b);\n    }\n\n    var z = parse(a, b);\n\n    this['re'] = z['re'];\n    this['im'] = z['im'];\n  }\n\n  Complex.prototype = {\n\n    're': 0,\n    'im': 0,\n\n    /**\n     * Calculates the sign of a complex number, which is a normalized complex\n     *\n     * @returns {Complex}\n     */\n    'sign': function() {\n\n      var abs = this['abs']();\n\n      return new Complex(\n              this['re'] / abs,\n              this['im'] / abs);\n    },\n\n    /**\n     * Adds two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'add': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity + Infinity = NaN\n      if (this['isInfinite']() && z['isInfinite']()) {\n        return Complex['NAN'];\n      }\n\n      // Infinity + z = Infinity { where z != Infinity }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      return new Complex(\n              this['re'] + z['re'],\n              this['im'] + z['im']);\n    },\n\n    /**\n     * Subtracts two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'sub': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity - Infinity = NaN\n      if (this['isInfinite']() && z['isInfinite']()) {\n        return Complex['NAN'];\n      }\n\n      // Infinity - z = Infinity { where z != Infinity }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      return new Complex(\n              this['re'] - z['re'],\n              this['im'] - z['im']);\n    },\n\n    /**\n     * Multiplies two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'mul': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity * 0 = NaN\n      if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {\n        return Complex['NAN'];\n      }\n\n      // Infinity * z = Infinity { where z != 0 }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      // Short circuit for real values\n      if (z['im'] === 0 && this['im'] === 0) {\n        return new Complex(this['re'] * z['re'], 0);\n      }\n\n      return new Complex(\n              this['re'] * z['re'] - this['im'] * z['im'],\n              this['re'] * z['im'] + this['im'] * z['re']);\n    },\n\n    /**\n     * Divides two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'div': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // 0 / 0 = NaN and Infinity / Infinity = NaN\n      if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {\n        return Complex['NAN'];\n      }\n\n      // Infinity / 0 = Infinity\n      if (this['isInfinite']() || z['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      // 0 / Infinity = 0\n      if (this['isZero']() || z['isInfinite']()) {\n        return Complex['ZERO'];\n      }\n\n      a = this['re'];\n      b = this['im'];\n\n      var c = z['re'];\n      var d = z['im'];\n      var t, x;\n\n      if (0 === d) {\n        // Divisor is real\n        return new Complex(a / c, b / c);\n      }\n\n      if (Math.abs(c) < Math.abs(d)) {\n\n        x = c / d;\n        t = c * x + d;\n\n        return new Complex(\n                (a * x + b) / t,\n                (b * x - a) / t);\n\n      } else {\n\n        x = d / c;\n        t = d * x + c;\n\n        return new Complex(\n                (a + b * x) / t,\n                (b - a * x) / t);\n      }\n    },\n\n    /**\n     * Calculate the power of two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'pow': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      a = this['re'];\n      b = this['im'];\n\n      if (z['isZero']()) {\n        return Complex['ONE'];\n      }\n\n      // If the exponent is real\n      if (z['im'] === 0) {\n\n        if (b === 0 && a >= 0) {\n\n          return new Complex(Math.pow(a, z['re']), 0);\n\n        } else if (a === 0) { // If base is fully imaginary\n\n          switch ((z['re'] % 4 + 4) % 4) {\n            case 0:\n              return new Complex(Math.pow(b, z['re']), 0);\n            case 1:\n              return new Complex(0, Math.pow(b, z['re']));\n            case 2:\n              return new Complex(-Math.pow(b, z['re']), 0);\n            case 3:\n              return new Complex(0, -Math.pow(b, z['re']));\n          }\n        }\n      }\n\n      /* I couldn't find a good formula, so here is a derivation and optimization\n       *\n       * z_1^z_2 = (a + bi)^(c + di)\n       *         = exp((c + di) * log(a + bi)\n       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\n       * =>...\n       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n       *\n       * =>...\n       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n       *\n       * =>\n       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\n       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\n       *\n       */\n\n      if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {\n        return Complex['ZERO'];\n      }\n\n      var arg = Math.atan2(b, a);\n      var loh = logHypot(a, b);\n\n      a = Math.exp(z['re'] * loh - z['im'] * arg);\n      b = z['im'] * loh + z['re'] * arg;\n      return new Complex(\n              a * Math.cos(b),\n              a * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex square root\n     *\n     * @returns {Complex}\n     */\n    'sqrt': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n      var r = this['abs']();\n\n      var re, im;\n\n      if (a >= 0) {\n\n        if (b === 0) {\n          return new Complex(Math.sqrt(a), 0);\n        }\n\n        re = 0.5 * Math.sqrt(2.0 * (r + a));\n      } else {\n        re = Math.abs(b) / Math.sqrt(2 * (r - a));\n      }\n\n      if (a <= 0) {\n        im = 0.5 * Math.sqrt(2.0 * (r - a));\n      } else {\n        im = Math.abs(b) / Math.sqrt(2 * (r + a));\n      }\n\n      return new Complex(re, b < 0 ? -im : im);\n    },\n\n    /**\n     * Calculate the complex exponent\n     *\n     * @returns {Complex}\n     */\n    'exp': function() {\n\n      var tmp = Math.exp(this['re']);\n\n      if (this['im'] === 0) {\n        //return new Complex(tmp, 0);\n      }\n      return new Complex(\n              tmp * Math.cos(this['im']),\n              tmp * Math.sin(this['im']));\n    },\n\n    /**\n     * Calculate the complex exponent and subtracts one.\n     *\n     * This may be more accurate than `Complex(x).exp().sub(1)` if\n     * `x` is small.\n     *\n     * @returns {Complex}\n     */\n    'expm1': function() {\n\n      /**\n       * exp(a + i*b) - 1\n       = exp(a) * (cos(b) + j*sin(b)) - 1\n       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\n       */\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n              Math.expm1(a) * Math.cos(b) + cosm1(b),\n              Math.exp(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the natural log\n     *\n     * @returns {Complex}\n     */\n    'log': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0 && a > 0) {\n        //return new Complex(Math.log(a), 0);\n      }\n\n      return new Complex(\n              logHypot(a, b),\n              Math.atan2(b, a));\n    },\n\n    /**\n     * Calculate the magnitude of the complex number\n     *\n     * @returns {number}\n     */\n    'abs': function() {\n\n      return hypot(this['re'], this['im']);\n    },\n\n    /**\n     * Calculate the angle of the complex number\n     *\n     * @returns {number}\n     */\n    'arg': function() {\n\n      return Math.atan2(this['im'], this['re']);\n    },\n\n    /**\n     * Calculate the sine of the complex number\n     *\n     * @returns {Complex}\n     */\n    'sin': function() {\n\n      // sin(c) = (e^b - e^(-b)) / (2i)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n              Math.sin(a) * cosh(b),\n              Math.cos(a) * sinh(b));\n    },\n\n    /**\n     * Calculate the cosine\n     *\n     * @returns {Complex}\n     */\n    'cos': function() {\n\n      // cos(z) = (e^b + e^(-b)) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n              Math.cos(a) * cosh(b),\n              -Math.sin(a) * sinh(b));\n    },\n\n    /**\n     * Calculate the tangent\n     *\n     * @returns {Complex}\n     */\n    'tan': function() {\n\n      // tan(c) = (e^(ci) - e^(-ci)) / (i(e^(ci) + e^(-ci)))\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = Math.cos(a) + cosh(b);\n\n      return new Complex(\n              Math.sin(a) / d,\n              sinh(b) / d);\n    },\n\n    /**\n     * Calculate the cotangent\n     *\n     * @returns {Complex}\n     */\n    'cot': function() {\n\n      // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = Math.cos(a) - cosh(b);\n\n      return new Complex(\n              -Math.sin(a) / d,\n              sinh(b) / d);\n    },\n\n    /**\n     * Calculate the secant\n     *\n     * @returns {Complex}\n     */\n    'sec': function() {\n\n      // sec(c) = 2 / (e^(ci) + e^(-ci))\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\n\n      return new Complex(\n              Math.cos(a) * cosh(b) / d,\n              Math.sin(a) * sinh(b) / d);\n    },\n\n    /**\n     * Calculate the cosecans\n     *\n     * @returns {Complex}\n     */\n    'csc': function() {\n\n      // csc(c) = 2i / (e^(ci) - e^(-ci))\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\n\n      return new Complex(\n              Math.sin(a) * cosh(b) / d,\n              -Math.cos(a) * sinh(b) / d);\n    },\n\n    /**\n     * Calculate the complex arcus sinus\n     *\n     * @returns {Complex}\n     */\n    'asin': function() {\n\n      // asin(c) = -i * log(ci + sqrt(1 - c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var t1 = new Complex(\n              b * b - a * a + 1,\n              -2 * a * b)['sqrt']();\n\n      var t2 = new Complex(\n              t1['re'] - b,\n              t1['im'] + a)['log']();\n\n      return new Complex(t2['im'], -t2['re']);\n    },\n\n    /**\n     * Calculate the complex arcus cosinus\n     *\n     * @returns {Complex}\n     */\n    'acos': function() {\n\n      // acos(c) = i * log(c - i * sqrt(1 - c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var t1 = new Complex(\n              b * b - a * a + 1,\n              -2 * a * b)['sqrt']();\n\n      var t2 = new Complex(\n              t1['re'] - b,\n              t1['im'] + a)['log']();\n\n      return new Complex(Math.PI / 2 - t2['im'], t2['re']);\n    },\n\n    /**\n     * Calculate the complex arcus tangent\n     *\n     * @returns {Complex}\n     */\n    'atan': function() {\n\n      // atan(c) = i / 2 log((i + x) / (i - x))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0) {\n\n        if (b === 1) {\n          return new Complex(0, Infinity);\n        }\n\n        if (b === -1) {\n          return new Complex(0, -Infinity);\n        }\n      }\n\n      var d = a * a + (1.0 - b) * (1.0 - b);\n\n      var t1 = new Complex(\n              (1 - b * b - a * a) / d,\n              -2 * a / d).log();\n\n      return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\n    },\n\n    /**\n     * Calculate the complex arcus cotangent\n     *\n     * @returns {Complex}\n     */\n    'acot': function() {\n\n      // acot(c) = i / 2 log((c - i) / (c + i))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0) {\n        return new Complex(Math.atan2(1, a), 0);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).atan()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).atan();\n    },\n\n    /**\n     * Calculate the complex arcus secant\n     *\n     * @returns {Complex}\n     */\n    'asec': function() {\n\n      // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(0, Infinity);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).acos()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).acos();\n    },\n\n    /**\n     * Calculate the complex arcus cosecans\n     *\n     * @returns {Complex}\n     */\n    'acsc': function() {\n\n      // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(Math.PI / 2, Infinity);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).asin()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).asin();\n    },\n\n    /**\n     * Calculate the complex sinh\n     *\n     * @returns {Complex}\n     */\n    'sinh': function() {\n\n      // sinh(c) = (e^c - e^-c) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n              sinh(a) * Math.cos(b),\n              cosh(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex cosh\n     *\n     * @returns {Complex}\n     */\n    'cosh': function() {\n\n      // cosh(c) = (e^c + e^-c) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n              cosh(a) * Math.cos(b),\n              sinh(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex tanh\n     *\n     * @returns {Complex}\n     */\n    'tanh': function() {\n\n      // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = cosh(a) + Math.cos(b);\n\n      return new Complex(\n              sinh(a) / d,\n              Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex coth\n     *\n     * @returns {Complex}\n     */\n    'coth': function() {\n\n      // coth(c) = (e^c + e^-c) / (e^c - e^-c)\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = cosh(a) - Math.cos(b);\n\n      return new Complex(\n              sinh(a) / d,\n              -Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex coth\n     *\n     * @returns {Complex}\n     */\n    'csch': function() {\n\n      // csch(c) = 2 / (e^c - e^-c)\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = Math.cos(2 * b) - cosh(2 * a);\n\n      return new Complex(\n              -2 * sinh(a) * Math.cos(b) / d,\n              2 * cosh(a) * Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex sech\n     *\n     * @returns {Complex}\n     */\n    'sech': function() {\n\n      // sech(c) = 2 / (e^c + e^-c)\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = Math.cos(2 * b) + cosh(2 * a);\n\n      return new Complex(\n              2 * cosh(a) * Math.cos(b) / d,\n              -2 * sinh(a) * Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex asinh\n     *\n     * @returns {Complex}\n     */\n    'asinh': function() {\n\n      // asinh(c) = log(c + sqrt(c^2 + 1))\n\n      var tmp = this['im'];\n      this['im'] = -this['re'];\n      this['re'] = tmp;\n      var res = this['asin']();\n\n      this['re'] = -this['im'];\n      this['im'] = tmp;\n      tmp = res['re'];\n\n      res['re'] = -res['im'];\n      res['im'] = tmp;\n      return res;\n    },\n\n    /**\n     * Calculate the complex asinh\n     *\n     * @returns {Complex}\n     */\n    'acosh': function() {\n\n      // acosh(c) = log(c + sqrt(c^2 - 1))\n\n      var res = this['acos']();\n      if (res['im'] <= 0) {\n        var tmp = res['re'];\n        res['re'] = -res['im'];\n        res['im'] = tmp;\n      } else {\n        var tmp = res['im'];\n        res['im'] = -res['re'];\n        res['re'] = tmp;\n      }\n      return res;\n    },\n\n    /**\n     * Calculate the complex atanh\n     *\n     * @returns {Complex}\n     */\n    'atanh': function() {\n\n      // atanh(c) = log((1+c) / (1-c)) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var noIM = a > 1 && b === 0;\n      var oneMinus = 1 - a;\n      var onePlus = 1 + a;\n      var d = oneMinus * oneMinus + b * b;\n\n      var x = (d !== 0)\n              ? new Complex(\n                      (onePlus * oneMinus - b * b) / d,\n                      (b * oneMinus + onePlus * b) / d)\n              : new Complex(\n                      (a !== -1) ? (a / 0) : 0,\n                      (b !== 0) ? (b / 0) : 0);\n\n      var temp = x['re'];\n      x['re'] = logHypot(x['re'], x['im']) / 2;\n      x['im'] = Math.atan2(x['im'], temp) / 2;\n      if (noIM) {\n        x['im'] = -x['im'];\n      }\n      return x;\n    },\n\n    /**\n     * Calculate the complex acoth\n     *\n     * @returns {Complex}\n     */\n    'acoth': function() {\n\n      // acoth(c) = log((c+1) / (c-1)) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(0, Math.PI / 2);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).atanh()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).atanh();\n    },\n\n    /**\n     * Calculate the complex acsch\n     *\n     * @returns {Complex}\n     */\n    'acsch': function() {\n\n      // acsch(c) = log((1+sqrt(1+c^2))/c)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0) {\n\n        return new Complex(\n                (a !== 0)\n                ? Math.log(a + Math.sqrt(a * a + 1))\n                : Infinity, 0);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).asinh()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).asinh();\n    },\n\n    /**\n     * Calculate the complex asech\n     *\n     * @returns {Complex}\n     */\n    'asech': function() {\n\n      // asech(c) = log((1+sqrt(1-c^2))/c)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (this['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n              ? new Complex(\n                      a / d,\n                      -b / d).acosh()\n              : new Complex(\n                      (a !== 0) ? a / 0 : 0,\n                      (b !== 0) ? -b / 0 : 0).acosh();\n    },\n\n    /**\n     * Calculate the complex inverse 1/z\n     *\n     * @returns {Complex}\n     */\n    'inverse': function() {\n\n      // 1 / 0 = Infinity and 1 / Infinity = 0\n      if (this['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      if (this['isInfinite']()) {\n        return Complex['ZERO'];\n      }\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var d = a * a + b * b;\n\n      return new Complex(a / d, -b / d);\n    },\n\n    /**\n     * Returns the complex conjugate\n     *\n     * @returns {Complex}\n     */\n    'conjugate': function() {\n\n      return new Complex(this['re'], -this['im']);\n    },\n\n    /**\n     * Gets the negated complex number\n     *\n     * @returns {Complex}\n     */\n    'neg': function() {\n\n      return new Complex(-this['re'], -this['im']);\n    },\n\n    /**\n     * Ceils the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'ceil': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n              Math.ceil(this['re'] * places) / places,\n              Math.ceil(this['im'] * places) / places);\n    },\n\n    /**\n     * Floors the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'floor': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n              Math.floor(this['re'] * places) / places,\n              Math.floor(this['im'] * places) / places);\n    },\n\n    /**\n     * Ceils the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'round': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n              Math.round(this['re'] * places) / places,\n              Math.round(this['im'] * places) / places);\n    },\n\n    /**\n     * Compares two complex numbers\n     *\n     * **Note:** new Complex(Infinity).equals(Infinity) === false\n     *\n     * @returns {boolean}\n     */\n    'equals': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&\n              Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * @returns {Complex}\n     */\n    'clone': function() {\n\n      return new Complex(this['re'], this['im']);\n    },\n\n    /**\n     * Gets a string of the actual complex number\n     *\n     * @returns {string}\n     */\n    'toString': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n      var ret = '';\n\n      if (this['isNaN']()) {\n        return 'NaN';\n      }\n\n      if (this['isZero']()) {\n        return '0';\n      }\n\n      if (this['isInfinite']()) {\n        return 'Infinity';\n      }\n\n      if (a !== 0) {\n        ret += a;\n      }\n\n      if (b !== 0) {\n\n        if (a !== 0) {\n          ret += b < 0 ? ' - ' : ' + ';\n        } else if (b < 0) {\n          ret += '-';\n        }\n\n        b = Math.abs(b);\n\n        if (1 !== b) {\n          ret += b;\n        }\n        ret += 'i';\n      }\n\n      if (!ret)\n        return '0';\n\n      return ret;\n    },\n\n    /**\n     * Returns the actual number as a vector\n     *\n     * @returns {Array}\n     */\n    'toVector': function() {\n\n      return [this['re'], this['im']];\n    },\n\n    /**\n     * Returns the actual real value of the current object\n     *\n     * @returns {number|null}\n     */\n    'valueOf': function() {\n\n      if (this['im'] === 0) {\n        return this['re'];\n      }\n      return null;\n    },\n\n    /**\n     * Determines whether a complex number is not on the Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isNaN': function() {\n      return isNaN(this['re']) || isNaN(this['im']);\n    },\n\n    /**\n     * Determines whether or not a complex number is at the zero pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isZero': function() {\n      return (\n              (this['re'] === 0 || this['re'] === -0) &&\n              (this['im'] === 0 || this['im'] === -0)\n              );\n    },\n\n    /**\n     * Determines whether a complex number is not at the infinity pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isFinite': function() {\n      return isFinite(this['re']) && isFinite(this['im']);\n    },\n\n    /**\n     * Determines whether or not a complex number is at the infinity pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isInfinite': function() {\n      return !(this['isNaN']() || this['isFinite']());\n    }\n  };\n\n  Complex['ZERO'] = new Complex(0, 0);\n  Complex['ONE'] = new Complex(1, 0);\n  Complex['I'] = new Complex(0, 1);\n  Complex['PI'] = new Complex(Math.PI, 0);\n  Complex['E'] = new Complex(Math.E, 0);\n  Complex['INFINITY'] = new Complex(Infinity, Infinity);\n  Complex['NAN'] = new Complex(NaN, NaN);\n  Complex['EPSILON'] = 1e-16;\n\n  if (typeof define === 'function' && define['amd']) {\n    define([], function() {\n      return Complex;\n    });\n  } else if (typeof exports === 'object') {\n    Object.defineProperty(exports, \"__esModule\", {'value': true});\n    Complex['default'] = Complex;\n    Complex['Complex'] = Complex;\n    module['exports'] = Complex;\n  } else {\n    root['Complex'] = Complex;\n  }\n\n})(this);\n"],"sourceRoot":""}