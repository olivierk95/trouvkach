{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/MatrixIndex.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/Matrix.js"],"names":["clone","__webpack_require__","isInteger","exports","name","path","factory","type","Index","ranges","this","SyntaxError","_dimensions","_isScalar","i","ii","arguments","length","arg","isRange","push","Array","isArray","isMatrix","m","_createImmutableMatrix","valueOf","size","TypeError","l","ImmutableDenseMatrix","prototype","isIndex","index","create","apply","d","max","values","range","min","forEach","callback","dimension","dim","isObjectProperty","getObjectProperty","isScalar","toArray","array","toString","strings","JSON","stringify","join","toJSON","mathjs","dimensions","fromJSON","json","isString","string","config","load","typed","Matrix","storage","format","constructor","_storage","Error","datatype","data","subset","replacement","defaultValue","get","set","value","resize","reshape","map","skipZeros","options"],"mappings":"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","file":"js/1ac69e03885f9e0b997d.js","sourcesContent":["'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type) {\n  /**\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\n   *\n   * Usage:\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\n   *\n   * Where each parameter can be any of:\n   *     A number\n   *     A string (containing a name of an object property)\n   *     An instance of Range\n   *     An Array with the Set values\n   *     A Matrix with the Set values\n   *\n   * The parameters start, end, and step must be integer numbers.\n   *\n   * @class Index\n   * @Constructor Index\n   * @param {...*} ranges\n   */\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this._dimensions = [];\n    this._isScalar = true;\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n\n      if (type.isRange(arg)) {\n        this._dimensions.push(arg);\n\n        this._isScalar = false;\n      } else if (Array.isArray(arg) || type.isMatrix(arg)) {\n        // create matrix\n        var m = _createImmutableMatrix(arg.valueOf());\n\n        this._dimensions.push(m); // size\n\n\n        var size = m.size(); // scalar\n\n        if (size.length !== 1 || size[0] !== 1) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      } // TODO: implement support for wildcard '*'\n\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    } // create matrix\n\n\n    return new type.ImmutableDenseMatrix(arg);\n  }\n  /**\n   * Create a clone of the index\n   * @memberof Index\n   * @return {Index} clone\n   */\n\n\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = clone(this._dimensions);\n    index._isScalar = this._isScalar;\n    return index;\n  };\n  /**\n   * Create an index from an array with ranges/numbers\n   * @memberof Index\n   * @param {Array.<Array | number>} ranges\n   * @return {Index} index\n   * @private\n   */\n\n\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n  /**\n   * Retrieve the size of the index, the number of elements for each dimension.\n   * @memberof Index\n   * @returns {number[]} size\n   */\n\n\n  Index.prototype.size = function () {\n    var size = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n\n    return size;\n  };\n  /**\n   * Get the maximum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} max\n   */\n\n\n  Index.prototype.max = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n\n    return values;\n  };\n  /**\n   * Get the minimum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} min\n   */\n\n\n  Index.prototype.min = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n\n    return values;\n  };\n  /**\n   * Loop over each of the ranges of the index\n   * @memberof Index\n   * @param {Function} callback   Called for each range with a Range as first\n   *                              argument, the dimension as second, and the\n   *                              index object as third.\n   */\n\n\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n  /**\n   * Retrieve the dimension for the given index\n   * @memberof Index\n   * @param {Number} dim                  Number of the dimension\n   * @returns {Range | null} range\n   */\n\n\n  Index.prototype.dimension = function (dim) {\n    return this._dimensions[dim] || null;\n  };\n  /**\n   * Test whether this index contains an object property\n   * @returns {boolean} Returns true if the index is an object property\n   */\n\n\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n  /**\n   * Returns the object property name when the Index holds a single object property,\n   * else returns null\n   * @returns {string | null}\n   */\n\n\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n  /**\n   * Test whether this index contains only a single value.\n   *\n   * This is the case when the index is created with only scalar values as ranges,\n   * not for ranges resolving into a single value.\n   * @memberof Index\n   * @return {boolean} isScalar\n   */\n\n\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n  /**\n   * Expand the Index into an array.\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n\n    return array;\n  };\n  /**\n   * Get the primitive value of the Index, a two dimensional array.\n   * Equivalent to Index.toArray().\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.valueOf = Index.prototype.toArray;\n  /**\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\n   * @memberof Index\n   * @returns {String} str\n   */\n\n  Index.prototype.toString = function () {\n    var strings = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n\n    return '[' + strings.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the Index\n   * @memberof Index\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   */\n\n\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n  /**\n   * Instantiate an Index from a JSON object\n   * @memberof Index\n   * @param {Object} json A JSON object structured as:\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   * @return {Index}\n   */\n\n\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n\n  return Index;\n}\n\nexports.name = 'Index';\nexports.path = 'type';\nexports.factory = factory;","'use strict';\n\nvar util = require('../../utils/index');\n\nvar string = util.string;\nvar isString = string.isString;\n\nfunction factory(type, config, load, typed) {\n  /**\n   * @constructor Matrix\n   *\n   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional\n   * array. A matrix can be constructed as:\n   *\n   *     let matrix = math.matrix(data)\n   *\n   * Matrix contains the functions to resize, get and set values, get the size,\n   * clone the matrix and to convert the matrix to a vector, array, or scalar.\n   * Furthermore, one can iterate over the matrix using map and forEach.\n   * The internal Array of the Matrix can be accessed using the function valueOf.\n   *\n   * Example usage:\n   *\n   *     let matrix = math.matrix([[1, 2], [3, 4]])\n   *     matix.size()              // [2, 2]\n   *     matrix.resize([3, 2], 5)\n   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]\n   *     matrix.subset([1,2])       // 3 (indexes are zero-based)\n   *\n   */\n  function Matrix() {\n    if (!(this instanceof Matrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Matrix.prototype.type = 'Matrix';\n  Matrix.prototype.isMatrix = true;\n  /**\n   * Get the Matrix storage constructor for the given format.\n   *\n   * @param {string} format       The Matrix storage format.\n   *\n   * @return {Function}           The Matrix storage constructor.\n   */\n\n  Matrix.storage = function (format) {\n    // check storage format is a string\n    if (!isString(format)) {\n      throw new TypeError('format must be a string value');\n    } // get storage format constructor\n\n\n    var constructor = Matrix._storage[format];\n\n    if (!constructor) {\n      throw new SyntaxError('Unsupported matrix storage format: ' + format);\n    } // return storage constructor\n\n\n    return constructor;\n  }; // a map with all constructors for all storage types\n\n\n  Matrix._storage = {};\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @return {string}           The storage format.\n   */\n\n  Matrix.prototype.storage = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke storage on a Matrix interface');\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @return {string}           The datatype.\n   */\n\n\n  Matrix.prototype.datatype = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke datatype on a Matrix interface');\n  };\n  /**\n   * Create a new Matrix With the type of the current matrix instance\n   * @param {Array | Object} data\n   * @param {string} [datatype]\n   */\n\n\n  Matrix.prototype.create = function (data, datatype) {\n    throw new Error('Cannot invoke create on a Matrix interface');\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  Matrix.prototype.subset = function (index, replacement, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke subset on a Matrix interface');\n  };\n  /**\n   * Get a single element from the matrix.\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  Matrix.prototype.get = function (index) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke get on a Matrix interface');\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {Matrix} self\n   */\n\n\n  Matrix.prototype.set = function (index, value, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke set on a Matrix interface');\n  };\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  Matrix.prototype.resize = function (size, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke resize on a Matrix interface');\n  };\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  Matrix.prototype.reshape = function (size, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke reshape on a Matrix interface');\n  };\n  /**\n   * Create a clone of the matrix\n   * @return {Matrix} clone\n   */\n\n\n  Matrix.prototype.clone = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke clone on a Matrix interface');\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @returns {number[]} size\n   */\n\n\n  Matrix.prototype.size = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke size on a Matrix interface');\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {Matrix} matrix\n   */\n\n\n  Matrix.prototype.map = function (callback, skipZeros) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke map on a Matrix interface');\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  Matrix.prototype.forEach = function (callback) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke forEach on a Matrix interface');\n  };\n  /**\n   * Create an Array with a copy of the data of the Matrix\n   * @returns {Array} array\n   */\n\n\n  Matrix.prototype.toArray = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke toArray on a Matrix interface');\n  };\n  /**\n   * Get the primitive value of the Matrix: a multidimensional array\n   * @returns {Array} array\n   */\n\n\n  Matrix.prototype.valueOf = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke valueOf on a Matrix interface');\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Matrix.prototype.format = function (options) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke format on a Matrix interface');\n  };\n  /**\n   * Get a string representation of the matrix\n   * @returns {string} str\n   */\n\n\n  Matrix.prototype.toString = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke toString on a Matrix interface');\n  }; // exports\n\n\n  return Matrix;\n}\n\nexports.name = 'Matrix';\nexports.path = 'type';\nexports.factory = factory;"],"sourceRoot":""}