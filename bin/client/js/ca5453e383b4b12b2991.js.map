{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm03.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm02.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm01.js"],"names":["DimensionError","__webpack_require__","exports","name","factory","type","config","load","typed","DenseMatrix","denseMatrix","sparseMatrix","callback","inverse","adata","_data","asize","_size","adt","_datatype","bvalues","_values","bindex","_index","bptr","_ptr","bsize","bdt","length","RangeError","Error","dt","rows","columns","zero","cf","convert","find","cdata","z","x","w","j","mark","k0","k1","k","i","y","data","size","datatype","equalScalar","SparseMatrix","eq","cvalues","cindex","cptr","cij","push","values","index","ptr","undefined"],"mappings":"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","file":"js/ca5453e383b4b12b2991.js","sourcesContent":["'use strict';\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var DenseMatrix = type.DenseMatrix;\n  /**\n   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).\n   * Callback function invoked M*N times.\n   *\n   *\n   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0\n   * C(i,j) = ┤\n   *          └  f(Dij, 0)    ; otherwise\n   *\n   *\n   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)\n   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)\n   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)\n   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)\n   *\n   * @return {Matrix}                    DenseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571\n   */\n\n  var algorithm03 = function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {\n    // dense matrix arrays\n    var adata = denseMatrix._data;\n    var asize = denseMatrix._size;\n    var adt = denseMatrix._datatype; // sparse matrix arrays\n\n    var bvalues = sparseMatrix._values;\n    var bindex = sparseMatrix._index;\n    var bptr = sparseMatrix._ptr;\n    var bsize = sparseMatrix._size;\n    var bdt = sparseMatrix._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // sparse matrix cannot be a Pattern matrix\n\n\n    if (!bvalues) {\n      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // datatype\n\n    var dt; // zero value\n\n    var zero = 0; // callback signature to use\n\n    var cf = callback; // process data types\n\n    if (typeof adt === 'string' && adt === bdt) {\n      // datatype\n      dt = adt; // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt); // callback\n\n      cf = typed.find(callback, [dt, dt]);\n    } // result (DenseMatrix)\n\n\n    var cdata = []; // initialize dense matrix\n\n    for (var z = 0; z < rows; z++) {\n      // initialize row\n      cdata[z] = [];\n    } // workspace\n\n\n    var x = []; // marks indicating we have a value in x for a given column\n\n    var w = []; // loop columns in b\n\n    for (var j = 0; j < columns; j++) {\n      // column mark\n      var mark = j + 1; // values in column j\n\n      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {\n        // row\n        var i = bindex[k]; // update workspace\n\n        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);\n        w[i] = mark;\n      } // process workspace\n\n\n      for (var y = 0; y < rows; y++) {\n        // check we have a calculated value for current row\n        if (w[y] === mark) {\n          // use calculated value\n          cdata[y][j] = x[y];\n        } else {\n          // calculate value\n          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);\n        }\n      }\n    } // return dense matrix\n\n\n    return new DenseMatrix({\n      data: cdata,\n      size: [rows, columns],\n      datatype: dt\n    });\n  };\n\n  return algorithm03;\n}\n\nexports.name = 'algorithm03';\nexports.factory = factory;","'use strict';\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var equalScalar = load(require('../../../function/relational/equalScalar'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).\n   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).\n   *\n   *\n   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0\n   * C(i,j) = ┤\n   *          └  0            ; otherwise\n   *\n   *\n   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)\n   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)\n   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)\n   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)\n   *\n   * @return {Matrix}                    SparseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571\n   */\n\n  var algorithm02 = function algorithm02(denseMatrix, sparseMatrix, callback, inverse) {\n    // dense matrix arrays\n    var adata = denseMatrix._data;\n    var asize = denseMatrix._size;\n    var adt = denseMatrix._datatype; // sparse matrix arrays\n\n    var bvalues = sparseMatrix._values;\n    var bindex = sparseMatrix._index;\n    var bptr = sparseMatrix._ptr;\n    var bsize = sparseMatrix._size;\n    var bdt = sparseMatrix._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // sparse matrix cannot be a Pattern matrix\n\n\n    if (!bvalues) {\n      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // datatype\n\n    var dt; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // callback signature to use\n\n    var cf = callback; // process data types\n\n    if (typeof adt === 'string' && adt === bdt) {\n      // datatype\n      dt = adt; // find signature that matches (dt, dt)\n\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt); // callback\n\n      cf = typed.find(callback, [dt, dt]);\n    } // result (SparseMatrix)\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // loop columns in b\n\n    for (var j = 0; j < columns; j++) {\n      // update cptr\n      cptr[j] = cindex.length; // values in column j\n\n      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {\n        // row\n        var i = bindex[k]; // update C(i,j)\n\n        var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // check for nonzero\n\n        if (!eq(cij, zero)) {\n          // push i & v\n          cindex.push(i);\n          cvalues.push(cij);\n        }\n      }\n    } // update cptr\n\n\n    cptr[columns] = cindex.length; // return sparse matrix\n\n    return new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [rows, columns],\n      datatype: dt\n    });\n  };\n\n  return algorithm02;\n}\n\nexports.name = 'algorithm02';\nexports.factory = factory;","'use strict';\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var DenseMatrix = type.DenseMatrix;\n  /**\n   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).\n   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).\n   *\n   *\n   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0\n   * C(i,j) = ┤\n   *          └  Dij          ; otherwise\n   *\n   *\n   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)\n   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)\n   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)\n   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)\n   *\n   * @return {Matrix}                    DenseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571\n   */\n\n  var algorithm01 = function algorithm01(denseMatrix, sparseMatrix, callback, inverse) {\n    // dense matrix arrays\n    var adata = denseMatrix._data;\n    var asize = denseMatrix._size;\n    var adt = denseMatrix._datatype; // sparse matrix arrays\n\n    var bvalues = sparseMatrix._values;\n    var bindex = sparseMatrix._index;\n    var bptr = sparseMatrix._ptr;\n    var bsize = sparseMatrix._size;\n    var bdt = sparseMatrix._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // sparse matrix cannot be a Pattern matrix\n\n\n    if (!bvalues) {\n      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // process data types\n\n    var dt = typeof adt === 'string' && adt === bdt ? adt : undefined; // callback function\n\n    var cf = dt ? typed.find(callback, [dt, dt]) : callback; // vars\n\n    var i, j; // result (DenseMatrix)\n\n    var cdata = []; // initialize c\n\n    for (i = 0; i < rows; i++) {\n      cdata[i] = [];\n    } // workspace\n\n\n    var x = []; // marks indicating we have a value in x for a given column\n\n    var w = []; // loop columns in b\n\n    for (j = 0; j < columns; j++) {\n      // column mark\n      var mark = j + 1; // values in column j\n\n      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {\n        // row\n        i = bindex[k]; // update workspace\n\n        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // mark i as updated\n\n        w[i] = mark;\n      } // loop rows\n\n\n      for (i = 0; i < rows; i++) {\n        // check row is in workspace\n        if (w[i] === mark) {\n          // c[i][j] was already calculated\n          cdata[i][j] = x[i];\n        } else {\n          // item does not exist in S\n          cdata[i][j] = adata[i][j];\n        }\n      }\n    } // return dense matrix\n\n\n    return new DenseMatrix({\n      data: cdata,\n      size: [rows, columns],\n      datatype: dt\n    });\n  };\n\n  return algorithm01;\n}\n\nexports.name = 'algorithm01';\nexports.factory = factory;"],"sourceRoot":""}