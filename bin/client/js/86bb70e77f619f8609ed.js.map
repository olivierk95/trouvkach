{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/expression/parse.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","ArgumentsError","__webpack_require__","deepMap","exports","name","path","factory","type","config","load","typed","numeric","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","FunctionNode","RangeNode","RelationalNode","SymbolNode","parse","expr","options","extraNodes","nodes","parseStart","Array","isArray","Matrix","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS",",","(",")","[","]","{","}","\"","'",";","+","-","*",".*","/","./","%","^",".^","~","!","&","|","^|","=",":","?","==","!=","<",">","<=",">=","<<",">>",">>>","NAMED_DELIMITERS","mod","to","in","and","xor","or","not","CONSTANTS","true","false","null","undefined","NUMERIC_CONSTANTS","currentString","state","expression","substr","index","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","tokenType","token","comment","isWhitespace","nestingLevel","c1","c2","c3","isDigitDot","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","conditionalLevel","node","visible","blocks","parseAssignment","push","parseBlock","createError","args","value","valid","parseLogicalXor","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseConditional","isSymbolNode","isAccessorNode","object","isFunctionNode","fn","forEach","arg","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","c","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","last","parseImplicitMultiplication","parseRule2","isConstantNode","isOperatorNode","op","parseUnary","tokenStates","pop","CustomNode","indexOf","parseAccessors","str","parseDoubleQuotesStringToken","parseSingleQuotesStringToken","array","rows","cols","row","parseRow","items","r","properties","numberStr","number","parseEnd","parseParentheses","parseNumber","parseObject","parseMatrix","parseSingleQuotesString","parseDoubleQuotesString","parseSymbol","parseCustomNodes","parseLeftHandOperators","parsePow","types","JSON","len","col","message","error","SyntaxError","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low"],"mappings":"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","file":"js/86bb70e77f619f8609ed.js","sourcesContent":["'use strict';\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar ArgumentsError = require('../error/ArgumentsError');\n\nvar deepMap = require('../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var numeric = load(require('../type/numeric'));\n  var AccessorNode = load(require('./node/AccessorNode'));\n  var ArrayNode = load(require('./node/ArrayNode'));\n  var AssignmentNode = load(require('./node/AssignmentNode'));\n  var BlockNode = load(require('./node/BlockNode'));\n  var ConditionalNode = load(require('./node/ConditionalNode'));\n  var ConstantNode = load(require('./node/ConstantNode'));\n  var FunctionAssignmentNode = load(require('./node/FunctionAssignmentNode'));\n  var IndexNode = load(require('./node/IndexNode'));\n  var ObjectNode = load(require('./node/ObjectNode'));\n  var OperatorNode = load(require('./node/OperatorNode'));\n  var ParenthesisNode = load(require('./node/ParenthesisNode'));\n  var FunctionNode = load(require('./node/FunctionNode'));\n  var RangeNode = load(require('./node/RangeNode'));\n  var RelationalNode = load(require('./node/RelationalNode'));\n  var SymbolNode = load(require('./node/SymbolNode'));\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.eval().\n   *\n   * Syntax:\n   *\n   *     parse(expr)\n   *     parse(expr, options)\n   *     parse([expr1, expr2, expr3, ...])\n   *     parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node = parse('sqrt(3^2 + 4^2)')\n   *     node.compile(math).eval() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node = parse('a * b') // 12\n   *     const code = node.compile(math)\n   *     code.eval(scope) // 12\n   *     scope.a = 5\n   *     code.eval(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile(math).eval() // 12\n   *\n   * @param {string | string[] | Matrix} expr\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n\n  function parse(expr, options) {\n    if (arguments.length !== 1 && arguments.length !== 2) {\n      throw new ArgumentsError('parse', arguments.length, 1, 2);\n    } // pass extra nodes\n\n\n    var extraNodes = options && options.nodes ? options.nodes : {};\n\n    if (typeof expr === 'string') {\n      // parse a single expression\n      return parseStart(expr, extraNodes);\n    } else if (Array.isArray(expr) || expr instanceof type.Matrix) {\n      // parse an array or matrix with expressions\n      return deepMap(expr, function (elem) {\n        if (typeof elem !== 'string') throw new TypeError('String expected');\n        return parseStart(elem, extraNodes);\n      });\n    } else {\n      // oops\n      throw new TypeError('String or matrix expected');\n    }\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4 // map with all delimiters\n\n  };\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true // map with all named delimiters\n\n  };\n  var NAMED_DELIMITERS = {\n    'mod': true,\n    'to': true,\n    'in': true,\n    'and': true,\n    'xor': true,\n    'or': true,\n    'not': true\n  };\n  var CONSTANTS = {\n    'true': true,\n    'false': false,\n    'null': null,\n    'undefined': undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {State} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {State} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // get number, can have a single dot\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (NAMED_DELIMITERS.hasOwnProperty(state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * http://unicode-table.com/en/\n   * http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * http://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (type.isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (type.isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (type.isFunctionNode(node) && type.isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (type.isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (operators.hasOwnProperty(state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, operators, name, fn, params;\n    node = parseConversion(state);\n    operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (operators.hasOwnProperty(state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, operators, name, fn, params;\n    node = parseRange(state);\n    operators = {\n      'to': 'to',\n      'in': 'to' // alias of 'to'\n\n    };\n\n    while (operators.hasOwnProperty(state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, operators, name, fn, params;\n    node = parseMultiplyDivide(state);\n    operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (operators.hasOwnProperty(state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, operators, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      'mod': 'mod'\n    };\n\n    while (true) {\n      if (operators.hasOwnProperty(state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && type.isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !type.isConstantNode(last) && (!type.isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && type.isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      'not': 'not'\n    };\n\n    if (operators.hasOwnProperty(state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, operators, name, fn, params;\n    node = parseCustomNodes(state);\n    operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (operators.hasOwnProperty(state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && state.extraNodes.hasOwnProperty(state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (CONSTANTS.hasOwnProperty(name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (type.isSymbolNode(node) || type.isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n    return error;\n  }\n\n  return parse;\n}\n\nexports.name = 'parse';\nexports.path = 'expression';\nexports.factory = factory;"],"sourceRoot":""}