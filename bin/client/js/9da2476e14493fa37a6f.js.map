{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/expression/node/ConditionalNode.js"],"names":["operators","__webpack_require__","exports","name","path","factory","type","config","load","typed","Node","mathTypeOf","ConditionalNode","condition","trueExpr","falseExpr","this","SyntaxError","isNode","TypeError","prototype","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","scope","args","context","isBigNumber","isZero","isComplex","re","im","isUnit","value","testCondition","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","getPrecedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex"],"mappings":"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","file":"js/9da2476e14493fa37a6f.js","sourcesContent":["'use strict';\n\nvar operators = require('../operators');\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var mathTypeOf = load(require('../../function/utils/typeof'));\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!type.isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!type.isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!type.isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (type.isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (type.isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (type.isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + mathTypeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}\n\nexports.name = 'ConditionalNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}