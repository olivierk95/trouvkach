{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/Range.js"],"names":["number","__webpack_require__","exports","name","path","factory","type","config","load","typed","Range","start","end","step","this","SyntaxError","hasStart","hasEnd","hasStep","isBigNumber","toNumber","TypeError","parseFloat","prototype","isRange","parse","str","nums","split","map","arg","some","num","isNaN","length","clone","size","len","diff","sign","Math","ceil","min","max","forEach","callback","x","i","array","value","index","obj","toArray","valueOf","format","options","toString","toJSON","mathjs","fromJSON","json"],"mappings":"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","file":"js/9f71a2df577c03473bde.js","sourcesContent":["'use strict';\n\nvar number = require('../../utils/number');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *\n   *     const range = new Range(start, end)\n   *     const range = new Range(start, end, step)\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x)\n   *     })\n   *     range.map(function (x) {\n   *         return math.sin(x)\n   *     })\n   *     range.toArray()\n   *\n   * Example usage:\n   *\n   *     const c = new Range(2, 6)       // 2:1:5\n   *     c.toArray()                     // [2, 3, 4, 5]\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    var hasStart = start !== null && start !== undefined;\n    var hasEnd = end !== null && end !== undefined;\n    var hasStep = step !== null && step !== undefined;\n\n    if (hasStart) {\n      if (type.isBigNumber(start)) {\n        start = start.toNumber();\n      } else if (typeof start !== 'number') {\n        throw new TypeError('Parameter start must be a number');\n      }\n    }\n\n    if (hasEnd) {\n      if (type.isBigNumber(end)) {\n        end = end.toNumber();\n      } else if (typeof end !== 'number') {\n        throw new TypeError('Parameter end must be a number');\n      }\n    }\n\n    if (hasStep) {\n      if (type.isBigNumber(step)) {\n        step = step.toNumber();\n      } else if (typeof step !== 'number') {\n        throw new TypeError('Parameter step must be a number');\n      }\n    }\n\n    this.start = hasStart ? parseFloat(start) : 0;\n    this.end = hasEnd ? parseFloat(end) : 0;\n    this.step = hasStep ? parseFloat(step) : 1;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n\n\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n\n\n  Range.prototype.size = function () {\n    var len = 0;\n    var start = this.start;\n    var step = this.step;\n    var end = this.end;\n    var diff = end - start;\n\n    if (number.sign(step) === number.sign(diff)) {\n      len = Math.ceil(diff / step);\n    } else if (diff === 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n\n    return [len];\n  };\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n\n\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      } else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n\n\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      } else {\n        // negative step\n        return this.start;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n\n\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Range.prototype.format = function (options) {\n    var str = number.format(this.start, options);\n\n    if (this.step !== 1) {\n      str += ':' + number.format(this.step, options);\n    }\n\n    str += ':' + number.format(this.end, options);\n    return str;\n  };\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n\n\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n\n\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n\n\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}\n\nexports.name = 'Range';\nexports.path = 'type';\nexports.factory = factory;"],"sourceRoot":""}