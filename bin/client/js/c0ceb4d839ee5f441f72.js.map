{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/parse.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/parser.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/index.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/compile.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/eval.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/function/help.js"],"names":["exports","name","factory","type","config","load","typed","parse","__webpack_require__","string | Array | Matrix","string | Array | Matrix, Object","math","Parser","","module","deepMap","string","expr","compile","Array | Matrix","entry","eval","string, Object","scope","Array | Matrix, Object","getSafeProperty","docs","any","search","prop","hasOwnProperty","doc","Error","Help"],"mappings":"2FAkDAA,EAAAC,KAAA,QACAD,EAAAE,QAjDA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAmBG,EAAQ,KAyC3B,OAAAF,EAAA,SACAG,0BAAAF,EACAG,kCAAAH,uCCSAP,EAAAC,KAAA,SACAD,EAAAE,QAtDA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAK,GACA,IAAAC,EAAAP,EAAoBG,EAAQ,MA6C5B,OAAAF,EAAA,UACAO,GAAA,WACA,WAAAD,EAAAD,OAOAX,EAAAW,MAAA,oCCvDAG,EAAAd,QAAA,CAAkBQ,EAAQ,KAAcA,EAAQ,KAAWA,EAAQ,KAAWA,EAAQ,KAAYA,EAAQ,wCCA1G,IAAAO,EAAcP,EAAQ,GAmDtBR,EAAAC,KAAA,UACAD,EAAAE,QAlDA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAmBG,EAAQ,KAoC3B,OAAAF,EAAA,WACAU,OAAA,SAAAC,GACA,OAAAV,EAAAU,GAAAC,WAEAC,iBAAA,SAAAF,GACA,OAAAF,EAAAE,EAAA,SAAAG,GACA,OAAAb,EAAAa,GAAAF,kDC7CA,IAAAH,EAAcP,EAAQ,GA2DtBR,EAAAC,KAAA,OACAD,EAAAE,QA1DA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAmBG,EAAQ,KAkC3B,OAAAF,EAAA,WACAU,OAAA,SAAAC,GAEA,OAAAV,EAAAU,GAAAC,UAAAG,KADA,KAGAC,iBAAA,SAAAL,EAAAM,GACA,OAAAhB,EAAAU,GAAAC,UAAAG,KAAAE,IAEAJ,iBAAA,SAAAF,GACA,IAAAM,EAAA,GACA,OAAAR,EAAAE,EAAA,SAAAG,GACA,OAAAb,EAAAa,GAAAF,UAAAG,KAAAE,MAGAC,yBAAA,SAAAP,EAAAM,GACA,OAAAR,EAAAE,EAAA,SAAAG,GACA,OAAAb,EAAAa,GAAAF,UAAAG,KAAAE,2CCrDA,IAAAE,EAAsBjB,EAAQ,IAAqBiB,gBA+DnDzB,EAAAW,MAAA,EAEAX,EAAAC,KAAA,OACAD,EAAAE,QAhEA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAK,GACA,IAAAe,EAAArB,EAAkBG,EAAQ,MAoB1B,OAAAF,EAAA,QACAqB,IAAA,SAAAC,GACA,IAAAC,EACA5B,EAAA2B,EAEA,oBAAAA,EACA,IAAAC,KAAAlB,EAEA,GAAAA,EAAAmB,eAAAD,IAAAD,IAAAjB,EAAAkB,GAAA,CACA5B,EAAA4B,EACA,MAmBA,IAAAE,EAAAN,EAAAC,EAAAzB,GAEA,IAAA8B,EACA,UAAAC,MAAA,8BAAA/B,EAAA,KAGA,WAAAE,EAAA8B,KAAAF","file":"js/c0ceb4d839ee5f441f72.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  var parse = load(require('../parse'));\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.eval().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [http://mathjs.org/docs/expressions/security.html](http://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().eval() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.eval(scope) // 12\n   *     scope.a = 5\n   *     code2.eval(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().eval() // 12\n   *\n   * See also:\n   *\n   *     eval, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n\n  return typed('parse', {\n    'string | Array | Matrix': parse,\n    'string | Array | Matrix, Object': parse\n  });\n}\n\nexports.name = 'parse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var Parser = load(require('../Parser'));\n  /**\n   * Create a parser. The function creates a new `math.expression.Parser` object.\n   *\n   * Syntax:\n   *\n   *    math.parser()\n   *\n   * Examples:\n   *\n   *     const parser = new math.parser()\n   *\n   *     // evaluate expressions\n   *     const a = parser.eval('sqrt(3^2 + 4^2)') // 5\n   *     const b = parser.eval('sqrt(-4)')        // 2i\n   *     const c = parser.eval('2 inch in cm')    // 5.08 cm\n   *     const d = parser.eval('cos(45 deg)')     // 0.7071067811865476\n   *\n   *     // define variables and functions\n   *     parser.eval('x = 7 / 2')                 // 3.5\n   *     parser.eval('x + 3')                     // 6.5\n   *     parser.eval('function f(x, y) = x^y')    // f(x, y)\n   *     parser.eval('f(2, 3)')                   // 8\n   *\n   *     // get and set variables and functions\n   *     const x = parser.get('x')                // 7\n   *     const f = parser.get('f')                // function\n   *     const g = f(3, 2)                        // 9\n   *     parser.set('h', 500)\n   *     const i = parser.eval('h / 2')           // 250\n   *     parser.set('hello', function (name) {\n   *       return 'hello, ' + name + '!'\n   *     })\n   *     parser.eval('hello(\"user\")')           // \"hello, user!\"\n   *\n   *     // clear defined functions and variables\n   *     parser.clear()\n   *\n   * See also:\n   *\n   *    eval, compile, parse\n   *\n   * @return {Parser} Parser\n   */\n\n  return typed('parser', {\n    '': function _() {\n      return new Parser(math);\n    }\n  });\n}\n\nexports.name = 'parser';\nexports.factory = factory;\nexports.math = true; // requires the math namespace as 5th argument","'use strict';\n\nmodule.exports = [require('./compile'), require('./eval'), require('./help'), require('./parse'), require('./parser')];","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var parse = load(require('../parse'));\n  /**\n   * Parse and compile an expression.\n   * Returns a an object with a function `eval([scope])` to evaluate the\n   * compiled expression.\n   *\n   * Syntax:\n   *\n   *     math.compile(expr)                       // returns one node\n   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes\n   *\n   * Examples:\n   *\n   *     const code1 = math.compile('sqrt(3^2 + 4^2)')\n   *     code1.eval() // 5\n   *\n   *     let scope = {a: 3, b: 4}\n   *     const code2 = math.compile('a * b') // 12\n   *     code2.eval(scope) // 12\n   *     scope.a = 5\n   *     code2.eval(scope) // 20\n   *\n   *     const nodes = math.compile(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].eval() // 12\n   *\n   * See also:\n   *\n   *    parse, eval\n   *\n   * @param {string | string[] | Array | Matrix} expr\n   *            The expression to be compiled\n   * @return {{eval: Function} | Array.<{eval: Function}>} code\n   *            An object with the compiled expression\n   * @throws {Error}\n   */\n\n  return typed('compile', {\n    'string': function string(expr) {\n      return parse(expr).compile();\n    },\n    'Array | Matrix': function ArrayMatrix(expr) {\n      return deepMap(expr, function (entry) {\n        return parse(entry).compile();\n      });\n    }\n  });\n}\n\nexports.name = 'compile';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var parse = load(require('../parse'));\n  /**\n   * Evaluate an expression.\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [http://mathjs.org/docs/expressions/security.html](http://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.eval(expr)\n   *     math.eval(expr, scope)\n   *     math.eval([expr1, expr2, expr3, ...])\n   *     math.eval([expr1, expr2, expr3, ...], scope)\n   *\n   * Example:\n   *\n   *     math.eval('(2+3)/4')                // 1.25\n   *     math.eval('sqrt(3^2 + 4^2)')        // 5\n   *     math.eval('sqrt(-4)')               // 2i\n   *     math.eval(['a=3', 'b=4', 'a*b'])    // [3, 4, 12]\n   *\n   *     let scope = {a:3, b:4}\n   *     math.eval('a * b', scope)           // 12\n   *\n   * See also:\n   *\n   *    parse, compile\n   *\n   * @param {string | string[] | Matrix} expr   The expression to be evaluated\n   * @param {Object} [scope]                    Scope to read/write variables\n   * @return {*} The result of the expression\n   * @throws {Error}\n   */\n\n  return typed('compile', {\n    'string': function string(expr) {\n      var scope = {};\n      return parse(expr).compile().eval(scope);\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return parse(expr).compile().eval(scope);\n    },\n    'Array | Matrix': function ArrayMatrix(expr) {\n      var scope = {};\n      return deepMap(expr, function (entry) {\n        return parse(entry).compile().eval(scope);\n      });\n    },\n    'Array | Matrix, Object': function ArrayMatrixObject(expr, scope) {\n      return deepMap(expr, function (entry) {\n        return parse(entry).compile().eval(scope);\n      });\n    }\n  });\n}\n\nexports.name = 'eval';\nexports.factory = factory;","'use strict';\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory(type, config, load, typed, math) {\n  var docs = load(require('../embeddedDocs'));\n  /**\n   * Retrieve help on a function or data type.\n   * Help files are retrieved from the documentation in math.expression.docs.\n   *\n   * Syntax:\n   *\n   *    math.help(search)\n   *\n   * Examples:\n   *\n   *    console.log(math.help('sin').toString())\n   *    console.log(math.help(math.add).toString())\n   *    console.log(math.help(math.add).toJSON())\n   *\n   * @param {Function | string | Object} search   A function or function name\n   *                                              for which to get help\n   * @return {Help} A help object\n   */\n\n  return typed('help', {\n    'any': function any(search) {\n      var prop;\n      var name = search;\n\n      if (typeof search !== 'string') {\n        for (prop in math) {\n          // search in functions and constants\n          if (math.hasOwnProperty(prop) && search === math[prop]) {\n            name = prop;\n            break;\n          }\n        }\n        /* TODO: implement help for data types\n         if (!text) {\n         // search data type\n         for (prop in math.type) {\n         if (math.type.hasOwnProperty(prop)) {\n         if (search === math.type[prop]) {\n         text = prop\n         break\n         }\n         }\n         }\n         }\n         */\n\n      }\n\n      var doc = getSafeProperty(docs, name);\n\n      if (!doc) {\n        throw new Error('No documentation found on \"' + name + '\"');\n      }\n\n      return new type.Help(doc);\n    }\n  });\n}\n\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\n\nexports.name = 'help';\nexports.factory = factory;"],"sourceRoot":""}