{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/index.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/chain/index.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/chain/Chain.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/chain/function/chain.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/complex/index.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/complex/function/complex.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/fraction/index.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/fraction/Fraction.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/complex/Complex.js","webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/type/fraction/function/fraction.js"],"names":["module","exports","__webpack_require__","format","lazy","name","path","factory","type","config","load","typed","math","Chain","value","this","SyntaxError","isChain","createProxy","fn","prototype","chainify","args","i","arguments","length","apply","done","valueOf","toString","toJSON","mathjs","fromJSON","json","arg0","arg1","prop","hasOwnProperty","on","resolver","undefined","createLazyProxy","","any","deepMap","latex","complex","Complex","ZERO","number","x","number, number","re","im","BigNumber, BigNumber","toNumber","clone","string","null","Object","Error","Array | Matrix","toTex","0","1","2","concat","symbols","Fraction","isFraction","n","s","d","_typeof","obj","Symbol","iterator","constructor","isNumber","isComplex","toPolar","r","abs","phi","arg","options","strRe","strIm","precision","epsilon","Math","pow","substring","fromPolar","TypeError","isUnit","hasBase","EPSILON","curr","prev","compare","a","b","fraction","isFinite","isNaN","numerator","denominator","BigNumber"],"mappings":"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","file":"js/1d6e852a1392e7ac3aad.js","sourcesContent":["'use strict';\n\nmodule.exports = [require('./bignumber'), require('./boolean'), require('./chain'), require('./complex'), require('./fraction'), require('./matrix'), require('./number'), require('./numeric'), require('./resultset'), require('./string'), require('./unit')];","'use strict';\n\nmodule.exports = [// type\nrequire('./Chain'), // construction function\nrequire('./function/chain')];","'use strict';\n\nvar format = require('../../utils/string').format;\n\nvar lazy = require('../../utils/object').lazy;\n\nfunction factory(type, config, load, typed, math) {\n  /**\n   * @constructor Chain\n   * Wrap any value in a chain, allowing to perform chained operations on\n   * the value.\n   *\n   * All methods available in the math.js library can be called upon the chain,\n   * and then will be evaluated with the value itself as first argument.\n   * The chain can be closed by executing chain.done(), which will return\n   * the final value.\n   *\n   * The Chain has a number of special functions:\n   * - done()             Finalize the chained operation and return the\n   *                      chain's value.\n   * - valueOf()          The same as done()\n   * - toString()         Returns a string representation of the chain's value.\n   *\n   * @param {*} [value]\n   */\n  function Chain(value) {\n    if (!(this instanceof Chain)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (type.isChain(value)) {\n      this.value = value.value;\n    } else {\n      this.value = value;\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Chain.prototype.type = 'Chain';\n  Chain.prototype.isChain = true;\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method valueOf()\n   * @returns {*} value\n   */\n\n  Chain.prototype.done = function () {\n    return this.value;\n  };\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method done()\n   * @returns {*} value\n   */\n\n\n  Chain.prototype.valueOf = function () {\n    return this.value;\n  };\n  /**\n   * Get a string representation of the value in the chain\n   * @returns {string}\n   */\n\n\n  Chain.prototype.toString = function () {\n    return format(this.value);\n  };\n  /**\n   * Get a JSON representation of the chain\n   * @returns {Object}\n   */\n\n\n  Chain.prototype.toJSON = function () {\n    return {\n      mathjs: 'Chain',\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate a Chain from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\n   *                       where mathjs is optional\n   * @returns {Chain}\n   */\n\n\n  Chain.fromJSON = function (json) {\n    return new Chain(json.value);\n  };\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {Function} fn      The function to be proxied\n   *                           If fn is no function, it is silently ignored.\n   * @private\n   */\n\n\n  function createProxy(name, fn) {\n    if (typeof fn === 'function') {\n      Chain.prototype[name] = chainify(fn);\n    }\n  }\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {function} resolver   The function resolving with the\n   *                              function to be proxied\n   * @private\n   */\n\n\n  function createLazyProxy(name, resolver) {\n    lazy(Chain.prototype, name, function outerResolver() {\n      var fn = resolver();\n\n      if (typeof fn === 'function') {\n        return chainify(fn);\n      }\n\n      return undefined; // if not a function, ignore\n    });\n  }\n  /**\n   * Make a function chainable\n   * @param {function} fn\n   * @return {Function} chain function\n   * @private\n   */\n\n\n  function chainify(fn) {\n    return function () {\n      var args = [this.value]; // `this` will be the context of a Chain instance\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i];\n      }\n\n      return new Chain(fn.apply(fn, args));\n    };\n  }\n  /**\n   * Create a proxy for a single method, or an object with multiple methods.\n   * Example usage:\n   *\n   *   Chain.createProxy('add', function add (x, y) {...})\n   *   Chain.createProxy({\n   *     add:      function add (x, y) {...},\n   *     subtract: function subtract (x, y) {...}\n   *   }\n   *\n   * @param {string | Object} arg0   A name (string), or an object with\n   *                                 functions\n   * @param {*} [arg1]               A function, when arg0 is a name\n   */\n\n\n  Chain.createProxy = function (arg0, arg1) {\n    if (typeof arg0 === 'string') {\n      // createProxy(name, value)\n      createProxy(arg0, arg1);\n    } else {\n      // createProxy(values)\n      for (var prop in arg0) {\n        if (arg0.hasOwnProperty(prop)) {\n          createProxy(prop, arg0[prop]);\n        }\n      }\n    }\n  }; // create proxy for everything that is in math.js\n\n\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\n\n  math.on('import', function (name, resolver, path) {\n    if (path === undefined) {\n      // an imported function (not a data type or something special)\n      createLazyProxy(name, resolver);\n    }\n  });\n  return Chain;\n}\n\nexports.name = 'Chain';\nexports.path = 'type';\nexports.factory = factory;\nexports.math = true; // require providing the math namespace as 5th argument\n\nexports.lazy = false; // we need to register a listener on the import events, so no lazy loading","'use strict';\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Wrap any value in a chain, allowing to perform chained operations on\n   * the value.\n   *\n   * All methods available in the math.js library can be called upon the chain,\n   * and then will be evaluated with the value itself as first argument.\n   * The chain can be closed by executing `chain.done()`, which returns\n   * the final value.\n   *\n   * The chain has a number of special functions:\n   *\n   * - `done()`     Finalize the chain and return the chain's value.\n   * - `valueOf()`  The same as `done()`\n   * - `toString()` Executes `math.format()` onto the chain's value, returning\n   *                a string representation of the value.\n   *\n   * Syntax:\n   *\n   *    math.chain(value)\n   *\n   * Examples:\n   *\n   *     math.chain(3)\n   *         .add(4)\n   *         .subtract(2)\n   *         .done()     // 5\n   *\n   *     math.chain( [[1, 2], [3, 4]] )\n   *         .subset(math.index(0, 0), 8)\n   *         .multiply(3)\n   *         .done()     // [[24, 6], [9, 12]]\n   *\n   * @param {*} [value]   A value of any type on which to start a chained operation.\n   * @return {math.type.Chain} The created chain\n   */\n  return typed('chain', {\n    '': function _() {\n      return new type.Chain();\n    },\n    'any': function any(value) {\n      return new type.Chain(value);\n    }\n  });\n}\n\nexports.name = 'chain';\nexports.factory = factory;","'use strict';\n\nmodule.exports = [// type\nrequire('./Complex'), // construction function\nrequire('./function/complex')];","'use strict';\n\nvar deepMap = require('../../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../../utils/latex');\n  /**\n   * Create a complex value or convert a value to a complex value.\n   *\n   * Syntax:\n   *\n   *     math.complex()                           // creates a complex value with zero\n   *                                              // as real and imaginary part.\n   *     math.complex(re : number, im : string)   // creates a complex value with provided\n   *                                              // values for real and imaginary part.\n   *     math.complex(re : number)                // creates a complex value with provided\n   *                                              // real value and zero imaginary part.\n   *     math.complex(complex : Complex)          // clones the provided complex value.\n   *     math.complex(arg : string)               // parses a string into a complex value.\n   *     math.complex(array : Array)              // converts the elements of the array\n   *                                              // or matrix element wise into a\n   *                                              // complex value.\n   *     math.complex({re: number, im: number})   // creates a complex value with provided\n   *                                              // values for real an imaginary part.\n   *     math.complex({r: number, phi: number})   // creates a complex value with provided\n   *                                              // polar coordinates\n   *\n   * Examples:\n   *\n   *    const a = math.complex(3, -4)     // a = Complex 3 - 4i\n   *    a.re = 5                          // a = Complex 5 - 4i\n   *    const i = a.im                    // Number -4\n   *    const b = math.complex('2 + 6i')  // Complex 2 + 6i\n   *    const c = math.complex()          // Complex 0 + 0i\n   *    const d = math.add(a, b)          // Complex 5 + 2i\n   *\n   * See also:\n   *\n   *    bignumber, boolean, index, matrix, number, string, unit\n   *\n   * @param {* | Array | Matrix} [args]\n   *            Arguments specifying the real and imaginary part of the complex number\n   * @return {Complex | Array | Matrix} Returns a complex value\n   */\n\n\n  var complex = typed('complex', {\n    '': function _() {\n      return type.Complex.ZERO;\n    },\n    'number': function number(x) {\n      return new type.Complex(x, 0);\n    },\n    'number, number': function numberNumber(re, im) {\n      return new type.Complex(re, im);\n    },\n    // TODO: this signature should be redundant\n    'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {\n      return new type.Complex(re.toNumber(), im.toNumber());\n    },\n    'Complex': function Complex(x) {\n      return x.clone();\n    },\n    'string': function string(x) {\n      return type.Complex(x); // for example '2 + 3i'\n    },\n    'null': function _null(x) {\n      return type.Complex(0);\n    },\n    'Object': function Object(x) {\n      if ('re' in x && 'im' in x) {\n        return new type.Complex(x.re, x.im);\n      }\n\n      if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {\n        return new type.Complex(x);\n      }\n\n      throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, complex);\n    }\n  });\n  complex.toTex = {\n    0: '0',\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(\\\\left(${args[0]}\\\\right)+\".concat(latex.symbols['i'], \"\\\\cdot\\\\left(${args[1]}\\\\right)\\\\right)\")\n  };\n  return complex;\n}\n\nexports.name = 'complex';\nexports.factory = factory;","'use strict';\n\nmodule.exports = [// type\nrequire('./Fraction'), // construction function\nrequire('./function/fraction')];","'use strict';\n\nvar Fraction = require('fraction.js');\n/**\n * Attach type information\n */\n\n\nFraction.prototype.type = 'Fraction';\nFraction.prototype.isFraction = true;\n/**\n * Get a JSON representation of a Fraction containing type information\n * @returns {Object} Returns a JSON object structured as:\n *                   `{\"mathjs\": \"Fraction\", \"n\": 3, \"d\": 8}`\n */\n\nFraction.prototype.toJSON = function () {\n  return {\n    mathjs: 'Fraction',\n    n: this.s * this.n,\n    d: this.d\n  };\n};\n/**\n * Instantiate a Fraction from a JSON object\n * @param {Object} json  a JSON object structured as:\n *                       `{\"mathjs\": \"Fraction\", \"n\": 3, \"d\": 8}`\n * @return {BigNumber}\n */\n\n\nFraction.fromJSON = function (json) {\n  return new Fraction(json);\n};\n\nfunction factory(type, config, load, typed) {\n  return Fraction;\n}\n\nexports.name = 'Fraction';\nexports.path = 'type';\nexports.factory = factory;","'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Complex = require('complex.js');\n\nvar format = require('../../utils/number').format;\n\nvar isNumber = require('../../utils/number').isNumber;\n\nfunction factory(type, config, load, typed, math) {\n  /**\n   * Attach type information\n   */\n  Complex.prototype.type = 'Complex';\n  Complex.prototype.isComplex = true;\n  /**\n   * Get a JSON representation of the complex number\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\n   */\n\n  Complex.prototype.toJSON = function () {\n    return {\n      mathjs: 'Complex',\n      re: this.re,\n      im: this.im\n    };\n  };\n  /*\n   * Return the value of the complex number in polar notation\n   * The angle phi will be set in the interval of [-pi, pi].\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\n   */\n\n\n  Complex.prototype.toPolar = function () {\n    return {\n      r: this.abs(),\n      phi: this.arg()\n    };\n  };\n  /**\n   * Get a string representation of the complex number,\n   * with optional formatting options.\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @return {string} str\n   */\n\n\n  Complex.prototype.format = function (options) {\n    var str = '';\n    var im = this.im;\n    var re = this.re;\n    var strRe = format(this.re, options);\n    var strIm = format(this.im, options); // round either re or im when smaller than the configured precision\n\n    var precision = isNumber(options) ? options : options ? options.precision : null;\n\n    if (precision !== null) {\n      var epsilon = Math.pow(10, -precision);\n\n      if (Math.abs(re / im) < epsilon) {\n        re = 0;\n      }\n\n      if (Math.abs(im / re) < epsilon) {\n        im = 0;\n      }\n    }\n\n    if (im === 0) {\n      // real value\n      str = strRe;\n    } else if (re === 0) {\n      // purely complex value\n      if (im === 1) {\n        str = 'i';\n      } else if (im === -1) {\n        str = '-i';\n      } else {\n        str = strIm + 'i';\n      }\n    } else {\n      // complex value\n      if (im < 0) {\n        if (im === -1) {\n          str = strRe + ' - i';\n        } else {\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\n        }\n      } else {\n        if (im === 1) {\n          str = strRe + ' + i';\n        } else {\n          str = strRe + ' + ' + strIm + 'i';\n        }\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Create a complex number from polar coordinates\n   *\n   * Usage:\n   *\n   *     Complex.fromPolar(r: number, phi: number) : Complex\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\n   *\n   * @param {*} args...\n   * @return {Complex}\n   */\n\n\n  Complex.fromPolar = function (args) {\n    switch (arguments.length) {\n      case 1:\n        var arg = arguments[0];\n\n        if (_typeof(arg) === 'object') {\n          return Complex(arg);\n        }\n\n        throw new TypeError('Input has to be an object with r and phi keys.');\n\n      case 2:\n        var r = arguments[0];\n        var phi = arguments[1];\n\n        if (isNumber(r)) {\n          if (type.isUnit(phi) && phi.hasBase('ANGLE')) {\n            // convert unit to a number in radians\n            phi = phi.toNumber('rad');\n          }\n\n          if (isNumber(phi)) {\n            return new Complex({\n              r: r,\n              phi: phi\n            });\n          }\n\n          throw new TypeError('Phi is not a number nor an angle unit.');\n        } else {\n          throw new TypeError('Radius r is not a number.');\n        }\n\n      default:\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\n    }\n  };\n\n  Complex.prototype.valueOf = Complex.prototype.toString;\n  /**\n   * Create a Complex number from a JSON object\n   * @param {Object} json  A JSON Object structured as\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\n   *                       All properties are optional, default values\n   *                       for `re` and `im` are 0.\n   * @return {Complex} Returns a new Complex number\n   */\n\n  Complex.fromJSON = function (json) {\n    return new Complex(json);\n  }; // apply the current epsilon\n\n\n  Complex.EPSILON = config.epsilon; // listen for changed in the configuration, automatically apply changed epsilon\n\n  math.on('config', function (curr, prev) {\n    if (curr.epsilon !== prev.epsilon) {\n      Complex.EPSILON = curr.epsilon;\n    }\n  });\n  /**\n   * Compare two complex numbers, `a` and `b`:\n   *\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\n   * - Returns 1 when the real parts are equal\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\n   * - Returns -1 when the real parts are equal\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\n   * - Returns 0 when both real and imaginary parts are equal.\n   *\n   * @params {Complex} a\n   * @params {Complex} b\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n  Complex.compare = function (a, b) {\n    if (a.re > b.re) {\n      return 1;\n    }\n\n    if (a.re < b.re) {\n      return -1;\n    }\n\n    if (a.im > b.im) {\n      return 1;\n    }\n\n    if (a.im < b.im) {\n      return -1;\n    }\n\n    return 0;\n  };\n\n  return Complex;\n}\n\nexports.name = 'Complex';\nexports.path = 'type';\nexports.factory = factory;\nexports.math = true; // request access to the math namespace","'use strict';\n\nvar deepMap = require('../../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Create a fraction convert a value to a fraction.\n   *\n   * Syntax:\n   *     math.fraction(numerator, denominator)\n   *     math.fraction({n: numerator, d: denominator})\n   *     math.fraction(matrix: Array | Matrix)         Turn all matrix entries\n   *                                                   into fractions\n   *\n   * Examples:\n   *\n   *     math.fraction(1, 3)\n   *     math.fraction('2/3')\n   *     math.fraction({n: 2, d: 3})\n   *     math.fraction([0.2, 0.25, 1.25])\n   *\n   * See also:\n   *\n   *    bignumber, number, string, unit\n   *\n   * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]\n   *            Arguments specifying the numerator and denominator of\n   *            the fraction\n   * @return {Fraction | Array | Matrix} Returns a fraction\n   */\n  var fraction = typed('fraction', {\n    'number': function number(x) {\n      if (!isFinite(x) || isNaN(x)) {\n        throw new Error(x + ' cannot be represented as a fraction');\n      }\n\n      return new type.Fraction(x);\n    },\n    'string': function string(x) {\n      return new type.Fraction(x);\n    },\n    'number, number': function numberNumber(numerator, denominator) {\n      return new type.Fraction(numerator, denominator);\n    },\n    'null': function _null(x) {\n      return new type.Fraction(0);\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.Fraction(x.toString());\n    },\n    'Fraction': function Fraction(x) {\n      return x; // fractions are immutable\n    },\n    'Object': function Object(x) {\n      return new type.Fraction(x);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, fraction);\n    }\n  });\n  return fraction;\n}\n\nexports.name = 'fraction';\nexports.factory = factory;"],"sourceRoot":""}