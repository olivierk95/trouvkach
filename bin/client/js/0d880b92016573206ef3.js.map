{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/FibonacciHeap.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/type/matrix/ImmutableDenseMatrix.js"],"names":["exports","name","path","factory","type","config","load","typed","smaller","__webpack_require__","larger","oneOverLogPhi","Math","log","sqrt","FibonacciHeap","this","SyntaxError","_minimum","_size","_cut","minimum","node","parent","left","right","degree","child","mark","prototype","isFibonacciHeap","insert","key","value","size","clear","isEmpty","extractMinimum","numberOfChildren","x","tempRight","y","arraySize","floor","array","Array","numRoots","d","next","temp","_linkNodes","i","_findMinimumNode","remove","_cascadingCut","_decreaseKey","util","string","object","isArray","isString","DenseMatrix","ImmutableDenseMatrix","data","datatype","Error","isMatrix","matrix","_data","_datatype","_min","_max","min","max","TypeError","types","isImmutableDenseMatrix","subset","index","arguments","length","m","call","set","resize","reshape","clone","toJSON","mathjs","fromJSON","json","swapRows","forEach","v","undefined"],"mappings":"4FAkYAA,EAAAC,KAAA,gBACAD,EAAAE,KAAA,OACAF,EAAAG,QAlYA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAqBG,EAAQ,KAC7BC,EAAAJ,EAAoBG,EAAQ,KAC5BE,EAAA,EAAAC,KAAAC,KAAA,EAAAD,KAAAE,KAAA,OAOA,SAAAC,IACA,KAAAC,gBAAAD,GACA,UAAAE,YAAA,oDAIAD,KAAAE,SAAA,KACAF,KAAAG,MAAA,EA+LA,SAAAC,EAAAC,EAAAC,EAAAC,GAEAD,EAAAE,KAAAC,MAAAH,EAAAG,MACAH,EAAAG,MAAAD,KAAAF,EAAAE,KACAD,EAAAG,SAEAH,EAAAI,QAAAL,IACAC,EAAAI,MAAAL,EAAAG,OAIA,IAAAF,EAAAG,SACAH,EAAAI,MAAA,MAIAL,EAAAE,KAAAH,EACAC,EAAAG,MAAAJ,EAAAI,MACAJ,EAAAI,MAAAH,EACAA,EAAAG,MAAAD,KAAAF,EAEAA,EAAAC,OAAA,KAEAD,EAAAM,MAAA,EA/MAb,EAAAc,UAAAzB,KAAA,gBACAW,EAAAc,UAAAC,iBAAA,EAQAf,EAAAc,UAAAE,OAAA,SAAAC,EAAAC,GAEA,IAAAX,EAAA,CACAU,MACAC,QACAP,OAAA,GAIA,GAAAV,KAAAE,SAAA,CAEA,IAAAG,EAAAL,KAAAE,SAEAI,EAAAE,KAAAH,EACAC,EAAAG,MAAAJ,EAAAI,MACAJ,EAAAI,MAAAH,EACAA,EAAAG,MAAAD,KAAAF,EAEAd,EAAAwB,EAAAX,EAAAW,OAEAhB,KAAAE,SAAAI,QAIAA,EAAAE,KAAAF,EACAA,EAAAG,MAAAH,EAEAN,KAAAE,SAAAI,EAMA,OAFAN,KAAAG,QAEAG,GAQAP,EAAAc,UAAAK,KAAA,WACA,OAAAlB,KAAAG,OAQAJ,EAAAc,UAAAM,MAAA,WACAnB,KAAAE,SAAA,KACAF,KAAAG,MAAA,GAQAJ,EAAAc,UAAAO,QAAA,WACA,WAAApB,KAAAG,OASAJ,EAAAc,UAAAQ,eAAA,WAEA,IAAAf,EAAAN,KAAAE,SAEA,UAAAI,EACA,OAAAA,EAUA,IANA,IAAAD,EAAAL,KAAAE,SAEAoB,EAAAhB,EAAAI,OAEAa,EAAAjB,EAAAK,MAEAW,EAAA,IAEA,IAAAE,EAAAD,EAAAd,MAEAc,EAAAf,KAAAC,MAAAc,EAAAd,MACAc,EAAAd,MAAAD,KAAAe,EAAAf,KAEAe,EAAAf,KAAAH,EACAkB,EAAAd,MAAAJ,EAAAI,MACAJ,EAAAI,MAAAc,EACAA,EAAAd,MAAAD,KAAAe,EAEAA,EAAAhB,OAAA,KACAgB,EAAAC,EACAF,IAsBA,OAlBAhB,EAAAE,KAAAC,MAAAH,EAAAG,MACAH,EAAAG,MAAAD,KAAAF,EAAAE,KAIAH,EAFAC,MAAAG,MAEA,KAqJA,SAAAJ,EAAAa,GAEA,IAkBAO,EAlBAC,EAAA9B,KAAA+B,MAAA/B,KAAAC,IAAAqB,GAAAvB,GAAA,EAEAiC,EAAA,IAAAC,MAAAH,GAEAI,EAAA,EACAP,EAAAlB,EAEA,GAAAkB,EAIA,IAHAO,IACAP,IAAAd,MAEAc,IAAAlB,GACAyB,IACAP,IAAAd,MAOA,KAAAqB,EAAA,IAMA,IAJA,IAAAC,EAAAR,EAAAb,OAEAsB,EAAAT,EAAAd,MAIAgB,EAAAG,EAAAG,IAFA,CASA,GAAArC,EAAA6B,EAAAP,IAAAS,EAAAT,KAAA,CACA,IAAAiB,EAAAR,EACAA,EAAAF,EACAA,EAAAU,EAIAC,EAAAT,EAAAF,GAGAK,EAAAG,GAAA,KACAA,IAIAH,EAAAG,GAAAR,EAEAA,EAAAS,EACAF,IAIAzB,EAAA,KAEA,QAAA8B,EAAA,EAAmBA,EAAAT,EAAeS,KAElCV,EAAAG,EAAAO,MAOA9B,GAEAoB,EAAAjB,KAAAC,MAAAgB,EAAAhB,MACAgB,EAAAhB,MAAAD,KAAAiB,EAAAjB,KAEAiB,EAAAjB,KAAAH,EACAoB,EAAAhB,MAAAJ,EAAAI,MACAJ,EAAAI,MAAAgB,EACAA,EAAAhB,MAAAD,KAAAiB,EAEAjC,EAAAiC,EAAAT,IAAAX,EAAAW,OACAX,EAAAoB,IAGApB,EAAAoB,GAIA,OAAApB,EAxOA+B,CAFA/B,EAAAC,EAAAG,MAEAT,KAAAG,OAIAH,KAAAG,QAEAH,KAAAE,SAAAG,EAEAC,GAWAP,EAAAc,UAAAwB,OAAA,SAAA/B,GAEAN,KAAAE,SAYA,SAAAG,EAAAC,EAAAU,GAEAV,EAAAU,MAEA,IAAAT,EAAAD,EAAAC,OAgBA,OAdAA,GAAAf,EAAAc,EAAAU,IAAAT,EAAAS,OAEAZ,EAAAC,EAAAC,EAAAC,GAsDA,SAAA+B,EAAAjC,EAAAC,GAEA,IAAAC,EAAAD,EAAAC,OAEAA,IAKAD,EAAAM,MAIAR,EAAAC,EAAAC,EAAAC,GAGA+B,EAAA/B,IANAD,EAAAM,MAAA,GA7DA0B,CAAAjC,EAAAE,IAIAf,EAAAc,EAAAU,IAAAX,EAAAW,OACAX,EAAAC,GAIAD,EAhCAkC,CAAAvC,KAAAE,SAAAI,GAAA,GAEAN,KAAAqB,kBAiGA,IAAAa,EAAA,SAAA5B,EAAAC,GAEAD,EAAAE,KAAAC,MAAAH,EAAAG,MACAH,EAAAG,MAAAD,KAAAF,EAAAE,KAEAF,EAAAC,SAEAA,EAAAI,OAKAL,EAAAE,KAAAD,EAAAI,MACAL,EAAAG,MAAAF,EAAAI,MAAAF,MACAF,EAAAI,MAAAF,MAAAH,EACAA,EAAAG,MAAAD,KAAAF,IAPAC,EAAAI,MAAAL,EACAA,EAAAG,MAAAH,EACAA,EAAAE,KAAAF,GASAC,EAAAG,SAEAJ,EAAAM,MAAA,GA8FA,OAAAb,qCC7XA,IAAAyC,EAAW/C,EAAQ,IAEnBgD,EAAAD,EAAAC,OACAC,EAAAF,EAAAE,OACAC,EAAAd,MAAAc,QACAC,EAAAH,EAAAG,SA0OA5D,EAAAC,KAAA,uBACAD,EAAAE,KAAA,OACAF,EAAAG,QA1OA,SAAAC,EAAAC,EAAAC,GACA,IAAAuD,EAAAvD,EAAyBG,EAAQ,KACjCD,EAAAF,EAAqBG,EAAQ,KAE7B,SAAAqD,EAAAC,EAAAC,GACA,KAAAhD,gBAAA8C,GACA,UAAA7C,YAAA,oDAGA,GAAA+C,IAAAJ,EAAAI,GACA,UAAAC,MAAA,qBAAAD,GAGA,GAAA5D,EAAA8D,SAAAH,IAAAJ,EAAAI,GAAA,CAEA,IAAAI,EAAA,IAAAN,EAAAE,EAAAC,GAEAhD,KAAAoD,MAAAD,EAAAC,MACApD,KAAAG,MAAAgD,EAAAhD,MACAH,KAAAqD,UAAAF,EAAAE,UACArD,KAAAsD,KAAA,KACAtD,KAAAuD,KAAA,UACK,GAAAR,GAAAJ,EAAAI,SAAAJ,EAAAI,EAAA7B,MAELlB,KAAAoD,MAAAL,OACA/C,KAAAG,MAAA4C,EAAA7B,KACAlB,KAAAqD,UAAAN,EAAAC,SACAhD,KAAAsD,UAAA,IAAAP,EAAAS,IAAAT,EAAAS,IAAA,KACAxD,KAAAuD,UAAA,IAAAR,EAAAU,IAAAV,EAAAU,IAAA,SACK,IAAAV,EAEL,UAAAW,UAAA,6BAAAlB,EAAAmB,MAAAvE,KAAA2D,GAAA,KAGA/C,KAAAoD,MAAA,GACApD,KAAAG,MAAA,IACAH,KAAAqD,UAAAL,EACAhD,KAAAsD,KAAA,KACAtD,KAAAuD,KAAA,MA+LA,OA3LAT,EAAAjC,UAAA,IAAAgC,EAKAC,EAAAjC,UAAAzB,KAAA,uBACA0D,EAAAjC,UAAA+C,wBAAA,EAeAd,EAAAjC,UAAAgD,OAAA,SAAAC,GACA,OAAAC,UAAAC,QACA,OAEA,IAAAC,EAAApB,EAAAhC,UAAAgD,OAAAK,KAAAlE,KAAA8D,GAEA,OAAA1E,EAAA8D,SAAAe,GAEA,IAAAnB,EAAA,CACAC,KAAAkB,EAAAb,MACAlC,KAAA+C,EAAA9D,MACA6C,SAAAiB,EAAAZ,YAIAY,EAGA,OACA,OACA,UAAAhB,MAAA,4DAEA,QACA,UAAAhD,YAAA,+BAcA6C,EAAAjC,UAAAsD,IAAA,WACA,UAAAlB,MAAA,sDAgBAH,EAAAjC,UAAAuD,OAAA,WACA,UAAAnB,MAAA,yDASAH,EAAAjC,UAAAwD,QAAA,WACA,UAAApB,MAAA,0DAQAH,EAAAjC,UAAAyD,MAAA,WAMA,OALA,IAAAxB,EAAA,CACAC,KAAAL,EAAA4B,MAAAtE,KAAAoD,OACAlC,KAAAwB,EAAA4B,MAAAtE,KAAAG,OACA6C,SAAAhD,KAAAqD,aAUAP,EAAAjC,UAAA0D,OAAA,WACA,OACAC,OAAA,uBACAzB,KAAA/C,KAAAoD,MACAlC,KAAAlB,KAAAG,MACA6C,SAAAhD,KAAAqD,YAYAP,EAAA2B,SAAA,SAAAC,GACA,WAAA5B,EAAA4B,IAYA5B,EAAAjC,UAAA8D,SAAA,WACA,UAAA1B,MAAA,2DAQAH,EAAAjC,UAAA2C,IAAA,WAEA,UAAAxD,KAAAsD,KAAA,CAEA,IAAAW,EAAA,KAEAjE,KAAA4E,QAAA,SAAAC,IACA,OAAAZ,GAAAzE,EAAAqF,EAAAZ,MACAA,EAAAY,KAGA7E,KAAAsD,KAAA,OAAAW,SAAAa,EAGA,OAAA9E,KAAAsD,MAQAR,EAAAjC,UAAA4C,IAAA,WAEA,UAAAzD,KAAAuD,KAAA,CAEA,IAAAU,EAAA,KAEAjE,KAAA4E,QAAA,SAAAC,IACA,OAAAZ,GAAAzE,EAAAyE,EAAAY,MACAZ,EAAAY,KAGA7E,KAAAuD,KAAA,OAAAU,SAAAa,EAGA,OAAA9E,KAAAuD,MAIAT","file":"js/0d880b92016573206ef3.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  var smaller = load(require('../../function/relational/smaller'));\n  var larger = load(require('../../function/relational/larger'));\n  var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);\n  /**\n   * Fibonacci Heap implementation, used interally for Matrix math.\n   * @class FibonacciHeap\n   * @constructor FibonacciHeap\n   */\n\n  function FibonacciHeap() {\n    if (!(this instanceof FibonacciHeap)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // initialize fields\n\n\n    this._minimum = null;\n    this._size = 0;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  FibonacciHeap.prototype.type = 'FibonacciHeap';\n  FibonacciHeap.prototype.isFibonacciHeap = true;\n  /**\n   * Inserts a new data element into the heap. No heap consolidation is\n   * performed at this time, the new node is simply inserted into the root\n   * list of this heap. Running time: O(1) actual.\n   * @memberof FibonacciHeap\n   */\n\n  FibonacciHeap.prototype.insert = function (key, value) {\n    // create node\n    var node = {\n      key: key,\n      value: value,\n      degree: 0 // check we have a node in the minimum\n\n    };\n\n    if (this._minimum) {\n      // minimum node\n      var minimum = this._minimum; // update left & right of node\n\n      node.left = minimum;\n      node.right = minimum.right;\n      minimum.right = node;\n      node.right.left = node; // update minimum node in heap if needed\n\n      if (smaller(key, minimum.key)) {\n        // node has a smaller key, use it as minimum\n        this._minimum = node;\n      }\n    } else {\n      // set left & right\n      node.left = node;\n      node.right = node; // this is the first node\n\n      this._minimum = node;\n    } // increment number of nodes in heap\n\n\n    this._size++; // return node\n\n    return node;\n  };\n  /**\n   * Returns the number of nodes in heap. Running time: O(1) actual.\n   * @memberof FibonacciHeap\n   */\n\n\n  FibonacciHeap.prototype.size = function () {\n    return this._size;\n  };\n  /**\n   * Removes all elements from this heap.\n   * @memberof FibonacciHeap\n   */\n\n\n  FibonacciHeap.prototype.clear = function () {\n    this._minimum = null;\n    this._size = 0;\n  };\n  /**\n   * Returns true if the heap is empty, otherwise false.\n   * @memberof FibonacciHeap\n   */\n\n\n  FibonacciHeap.prototype.isEmpty = function () {\n    return this._size === 0;\n  };\n  /**\n   * Extracts the node with minimum key from heap. Amortized running\n   * time: O(log n).\n   * @memberof FibonacciHeap\n   */\n\n\n  FibonacciHeap.prototype.extractMinimum = function () {\n    // node to remove\n    var node = this._minimum; // check we have a minimum\n\n    if (node === null) {\n      return node;\n    } // current minimum\n\n\n    var minimum = this._minimum; // get number of children\n\n    var numberOfChildren = node.degree; // pointer to the first child\n\n    var x = node.child; // for each child of node do...\n\n    while (numberOfChildren > 0) {\n      // store node in right side\n      var tempRight = x.right; // remove x from child list\n\n      x.left.right = x.right;\n      x.right.left = x.left; // add x to root list of heap\n\n      x.left = minimum;\n      x.right = minimum.right;\n      minimum.right = x;\n      x.right.left = x; // set Parent[x] to null\n\n      x.parent = null;\n      x = tempRight;\n      numberOfChildren--;\n    } // remove node from root list of heap\n\n\n    node.left.right = node.right;\n    node.right.left = node.left; // update minimum\n\n    if (node === node.right) {\n      // empty\n      minimum = null;\n    } else {\n      // update minimum\n      minimum = node.right; // we need to update the pointer to the root with minimum key\n\n      minimum = _findMinimumNode(minimum, this._size);\n    } // decrement size of heap\n\n\n    this._size--; // update minimum\n\n    this._minimum = minimum; // return node\n\n    return node;\n  };\n  /**\n   * Removes a node from the heap given the reference to the node. The trees\n   * in the heap will be consolidated, if necessary. This operation may fail\n   * to remove the correct element if there are nodes with key value -Infinity.\n   * Running time: O(log n) amortized.\n   * @memberof FibonacciHeap\n   */\n\n\n  FibonacciHeap.prototype.remove = function (node) {\n    // decrease key value\n    this._minimum = _decreaseKey(this._minimum, node, -1); // remove the smallest\n\n    this.extractMinimum();\n  };\n  /**\n   * Decreases the key value for a heap node, given the new value to take on.\n   * The structure of the heap may be changed and will not be consolidated.\n   * Running time: O(1) amortized.\n   * @memberof FibonacciHeap\n   */\n\n\n  function _decreaseKey(minimum, node, key) {\n    // set node key\n    node.key = key; // get parent node\n\n    var parent = node.parent;\n\n    if (parent && smaller(node.key, parent.key)) {\n      // remove node from parent\n      _cut(minimum, node, parent); // remove all nodes from parent to the root parent\n\n\n      _cascadingCut(minimum, parent);\n    } // update minimum node if needed\n\n\n    if (smaller(node.key, minimum.key)) {\n      minimum = node;\n    } // return minimum\n\n\n    return minimum;\n  }\n  /**\n   * The reverse of the link operation: removes node from the child list of parent.\n   * This method assumes that min is non-null. Running time: O(1).\n   * @memberof FibonacciHeap\n   */\n\n\n  function _cut(minimum, node, parent) {\n    // remove node from parent children and decrement Degree[parent]\n    node.left.right = node.right;\n    node.right.left = node.left;\n    parent.degree--; // reset y.child if necessary\n\n    if (parent.child === node) {\n      parent.child = node.right;\n    } // remove child if degree is 0\n\n\n    if (parent.degree === 0) {\n      parent.child = null;\n    } // add node to root list of heap\n\n\n    node.left = minimum;\n    node.right = minimum.right;\n    minimum.right = node;\n    node.right.left = node; // set parent[node] to null\n\n    node.parent = null; // set mark[node] to false\n\n    node.mark = false;\n  }\n  /**\n   * Performs a cascading cut operation. This cuts node from its parent and then\n   * does the same for its parent, and so on up the tree.\n   * Running time: O(log n); O(1) excluding the recursion.\n   * @memberof FibonacciHeap\n   */\n\n\n  function _cascadingCut(minimum, node) {\n    // store parent node\n    var parent = node.parent; // if there's a parent...\n\n    if (!parent) {\n      return;\n    } // if node is unmarked, set it marked\n\n\n    if (!node.mark) {\n      node.mark = true;\n    } else {\n      // it's marked, cut it from parent\n      _cut(minimum, node, parent); // cut its parent as well\n\n\n      _cascadingCut(parent);\n    }\n  }\n  /**\n   * Make the first node a child of the second one. Running time: O(1) actual.\n   * @memberof FibonacciHeap\n   */\n\n\n  var _linkNodes = function _linkNodes(node, parent) {\n    // remove node from root list of heap\n    node.left.right = node.right;\n    node.right.left = node.left; // make node a Child of parent\n\n    node.parent = parent;\n\n    if (!parent.child) {\n      parent.child = node;\n      node.right = node;\n      node.left = node;\n    } else {\n      node.left = parent.child;\n      node.right = parent.child.right;\n      parent.child.right = node;\n      node.right.left = node;\n    } // increase degree[parent]\n\n\n    parent.degree++; // set mark[node] false\n\n    node.mark = false;\n  };\n\n  function _findMinimumNode(minimum, size) {\n    // to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree\n    var arraySize = Math.floor(Math.log(size) * oneOverLogPhi) + 1; // create list with initial capacity\n\n    var array = new Array(arraySize); // find the number of root nodes.\n\n    var numRoots = 0;\n    var x = minimum;\n\n    if (x) {\n      numRoots++;\n      x = x.right;\n\n      while (x !== minimum) {\n        numRoots++;\n        x = x.right;\n      }\n    } // vars\n\n\n    var y; // For each node in root list do...\n\n    while (numRoots > 0) {\n      // access this node's degree..\n      var d = x.degree; // get next node\n\n      var next = x.right; // check if there is a node already in array with the same degree\n\n      while (true) {\n        // get node with the same degree is any\n        y = array[d];\n\n        if (!y) {\n          break;\n        } // make one node with the same degree a child of the other, do this based on the key value.\n\n\n        if (larger(x.key, y.key)) {\n          var temp = y;\n          y = x;\n          x = temp;\n        } // make y a child of x\n\n\n        _linkNodes(y, x); // we have handled this degree, go to next one.\n\n\n        array[d] = null;\n        d++;\n      } // save this node for later when we might encounter another of the same degree.\n\n\n      array[d] = x; // move forward through list.\n\n      x = next;\n      numRoots--;\n    } // Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].\n\n\n    minimum = null; // loop nodes in array\n\n    for (var i = 0; i < arraySize; i++) {\n      // get current node\n      y = array[i];\n\n      if (!y) {\n        continue;\n      } // check if we have a linked list\n\n\n      if (minimum) {\n        // First remove node from root list.\n        y.left.right = y.right;\n        y.right.left = y.left; // now add to root list, again.\n\n        y.left = minimum;\n        y.right = minimum.right;\n        minimum.right = y;\n        y.right.left = y; // check if this is a new min.\n\n        if (smaller(y.key, minimum.key)) {\n          minimum = y;\n        }\n      } else {\n        minimum = y;\n      }\n    }\n\n    return minimum;\n  }\n\n  return FibonacciHeap;\n}\n\nexports.name = 'FibonacciHeap';\nexports.path = 'type';\nexports.factory = factory;","'use strict';\n\nvar util = require('../../utils/index');\n\nvar string = util.string;\nvar object = util.object;\nvar isArray = Array.isArray;\nvar isString = string.isString;\n\nfunction factory(type, config, load) {\n  var DenseMatrix = load(require('./DenseMatrix'));\n  var smaller = load(require('../../function/relational/smaller'));\n\n  function ImmutableDenseMatrix(data, datatype) {\n    if (!(this instanceof ImmutableDenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (type.isMatrix(data) || isArray(data)) {\n      // use DenseMatrix implementation\n      var matrix = new DenseMatrix(data, datatype); // internal structures\n\n      this._data = matrix._data;\n      this._size = matrix._size;\n      this._datatype = matrix._datatype;\n      this._min = null;\n      this._max = null;\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size;\n      this._datatype = data.datatype;\n      this._min = typeof data.min !== 'undefined' ? data.min : null;\n      this._max = typeof data.max !== 'undefined' ? data.max : null;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n      this._min = null;\n      this._max = null;\n    }\n  }\n\n  ImmutableDenseMatrix.prototype = new DenseMatrix();\n  /**\n   * Attach type information\n   */\n\n  ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';\n  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @param {Index} index\n   * @param {Array | ImmutableDenseMatrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n  ImmutableDenseMatrix.prototype.subset = function (index) {\n    switch (arguments.length) {\n      case 1:\n        // use base implementation\n        var m = DenseMatrix.prototype.subset.call(this, index); // check result is a matrix\n\n        if (type.isMatrix(m)) {\n          // return immutable matrix\n          return new ImmutableDenseMatrix({\n            data: m._data,\n            size: m._size,\n            datatype: m._datatype\n          });\n        }\n\n        return m;\n      // intentional fall through\n\n      case 2:\n      case 3:\n        throw new Error('Cannot invoke set subset on an Immutable Matrix instance');\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @param {Number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {ImmutableDenseMatrix} self\n   */\n\n\n  ImmutableDenseMatrix.prototype.set = function () {\n    throw new Error('Cannot invoke set on an Immutable Matrix instance');\n  };\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @param {Number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  ImmutableDenseMatrix.prototype.resize = function () {\n    throw new Error('Cannot invoke resize on an Immutable Matrix instance');\n  };\n  /**\n   * Disallows reshaping in favor of immutability.\n   *\n   * @throws {Error} Operation not allowed\n   */\n\n\n  ImmutableDenseMatrix.prototype.reshape = function () {\n    throw new Error('Cannot invoke reshape on an Immutable Matrix instance');\n  };\n  /**\n   * Create a clone of the matrix\n   * @return {ImmutableDenseMatrix} clone\n   */\n\n\n  ImmutableDenseMatrix.prototype.clone = function () {\n    var m = new ImmutableDenseMatrix({\n      data: object.clone(this._data),\n      size: object.clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @returns {Object}\n   */\n\n\n  ImmutableDenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'ImmutableDenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ImmutableDenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {ImmutableDenseMatrix}\n   */\n\n\n  ImmutableDenseMatrix.fromJSON = function (json) {\n    return new ImmutableDenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @param {Number} i       Matrix row index 1\n   * @param {Number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  ImmutableDenseMatrix.prototype.swapRows = function () {\n    throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');\n  };\n  /**\n   * Calculate the minimum value in the set\n   * @return {Number | undefined} min\n   */\n\n\n  ImmutableDenseMatrix.prototype.min = function () {\n    // check min has been calculated before\n    if (this._min === null) {\n      // minimum\n      var m = null; // compute min\n\n      this.forEach(function (v) {\n        if (m === null || smaller(v, m)) {\n          m = v;\n        }\n      });\n      this._min = m !== null ? m : undefined;\n    }\n\n    return this._min;\n  };\n  /**\n   * Calculate the maximum value in the set\n   * @return {Number | undefined} max\n   */\n\n\n  ImmutableDenseMatrix.prototype.max = function () {\n    // check max has been calculated before\n    if (this._max === null) {\n      // maximum\n      var m = null; // compute max\n\n      this.forEach(function (v) {\n        if (m === null || smaller(m, v)) {\n          m = v;\n        }\n      });\n      this._max = m !== null ? m : undefined;\n    }\n\n    return this._max;\n  }; // exports\n\n\n  return ImmutableDenseMatrix;\n}\n\nexports.name = 'ImmutableDenseMatrix';\nexports.path = 'type';\nexports.factory = factory;"],"sourceRoot":""}