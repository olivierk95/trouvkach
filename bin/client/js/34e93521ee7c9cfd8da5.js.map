{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/statistics/mode.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/statistics/prod.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/statistics/quantileSeq.js"],"names":["flatten","__webpack_require__","exports","name","factory","type","config","load","typed","isNaN","isNumeric","Array | Matrix","_mode","...","args","values","valueOf","length","Error","count","mode","max","i","value","push","deepForEach","multiply","improveErrorMessage","prod","_prod","Array | Matrix, number | BigNumber","array","dim","toTex","undefined","err","isInteger","isNumber","isCollection","add","partitionSelect","compare","_quantileSeq","prob","sorted","flat","len","_index","_fracPart","validate","_left","_right","_integerPart","Math","floor","index","times","toNumber","_value","left","right","integerPart","fracPart","minus","integerPartNumber","_i3","one","constructor","number | BigNumber | Unit","x","data","probOrN","probArr","dataArr","arguments","SyntaxError","nPlusOne","Array","isBigNumber","isNegative","lte","BigNumber","gt","intN","_nPlusOne","_i","div","isArray","_i2","currProb","TypeError"],"mappings":"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","file":"js/34e93521ee7c9cfd8da5.js","sourcesContent":["'use strict';\n\nvar flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var isNaN = load(require('../utils/isNaN'));\n  var isNumeric = load(require('../utils/isNumeric'));\n  /**\n  * Computes the mode of a set of numbers or a list with values(numbers or characters).\n  * If there are more than one modes, it returns a list of those values.\n  *\n  * Syntax:\n  *\n  *     math.mode(a, b, c, ...)\n  *     math.mode(A)\n  *\n  * Examples:\n  *\n  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]\n  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]\n  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]\n  *     math.mode('a','a','b','c')                           // returns [\"a\"]\n  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, \"abc\"]\n  *\n  * See also:\n  *\n  *     median,\n  *     mean\n  *\n  * @param {... *} args  A single matrix\n  * @return {*} The mode of all values\n  */\n\n  var mode = typed('mode', {\n    'Array | Matrix': _mode,\n    '...': function _(args) {\n      return _mode(args);\n    }\n  });\n  return mode;\n  /**\n   * Calculates the mode in an 1-dimensional array\n   * @param {Array} values\n   * @return {Array} mode\n   * @private\n   */\n\n  function _mode(values) {\n    values = flatten(values.valueOf());\n    var num = values.length;\n\n    if (num === 0) {\n      throw new Error('Cannot calculate mode of an empty array');\n    }\n\n    var count = {};\n    var mode = [];\n    var max = 0;\n\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n\n      if (isNumeric(value) && isNaN(value)) {\n        throw new Error('Cannot calculate mode of an array containing NaN values');\n      }\n\n      if (!(value in count)) {\n        count[value] = 0;\n      }\n\n      count[value]++;\n\n      if (count[value] === max) {\n        mode.push(value);\n      } else if (count[value] > max) {\n        max = count[value];\n        mode = [value];\n      }\n    }\n\n    return mode;\n  }\n}\n\nexports.name = 'mode';\nexports.factory = factory;","'use strict';\n\nvar deepForEach = require('../../utils/collection/deepForEach');\n\nfunction factory(type, config, load, typed) {\n  var multiply = load(require('../arithmetic/multiplyScalar'));\n  var improveErrorMessage = load(require('./utils/improveErrorMessage'));\n  /**\n   * Compute the product of a matrix or a list with values.\n   * In case of a (multi dimensional) array or matrix, the sum of all\n   * elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.prod(a, b, c, ...)\n   *     math.prod(A)\n   *\n   * Examples:\n   *\n   *     math.multiply(2, 3)           // returns 6\n   *     math.prod(2, 3)               // returns 6\n   *     math.prod(2, 3, 4)            // returns 24\n   *     math.prod([2, 3, 4])          // returns 24\n   *     math.prod([[2, 5], [4, 3]])   // returns 120\n   *\n   * See also:\n   *\n   *    mean, median, min, max, sum, std, var\n   *\n   * @param {... *} args  A single matrix or or multiple scalar values\n   * @return {*} The product of all values\n   */\n\n  var prod = typed('prod', {\n    // prod([a, b, c, d, ...])\n    'Array | Matrix': _prod,\n    // prod([a, b, c, d, ...], dim)\n    'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {\n      // TODO: implement prod(A, dim)\n      throw new Error('prod(A, dim) is not yet supported'); // return reduce(arguments[0], arguments[1], math.prod)\n    },\n    // prod(a, b, c, d, ...)\n    '...': function _(args) {\n      return _prod(args);\n    }\n  });\n  prod.toTex = undefined; // use default template\n\n  return prod;\n  /**\n   * Recursively calculate the product of an n-dimensional array\n   * @param {Array} array\n   * @return {number} prod\n   * @private\n   */\n\n  function _prod(array) {\n    var prod;\n    deepForEach(array, function (value) {\n      try {\n        prod = prod === undefined ? value : multiply(prod, value);\n      } catch (err) {\n        throw improveErrorMessage(err, 'prod', value);\n      }\n    });\n\n    if (prod === undefined) {\n      throw new Error('Cannot calculate prod of an empty array');\n    }\n\n    return prod;\n  }\n}\n\nexports.name = 'prod';\nexports.factory = factory;","'use strict';\n\nvar isInteger = require('../../utils/number').isInteger;\n\nvar isNumber = require('../../utils/number').isNumber;\n\nvar flatten = require('../../utils/array').flatten;\n\nvar isCollection = require('../../utils/collection/isCollection');\n\nfunction factory(type, config, load, typed) {\n  var add = load(require('../arithmetic/add'));\n  var multiply = load(require('../arithmetic/multiply'));\n  var partitionSelect = load(require('../matrix/partitionSelect'));\n  var compare = load(require('../relational/compare'));\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, var\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n\n    if (isCollection(data)) {\n      sorted = sorted || false;\n\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n\n        if (isNumber(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!isInteger(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n\n            return probArr;\n          }\n        }\n\n        if (type.isBigNumber(probOrN)) {\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          one = new probOrN.constructor(1);\n\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new type.BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n\n            var intN = probOrN.toNumber();\n\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n\n            var _nPlusOne = new type.BigNumber(intN + 1);\n\n            probArr = new Array(intN);\n\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new type.BigNumber(_quantileSeq(dataArr, new type.BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n\n            return probArr;\n          }\n        }\n\n        if (Array.isArray(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          probArr = new Array(probOrN.length);\n\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrN[_i2];\n\n            if (isNumber(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if (type.isBigNumber(currProb)) {\n              one = new currProb.constructor(1);\n\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n\n          return probArr;\n        }\n\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n\n    if (isNumber(prob)) {\n      var _index = prob * (len - 1);\n\n      var _fracPart = _index % 1;\n\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n\n      var _integerPart = Math.floor(_index);\n\n      var _left;\n\n      var _right;\n\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n\n    var index = prob.times(len - 1);\n\n    if (index.isInteger()) {\n      index = index.toNumber();\n\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n\n      validate(_value);\n      return _value;\n    }\n\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return quantileSeq;\n}\n\nexports.name = 'quantileSeq';\nexports.factory = factory;"],"sourceRoot":""}