{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/diag.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/dot.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/eye.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/expm.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/filter.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/flatten.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/forEach.js"],"names":["array","__webpack_require__","isInteger","exports","name","factory","type","config","load","typed","matrix","diag","Array","x","_diag","size","Array, number","k","Array, BigNumber","toNumber","Array, string","format","Array, number, string","Array, BigNumber, string","Matrix","storage","Matrix, number","Matrix, BigNumber","Matrix, string","Matrix, number, string","Matrix, BigNumber, string","toTex","undefined","TypeError","kSuper","kSub","length","l","ms","m","diagonal","valueOf","_createDiagonalMatrix","s","isMatrix","dm","n","Math","min","vector","i","_getDiagonal","RangeError","add","multiply","dot","Matrix, Matrix","y","_dot","toArray","Matrix, Array","Array, Matrix","Array, Array","2","xSize","ySize","len","prod","Error","abs","identity","inv","SparseMatrix","expm","A","params","infNorm","eps","q","j","errorEstimate","findParams","rowSum","get","max","infinityNorm","Apos","pow","N","D","factor","AposToI","alternate","R","_i","isSparseMatrix","qfac","twoqfac","_i2","twoqp1fac","1","filter","filterRegExp","maxArgumentCount","_filterCallback","callback","args","value","index","Array, function","Matrix, function","test","Array, RegExp","Matrix, RegExp","clone","_flatten","flatten","flat","forEach","_forEach","recurse","isArray","child","concat"],"mappings":"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","file":"js/4cc7acdbc955def33c12.js","sourcesContent":["'use strict';\n\nvar array = require('../../utils/array');\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n\n  var diag = typed('diag', {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    'Array': function Array(x) {\n      return _diag(x, 0, array.size(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, array.size(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), array.size(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, array.size(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, array.size(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), array.size(x), format);\n    },\n    'Matrix': function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  diag.toTex = undefined; // use default template\n\n  return diag;\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper]; // get matrix constructor\n\n    var F = type.Matrix.storage(format || 'dense'); // create diagonal matrix\n\n    var m = F.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (type.isMatrix(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n}\n\nexports.name = 'diag';\nexports.factory = factory;","'use strict';\n\nvar size = require('../../utils/array').size;\n\nfunction factory(type, config, load, typed) {\n  var add = load(require('../arithmetic/add'));\n  var multiply = load(require('../arithmetic/multiply'));\n  /**\n   * Calculate the dot product of two vectors. The dot product of\n   * `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:\n   *\n   *    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn\n   *\n   * Syntax:\n   *\n   *    math.dot(x, y)\n   *\n   * Examples:\n   *\n   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15\n   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15\n   *\n   * See also:\n   *\n   *    multiply, cross\n   *\n   * @param  {Array | Matrix} x     First vector\n   * @param  {Array | Matrix} y     Second vector\n   * @return {number}               Returns the dot product of `x` and `y`\n   */\n\n  var dot = typed('dot', {\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      return _dot(x.toArray(), y.toArray());\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      return _dot(x.toArray(), y);\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      return _dot(x, y.toArray());\n    },\n    'Array, Array': _dot\n  });\n  dot.toTex = {\n    2: \"\\\\left(${args[0]}\\\\cdot${args[1]}\\\\right)\"\n  };\n  return dot;\n  /**\n   * Calculate the dot product for two arrays\n   * @param {Array} x  First vector\n   * @param {Array} y  Second vector\n   * @returns {number} Returns the dot product of x and y\n   * @private\n   */\n  // TODO: double code with math.multiply\n\n  function _dot(x, y) {\n    var xSize = size(x);\n    var ySize = size(y);\n    var len = xSize[0];\n    if (xSize.length !== 1 || ySize.length !== 1) throw new RangeError('Vector expected'); // TODO: better error message\n\n    if (xSize[0] !== ySize[0]) throw new RangeError('Vectors must have equal length (' + xSize[0] + ' != ' + ySize[0] + ')');\n    if (len === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');\n    var prod = 0;\n\n    for (var i = 0; i < len; i++) {\n      prod = add(prod, multiply(x[i], y[i]));\n    }\n\n    return prod;\n  }\n}\n\nexports.name = 'dot';\nexports.factory = factory;","'use strict'; // TODO: function eye is removed since v5.0.0 (June 2018). Remove it some day.\n\nfunction factory(type, config, load, typed) {\n  return function eye() {\n    throw new Error('Function \"eye\" is renamed to \"identity\" since mathjs version 5.0.0. ' + 'To keep eye working, create an alias for it using \"math.import({eye: math.identity}, {override: true})\"');\n  };\n}\n\nexports.name = 'eye';\nexports.factory = factory;","'use strict';\n\nvar format = require('../../utils/string').format;\n\nfunction factory(type, config, load, typed) {\n  var abs = load(require('../arithmetic/abs'));\n  var add = load(require('../arithmetic/add'));\n  var identity = load(require('./identity'));\n  var inv = load(require('./inv'));\n  var multiply = load(require('../arithmetic/multiply'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n\n  var expm = typed('expm', {\n    'Matrix': function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n      }\n\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n\n      return type.isSparseMatrix(A) ? new SparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    var twoqfac = qfac;\n\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n\n  expm.toTex = {\n    1: \"\\\\exp\\\\left(${args[0]}\\\\right)\"\n  };\n  return expm;\n}\n\nexports.name = 'expm';\nexports.factory = factory;","'use strict';\n\nvar filter = require('../../utils/array').filter;\n\nvar filterRegExp = require('../../utils/array').filterRegExp;\n\nvar maxArgumentCount = require('../../utils/function').maxArgumentCount;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Filter the items in an array or one dimensional matrix.\n   *\n   * Syntax:\n   *\n   *    math.filter(x, test)\n   *\n   * Examples:\n   *\n   *    function isPositive (x) {\n   *      return x > 0\n   *    }\n   *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]\n   *\n   *    math.filter([\"23\", \"foo\", \"100\", \"55\", \"bar\"], /[0-9]+/) // returns [\"23\", \"100\", \"55\"]\n   *\n   * See also:\n   *\n   *    forEach, map, sort\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to filter\n   * @param {Function | RegExp} test\n   *        A function or regular expression to test items.\n   *        All entries for which `test` returns true are returned.\n   *        When `test` is a function, it is invoked with three parameters:\n   *        the value of the element, the index of the element, and the\n   *        matrix/array being traversed. The function must return a boolean.\n   * @return {Matrix | Array} Returns the filtered matrix.\n   */\n\n  var filter = typed('filter', {\n    'Array, function': _filterCallback,\n    'Matrix, function': function MatrixFunction(x, test) {\n      return matrix(_filterCallback(x.toArray(), test));\n    },\n    'Array, RegExp': filterRegExp,\n    'Matrix, RegExp': function MatrixRegExp(x, test) {\n      return matrix(filterRegExp(x.toArray(), test));\n    }\n  });\n  filter.toTex = undefined; // use default template\n\n  return filter;\n}\n/**\n * Filter values in a callback given a callback function\n * @param {Array} x\n * @param {Function} callback\n * @return {Array} Returns the filtered array\n * @private\n */\n\n\nfunction _filterCallback(x, callback) {\n  // figure out what number of arguments the callback function expects\n  var args = maxArgumentCount(callback);\n  return filter(x, function (value, index, array) {\n    // invoke the callback function with the right number of arguments\n    if (args === 1) {\n      return callback(value);\n    } else if (args === 2) {\n      return callback(value, [index]);\n    } else {\n      // 3 or -1\n      return callback(value, [index], array);\n    }\n  });\n}\n\nexports.name = 'filter';\nexports.factory = factory;","'use strict';\n\nvar clone = require('../../utils/object').clone;\n\nvar _flatten = require('../../utils/array').flatten;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Flatten a multi dimensional matrix into a single dimensional matrix.\n   *\n   * Syntax:\n   *\n   *    math.flatten(x)\n   *\n   * Examples:\n   *\n   *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]\n   *\n   * See also:\n   *\n   *    concat, resize, size, squeeze\n   *\n   * @param {Matrix | Array} x   Matrix to be flattened\n   * @return {Matrix | Array} Returns the flattened matrix\n   */\n\n  var flatten = typed('flatten', {\n    'Array': function Array(x) {\n      return _flatten(clone(x));\n    },\n    'Matrix': function Matrix(x) {\n      var flat = _flatten(clone(x.toArray())); // TODO: return the same matrix type as x\n\n\n      return matrix(flat);\n    }\n  });\n  flatten.toTex = undefined; // use default template\n\n  return flatten;\n}\n\nexports.name = 'flatten';\nexports.factory = factory;","'use strict';\n\nvar maxArgumentCount = require('../../utils/function').maxArgumentCount;\n\nvar forEach = require('../../utils/array').forEach;\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Iterate over all elements of a matrix/array, and executes the given callback function.\n   *\n   * Syntax:\n   *\n   *    math.forEach(x, callback)\n   *\n   * Examples:\n   *\n   *    math.forEach([1, 2, 3], function(value) {\n   *      console.log(value)\n   *    })\n   *    // outputs 1, 2, 3\n   *\n   * See also:\n   *\n   *    filter, map, sort\n   *\n   * @param {Matrix | Array} x    The matrix to iterate on.\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix/array being traversed.\n   */\n  var forEach = typed('forEach', {\n    'Array, function': _forEach,\n    'Matrix, function': function MatrixFunction(x, callback) {\n      return x.forEach(callback);\n    }\n  });\n  forEach.toTex = undefined; // use default template\n\n  return forEach;\n}\n/**\n * forEach for a multi dimensional array\n * @param {Array} array\n * @param {Function} callback\n * @private\n */\n\n\nfunction _forEach(array, callback) {\n  // figure out what number of arguments the callback function expects\n  var args = maxArgumentCount(callback);\n\n  var recurse = function recurse(value, index) {\n    if (Array.isArray(value)) {\n      forEach(value, function (child, i) {\n        // we create a copy of the index array and append the new index value\n        recurse(child, index.concat(i));\n      });\n    } else {\n      // invoke the callback function with the right number of arguments\n      if (args === 1) {\n        callback(value);\n      } else if (args === 2) {\n        callback(value, index);\n      } else {\n        // 3 or -1\n        callback(value, index, array);\n      }\n    }\n  };\n\n  recurse(array, []);\n}\n\nexports.name = 'forEach';\nexports.factory = factory;"],"sourceRoot":""}