{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/RangeNode.js"],"names":["operators","__webpack_require__","exports","name","path","factory","type","config","load","typed","Node","RangeNode","start","end","step","this","SyntaxError","isNode","TypeError","arguments","length","Error","calculateNecessaryParentheses","node","parenthesis","precedence","getPrecedence","parens","startPrecedence","stepPrecedence","endPrecedence","prototype","isRangeNode","needsEnd","filter","isSymbolNode","_compile","math","argNames","range","evalStart","evalEnd","evalStep","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat"],"mappings":"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","file":"js/aadd502ac48cb0851c91.js","sourcesContent":["'use strict';\n\nvar operators = require('../operators');\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!type.isNode(start)) throw new TypeError('Node expected');\n    if (!type.isNode(end)) throw new TypeError('Node expected');\n    if (step && !type.isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return type.isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = operators.getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = operators.getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = operators.getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}\n\nexports.name = 'RangeNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}