{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/simplify/util.js"],"names":["exports","factory","type","config","load","typed","math","FunctionNode","expression","node","OperatorNode","SymbolNode","commutative","add","multiply","associative","isAssociative","context","isOperatorNode","name","fn","toString","hasOwnProperty","allChildren","op","children","findChildren","i","args","length","child","push","createMakeNodeFunction","implicit","err","console","error","isCommutative","flatten","unflattenr","makeNode","l","curnode","pop","unflattenl","shift"],"mappings":"4FAgLAA,EAAAC,QA9KA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAAE,WAAAC,KAAAF,aACAG,EAAAJ,EAAAE,WAAAC,KAAAC,aACAC,EAAAL,EAAAE,WAAAC,KAAAE,WAKAC,EAAA,CACAC,KAAA,EACAC,UAAA,GAEAC,EAAA,CACAF,KAAA,EACAC,UAAA,GAiBA,SAAAE,EAAAP,EAAAQ,GACA,IAAAf,EAAAgB,eAAAT,GACA,SAGA,IAAAU,EAAAV,EAAAW,GAAAC,WAEA,OAAAJ,KAAAK,eAAAH,IAAAF,EAAAE,GAAAG,eAAA,eACAL,EAAAE,GAAAJ,YAGAA,EAAAI,KAAA,EAyBA,SAAAI,EAAAd,GACA,IAAAe,EACAC,EAAA,GAcA,OAAAT,EAAAP,IACAe,EAAAf,EAAAe,GAbA,SAAAE,EAAAjB,GACA,QAAAkB,EAAA,EAAqBA,EAAAlB,EAAAmB,KAAAC,OAAsBF,IAAA,CAC3C,IAAAG,EAAArB,EAAAmB,KAAAD,GAEAzB,EAAAgB,eAAAY,IAAAN,IAAAM,EAAAN,GACAE,EAAAI,GAEAL,EAAAM,KAAAD,IAOAJ,CAAAjB,GACAgB,GAEAhB,EAAAmB,KA0DA,SAAAI,EAAAvB,GACA,OAAAP,EAAAgB,eAAAT,GACA,SAAAmB,GACA,IACA,WAAAlB,EAAAD,EAAAe,GAAAf,EAAAW,GAAAQ,EAAAnB,EAAAwB,UACS,MAAAC,GAET,OADAC,QAAAC,MAAAF,GACA,KAIA,SAAAN,GACA,WAAArB,EAAA,IAAAI,EAAAF,EAAAU,MAAAS,IAKA,OACAI,yBACAK,cApJA,SAAA5B,EAAAQ,GACA,IAAAf,EAAAgB,eAAAT,GACA,SAGA,IAAAU,EAAAV,EAAAW,GAAAC,WAEA,OAAAJ,KAAAK,eAAAH,IAAAF,EAAAE,GAAAG,eAAA,eACAL,EAAAE,GAAAP,YAGAA,EAAAO,KAAA,GA0IAH,gBACAsB,QArHA,SAAAA,EAAA7B,GACA,IAAAA,EAAAmB,MAAA,IAAAnB,EAAAmB,KAAAC,OACA,OAAApB,EAGAA,EAAAmB,KAAAL,EAAAd,GAEA,QAAAkB,EAAA,EAAmBA,EAAAlB,EAAAmB,KAAAC,OAAsBF,IACzCW,EAAA7B,EAAAmB,KAAAD,KA8GAJ,cACAgB,WAzEA,SAAAA,EAAA9B,GACA,GAAAA,EAAAmB,MAAA,IAAAnB,EAAAmB,KAAAC,OAAA,CAOA,IAHA,IAAAW,EAAAR,EAAAvB,GACAgC,EAAAhC,EAAAmB,KAAAC,OAEAF,EAAA,EAAmBA,EAAAc,EAAOd,IAC1BY,EAAA9B,EAAAmB,KAAAD,IAGA,GAAAc,EAAA,GAAAzB,EAAAP,GAAA,CAGA,IAFA,IAAAiC,EAAAjC,EAAAmB,KAAAe,MAEAlC,EAAAmB,KAAAC,OAAA,GACAa,EAAAF,EAAA,CAAA/B,EAAAmB,KAAAe,MAAAD,IAGAjC,EAAAmB,KAAAc,EAAAd,QAuDAgB,WA/CA,SAAAA,EAAAnC,GACA,GAAAA,EAAAmB,MAAA,IAAAnB,EAAAmB,KAAAC,OAAA,CAOA,IAHA,IAAAW,EAAAR,EAAAvB,GACAgC,EAAAhC,EAAAmB,KAAAC,OAEAF,EAAA,EAAmBA,EAAAc,EAAOd,IAC1BiB,EAAAnC,EAAAmB,KAAAD,IAGA,GAAAc,EAAA,GAAAzB,EAAAP,GAAA,CAGA,IAFA,IAAAiC,EAAAjC,EAAAmB,KAAAiB,QAEApC,EAAAmB,KAAAC,OAAA,GACAa,EAAAF,EAAA,CAAAE,EAAAjC,EAAAmB,KAAAiB,UAGApC,EAAAmB,KAAAc,EAAAd,UAiCA5B,EAAAM,MAAA","file":"js/023e6cecc2a361a1a07c.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var FunctionNode = math.expression.node.FunctionNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var SymbolNode = math.expression.node.SymbolNode; // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  var commutative = {\n    'add': true,\n    'multiply': true\n  };\n  var associative = {\n    'add': true,\n    'multiply': true\n  };\n\n  function isCommutative(node, context) {\n    if (!type.isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && context.hasOwnProperty(name) && context[name].hasOwnProperty('commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!type.isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && context.hasOwnProperty(name) && context[name].hasOwnProperty('associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (type.isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (type.isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n}\n\nexports.factory = factory;\nexports.math = true;"],"sourceRoot":""}