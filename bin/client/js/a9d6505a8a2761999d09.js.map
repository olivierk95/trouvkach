{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/AccessorNode.js"],"names":["getSafeProperty","__webpack_require__","exports","name","path","factory","type","config","load","typed","Node","access","AccessorNode","object","index","this","SyntaxError","isNode","TypeError","isIndexNode","Object","defineProperty","get","isObjectProperty","getObjectProperty","bind","set","Error","needParenthesis","node","isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isObjectNode","isParenthesisNode","isSymbolNode","prototype","_compile","math","argNames","evalObject","evalIndex","prop","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","toString","toHTML","_toTex","toTex","toJSON","mathjs","fromJSON","json"],"mappings":"2FAEA,IAAAA,EAAsBC,EAAQ,IAAqBD,gBAsMnDE,EAAAC,KAAA,eACAD,EAAAE,KAAA,kBACAF,EAAAG,QAtMA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAkBP,EAAQ,KAC1BU,EAAAH,EAAoBP,EAAQ,MAW5B,SAAAW,EAAAC,EAAAC,GACA,KAAAC,gBAAAH,GACA,UAAAI,YAAA,oDAGA,IAAAV,EAAAW,OAAAJ,GACA,UAAAK,UAAA,wCAGA,IAAAZ,EAAAa,YAAAL,GACA,UAAAI,UAAA,4CAGAH,KAAAF,UAAA,KACAE,KAAAD,QAEAM,OAAAC,eAAAN,KAAA,QACAO,IAAA,WACA,OAAAP,KAAAD,MACAC,KAAAD,MAAAS,mBAAAR,KAAAD,MAAAU,oBAAA,GAEAT,KAAAF,OAAAV,MAAA,IAEOsB,KAAAV,MACPW,IAAA,WACA,UAAAC,MAAA,kDAsJA,SAAAC,EAAAC,GAEA,QAAAvB,EAAAwB,eAAAD,IAAAvB,EAAAyB,YAAAF,IAAAvB,EAAA0B,eAAAH,IAAAvB,EAAA2B,eAAAJ,IAAAvB,EAAA4B,aAAAL,IAAAvB,EAAA6B,kBAAAN,IAAAvB,EAAA8B,aAAAP,IAGA,OAtJAjB,EAAAyB,UAAA,IAAA3B,EACAE,EAAAyB,UAAA/B,KAAA,eACAM,EAAAyB,UAAAP,gBAAA,EAeAlB,EAAAyB,UAAAC,SAAA,SAAAC,EAAAC,GACA,IAAAC,EAAA1B,KAAAF,OAAAyB,SAAAC,EAAAC,GAEAE,EAAA3B,KAAAD,MAAAwB,SAAAC,EAAAC,GAEA,GAAAzB,KAAAD,MAAAS,mBAAA,CACA,IAAAoB,EAAA5B,KAAAD,MAAAU,oBACA,gBAAAoB,EAAAC,EAAAC,GACA,OAAA9C,EAAAyC,EAAAG,EAAAC,EAAAC,GAAAH,IAGA,gBAAAC,EAAAC,EAAAC,GACA,IAAAjC,EAAA4B,EAAAG,EAAAC,EAAAC,GACAhC,EAAA4B,EAAAE,EAAAC,EAAAhC,GAEA,OAAAF,EAAAE,EAAAC,KAUAF,EAAAyB,UAAAU,QAAA,SAAAC,GACAA,EAAAjC,KAAAF,OAAA,SAAAE,MACAiC,EAAAjC,KAAAD,MAAA,QAAAC,OAUAH,EAAAyB,UAAAY,IAAA,SAAAD,GACA,WAAApC,EAAAG,KAAAmC,QAAAF,EAAAjC,KAAAF,OAAA,SAAAE,YAAAmC,QAAAF,EAAAjC,KAAAD,MAAA,QAAAC,SAQAH,EAAAyB,UAAAc,MAAA,WACA,WAAAvC,EAAAG,KAAAF,OAAAE,KAAAD,QASAF,EAAAyB,UAAAe,UAAA,SAAAC,GACA,IAAAxC,EAAAE,KAAAF,OAAAyC,SAAAD,GAMA,OAJAzB,EAAAb,KAAAF,UACAA,EAAA,IAAAA,EAAA,KAGAA,EAAAE,KAAAD,MAAAwC,SAAAD,IASAzC,EAAAyB,UAAAkB,OAAA,SAAAF,GACA,IAAAxC,EAAAE,KAAAF,OAAA0C,OAAAF,GAMA,OAJAzB,EAAAb,KAAAF,UACAA,EAAA,iEAAAA,EAAA,kEAGAA,EAAAE,KAAAD,MAAAyC,OAAAF,IASAzC,EAAAyB,UAAAmB,OAAA,SAAAH,GACA,IAAAxC,EAAAE,KAAAF,OAAA4C,MAAAJ,GAMA,OAJAzB,EAAAb,KAAAF,UACAA,EAAA,iCAGAA,EAAAE,KAAAD,MAAA2C,MAAAJ,IAQAzC,EAAAyB,UAAAqB,OAAA,WACA,OACAC,OAAA,eACA9C,OAAAE,KAAAF,OACAC,MAAAC,KAAAD,QAYAF,EAAAgD,SAAA,SAAAC,GACA,WAAAjD,EAAAiD,EAAAhD,OAAAgD,EAAA/C,QAaAF","file":"js/a9d6505a8a2761999d09.js","sourcesContent":["'use strict';\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var access = load(require('./utils/access'));\n  /**\n   * @constructor AccessorNode\n   * @extends {Node}\n   * Access an object property or get a matrix subset\n   *\n   * @param {Node} object                 The object from which to retrieve\n   *                                      a property or subset.\n   * @param {IndexNode} index             IndexNode containing ranges\n   */\n\n  function AccessorNode(object, index) {\n    if (!(this instanceof AccessorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!type.isNode(object)) {\n      throw new TypeError('Node expected for parameter \"object\"');\n    }\n\n    if (!type.isIndexNode(index)) {\n      throw new TypeError('IndexNode expected for parameter \"index\"');\n    }\n\n    this.object = object || null;\n    this.index = index; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\n        } else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AccessorNode.prototype = new Node();\n  AccessorNode.prototype.type = 'AccessorNode';\n  AccessorNode.prototype.isAccessorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  AccessorNode.prototype._compile = function (math, argNames) {\n    var evalObject = this.object._compile(math, argNames);\n\n    var evalIndex = this.index._compile(math, argNames);\n\n    if (this.index.isObjectProperty()) {\n      var prop = this.index.getObjectProperty();\n      return function evalAccessorNode(scope, args, context) {\n        return getSafeProperty(evalObject(scope, args, context), prop);\n      };\n    } else {\n      return function evalAccessorNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        var index = evalIndex(scope, args, object); // we pass object here instead of context\n\n        return access(object, index);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  AccessorNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    callback(this.index, 'index', this);\n  };\n  /**\n   * Create a new AccessorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AccessorNode} Returns a transformed copy of the node\n   */\n\n\n  AccessorNode.prototype.map = function (callback) {\n    return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AccessorNode}\n   */\n\n\n  AccessorNode.prototype.clone = function () {\n    return new AccessorNode(this.object, this.index);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n\n    if (needParenthesis(this.object)) {\n      object = '(' + object + ')';\n    }\n\n    return object + this.index.toString(options);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n\n    if (needParenthesis(this.object)) {\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + this.index.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n\n    if (needParenthesis(this.object)) {\n      object = \"\\\\left(' + object + '\\\\right)\";\n    }\n\n    return object + this.index.toTex(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  AccessorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'AccessorNode',\n      object: this.object,\n      index: this.index\n    };\n  };\n  /**\n   * Instantiate an AccessorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"AccessorNode\", object: ..., index: ...}`,\n   *                       where mathjs is optional\n   * @returns {AccessorNode}\n   */\n\n\n  AccessorNode.fromJSON = function (json) {\n    return new AccessorNode(json.object, json.index);\n  };\n  /**\n   * Are parenthesis needed?\n   * @private\n   */\n\n\n  function needParenthesis(node) {\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\n    return !(type.isAccessorNode(node) || type.isArrayNode(node) || type.isConstantNode(node) || type.isFunctionNode(node) || type.isObjectNode(node) || type.isParenthesisNode(node) || type.isSymbolNode(node));\n  }\n\n  return AccessorNode;\n}\n\nexports.name = 'AccessorNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}