{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/ObjectNode.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/ParenthesisNode.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","stringify","__webpack_require__","escape","isSafeProperty","hasOwnProperty","exports","name","path","factory","type","config","load","typed","Node","ObjectNode","properties","this","SyntaxError","Object","keys","every","key","isNode","TypeError","isObjectNode","_compile","math","argNames","evalEntries","stringifiedKey","parsedKey","JSON","parse","Error","scope","args","context","_key","forEach","callback","map","_ifNode","clone","_toString","options","entries","push","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","ParenthesisNode","content","isParenthesisNode","getContent","parenthesis"],"mappings":"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","file":"js/589da8f08788c6fdbc88.js","sourcesContent":["'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar stringify = require('../../utils/string').stringify;\n\nvar escape = require('../../utils/string').escape;\n\nvar isSafeProperty = require('../../utils/customs').isSafeProperty;\n\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor ObjectNode\n   * @extends {Node}\n   * Holds an object with keys/values\n   * @param {Object.<string, Node>} [properties]   object with key/value pairs\n   */\n\n  function ObjectNode(properties) {\n    if (!(this instanceof ObjectNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.properties = properties || {}; // validate input\n\n    if (properties) {\n      if (!(_typeof(properties) === 'object') || !Object.keys(properties).every(function (key) {\n        return type.isNode(properties[key]);\n      })) {\n        throw new TypeError('Object containing Nodes expected');\n      }\n    }\n  }\n\n  ObjectNode.prototype = new Node();\n  ObjectNode.prototype.type = 'ObjectNode';\n  ObjectNode.prototype.isObjectNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ObjectNode.prototype._compile = function (math, argNames) {\n    var evalEntries = {};\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        // we stringify/parse the key here to resolve unicode characters,\n        // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n        var stringifiedKey = stringify(key);\n        var parsedKey = JSON.parse(stringifiedKey);\n\n        if (!isSafeProperty(this.properties, parsedKey)) {\n          throw new Error('No access to property \"' + parsedKey + '\"');\n        }\n\n        evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);\n      }\n    }\n\n    return function evalObjectNode(scope, args, context) {\n      var obj = {};\n\n      for (var _key in evalEntries) {\n        if (hasOwnProperty(evalEntries, _key)) {\n          obj[_key] = evalEntries[_key](scope, args, context);\n        }\n      }\n\n      return obj;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ObjectNode.prototype.forEach = function (callback) {\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n      }\n    }\n  };\n  /**\n   * Create a new ObjectNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ObjectNode} Returns a transformed copy of the node\n   */\n\n\n  ObjectNode.prototype.map = function (callback) {\n    var properties = {};\n\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n      }\n    }\n\n    return new ObjectNode(properties);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ObjectNode}\n   */\n\n\n  ObjectNode.prototype.clone = function () {\n    var properties = {};\n\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        properties[key] = this.properties[key];\n      }\n    }\n\n    return new ObjectNode(properties);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ObjectNode.prototype._toString = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n      }\n    }\n\n    return '{' + entries.join(', ') + '}';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ObjectNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ObjectNode',\n      properties: this.properties\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\n   *                       where mathjs is optional\n   * @returns {ObjectNode}\n   */\n\n\n  ObjectNode.fromJSON = function (json) {\n    return new ObjectNode(json.properties);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ObjectNode.prototype.toHTML = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator math-property-assignment-operator math-binary-operator\">:</span>' + this.properties[key].toHTML(options));\n      }\n    }\n\n    return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ObjectNode.prototype._toTex = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n      }\n    }\n\n    return \"\\\\left\\\\{\\\\begin{array}{ll}\".concat(entries.join('\\n'), \"\\\\end{array}\\\\right\\\\}\");\n  };\n\n  return ObjectNode;\n}\n\nexports.name = 'ObjectNode';\nexports.path = 'expression.node';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor ParenthesisNode\n   * @extends {Node}\n   * A parenthesis node describes manual parenthesis from the user input\n   * @param {Node} content\n   * @extends {Node}\n   */\n\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (!type.isNode(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n\n    this.content = content;\n  }\n\n  ParenthesisNode.prototype = new Node();\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n  ParenthesisNode.prototype.isParenthesisNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ParenthesisNode.prototype._compile = function (math, argNames) {\n    return this.content._compile(math, argNames);\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} content\n   * @override\n   **/\n\n\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n  /**\n   * Create a new ParenthesisNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ParenthesisNode} Returns a clone of the node\n   */\n\n\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.prototype.clone = function () {\n    return new ParenthesisNode(this.content);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toString = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '(' + this.content.toString(options) + ')';\n    }\n\n    return this.content.toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ParenthesisNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ParenthesisNode',\n      content: this.content\n    };\n  };\n  /**\n   * Instantiate an ParenthesisNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.fromJSON = function (json) {\n    return new ParenthesisNode(json.content);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype.toHTML = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return this.content.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toTex = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\n    }\n\n    return this.content.toTex(options);\n  };\n\n  return ParenthesisNode;\n}\n\nexports.name = 'ParenthesisNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}