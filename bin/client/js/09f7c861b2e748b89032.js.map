{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/escape-latex/dist/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","defaultEscapes","{","}","\\","#","$","%","&","^","_","~","formatEscapes","–","—"," ","\t","\r\n","\n","defaultEscapeMapFn","module","exports","str","_ref","undefined","_ref$preserveFormatti","preserveFormatting","_ref$escapeMapFn","escapeMapFn","runningStr","String","result","escapes","escapeKeys","keys","_loop","specialCharFound","forEach","index","slice"],"mappings":"0FAKA,IAAAA,EAAAC,OAAAC,QAAA,SAAAC,GAAmD,QAAAC,EAAA,EAAgBA,EAAAC,UAAAC,OAAsBF,IAAA,CAAO,IAAAG,EAAAF,UAAAD,GAA2B,QAAAI,KAAAD,EAA0BN,OAAAQ,UAAAC,eAAAC,KAAAJ,EAAAC,KAAyDL,EAAAK,GAAAD,EAAAC,IAAiC,OAAAL,GAE/OS,EAAA,CACAC,IAAI,MACJC,IAAI,MACJC,KAAA,oBACAC,IAAA,MACAC,EAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,sBACAC,EAAA,MACAC,IAAA,sBAEAC,EAAA,CACAC,IAAA,OACAC,IAAA,QACAC,IAAA,IACAC,KAAA,YACAC,OAAA,cACAC,KAAA,eAGAC,EAAA,SAAAlB,EAAAW,GACA,OAAAvB,EAAA,GAAoBY,EAAAW,IAWpBQ,EAAAC,QAAA,SAAAC,GAmCA,IAlCA,IAAAC,EAAA7B,UAAAC,OAAA,QAAA6B,IAAA9B,UAAA,GAAAA,UAAA,MACA+B,EAAAF,EAAAG,mBACAA,OAAAF,IAAAC,KACAE,EAAAJ,EAAAK,YACAA,OAAAJ,IAAAG,EAAAR,EAAAQ,EAEAE,EAAAC,OAAAR,GACAS,EAAA,GAEAC,EAAAJ,EAAAvC,EAAA,GAAuCY,GAAAyB,EAAArC,EAAA,GAAmDuB,GAAA,IAC1FqB,EAAA3C,OAAA4C,KAAAF,GAMAG,EAAA,WACA,IAAAC,GAAA,EACAH,EAAAI,QAAA,SAAAxC,EAAAyC,GACAF,GAGAP,EAAAlC,QAAAE,EAAAF,QAAAkC,EAAAU,MAAA,EAAA1C,EAAAF,UAAAE,IACAkC,GAAAC,EAAAC,EAAAK,IACAT,IAAAU,MAAA1C,EAAAF,OAAAkC,EAAAlC,QACAyC,GAAA,KAGAA,IACAL,GAAAF,EAAAU,MAAA,KACAV,IAAAU,MAAA,EAAAV,EAAAlC,UAIAkC,GACAM,IAEA,OAAAJ","file":"js/09f7c861b2e748b89032.js","sourcesContent":["\"use strict\";\n\n// Map the characters to escape to their escaped values. The list is derived\n// from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar defaultEscapes = {\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"\\\\\": \"\\\\textbackslash{}\",\n  \"#\": \"\\\\#\",\n  $: \"\\\\$\",\n  \"%\": \"\\\\%\",\n  \"&\": \"\\\\&\",\n  \"^\": \"\\\\textasciicircum{}\",\n  _: \"\\\\_\",\n  \"~\": \"\\\\textasciitilde{}\"\n};\nvar formatEscapes = {\n  \"\\u2013\": \"\\\\--\",\n  \"\\u2014\": \"\\\\---\",\n  \" \": \"~\",\n  \"\\t\": \"\\\\qquad{}\",\n  \"\\r\\n\": \"\\\\newline{}\",\n  \"\\n\": \"\\\\newline{}\"\n};\n\nvar defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {\n  return _extends({}, defaultEscapes, formatEscapes);\n};\n\n/**\n * Escape a string to be used in LaTeX documents.\n * @param {string} str the string to be escaped.\n * @param {boolean} params.preserveFormatting whether formatting escapes should\n *  be performed (default: false).\n * @param {function} params.escapeMapFn the function to modify the escape maps.\n * @return {string} the escaped string, ready to be used in LaTeX.\n */\nmodule.exports = function (str) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$preserveFormatti = _ref.preserveFormatting,\n      preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,\n      _ref$escapeMapFn = _ref.escapeMapFn,\n      escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;\n\n  var runningStr = String(str);\n  var result = \"\";\n\n  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});\n  var escapeKeys = Object.keys(escapes); // as it is reused later on\n\n  // Algorithm: Go through the string character by character, if it matches\n  // with one of the special characters then we'll replace it with the escaped\n  // version.\n\n  var _loop = function _loop() {\n    var specialCharFound = false;\n    escapeKeys.forEach(function (key, index) {\n      if (specialCharFound) {\n        return;\n      }\n      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {\n        result += escapes[escapeKeys[index]];\n        runningStr = runningStr.slice(key.length, runningStr.length);\n        specialCharFound = true;\n      }\n    });\n    if (!specialCharFound) {\n      result += runningStr.slice(0, 1);\n      runningStr = runningStr.slice(1, runningStr.length);\n    }\n  };\n\n  while (runningStr) {\n    _loop();\n  }\n  return result;\n};"],"sourceRoot":""}