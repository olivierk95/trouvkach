{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/fraction.js/fraction.js"],"names":["__WEBPACK_AMD_DEFINE_RESULT__","root","MAX_CYCLE_LEN","P","s","n","d","createError","name","errorConstructor","temp","Error","apply","this","arguments","IntermediateInheritor","prototype","DivisionByZero","Fraction","InvalidParameter","assign","isNaN","parseInt","throwInvalidParam","parse","p1","p2","M","v","w","x","y","z","A","B","C","D","N","undefined","Math","pow","floor","log","LN10","NaN","match","length","abs","gcd","a","b","neg","add","sub","mul","div","clone","mod","lcm","ceil","places","round","inverse","m","equals","compare","t","simplify","eps","cont","rec","slice","i","tmp","valueOf","divisible","toFraction","excludeWhole","whole","str","toLatex","toContinued","res","push","toString","dec","g","cycLen","rem","cycleLen","cycOff","len","rem1","rem2","e","r","modpow","cycleStart","exports","module"],"mappings":"8EAAA,IAAAA;;;;;;;;;;;;;;;CAuCA,SAAAC,GAEA,aAKA,IAAAC,EAAA,IAGAC,EAAA,CACAC,EAAA,EACAC,EAAA,EACAC,EAAA,GAGA,SAAAC,EAAAC,GAEA,SAAAC,IACA,IAAAC,EAAAC,MAAAC,MAAAC,KAAAC,WACAJ,EAAA,KAAAG,KAAA,KAAAL,EACAK,KAAA,MAAAH,EAAA,MACAG,KAAA,QAAAH,EAAA,QAQA,SAAAK,KAIA,OAHAA,EAAAC,UAAAL,MAAAK,UACAP,EAAAO,UAAA,IAAAD,EAEAN,EAGA,IAAAQ,EAAAC,EAAA,eAAAX,EAAA,kBACAY,EAAAD,EAAA,iBAAAX,EAAA,oBAEA,SAAAa,EAAAf,EAAAD,GAKA,OAHAiB,MAAAhB,EAAAiB,SAAAjB,EAAA,MACAkB,IAEAlB,EAAAD,EAGA,SAAAmB,IACA,UAAAJ,EAGA,IAAAK,EAAA,SAAAC,EAAAC,GAEA,IAOAC,EAPAtB,EAAA,EAAAC,EAAA,EAAAF,EAAA,EACAwB,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAEAC,EAAA,EAAAC,EAAA,EACAC,EAAA,EAAAC,EAAA,EAEAC,EAAA,IAGA,GAAAZ,cAEK,QAAAa,IAAAZ,EAGLtB,GAFAC,EAAAoB,IACAnB,EAAAoB,QAGA,cAAAD,GAEA,aAEA,MAAAA,GAAA,MAAAA,GACApB,EAAAoB,EAAA,EACAnB,EAAAmB,EAAA,EACA,MAAAA,IACApB,GAAAoB,EAAA,IACW,KAAAA,GACXpB,EAAAoB,EAAA,GACA,KAAAA,IACAnB,EAAAmB,EAAA,KAEAF,IAEAnB,EAAAC,EAAAC,EACA,MAEA,aAOA,GALAmB,EAAA,IACArB,EAAAqB,EACAA,MAGAA,EAAA,KACApB,EAAAoB,OACW,GAAAA,EAAA,GAUX,IARAA,GAAA,IAEAA,GADAO,EAAAO,KAAAC,IAAA,GAAAD,KAAAE,MAAA,EAAAF,KAAAG,IAAAjB,GAAAc,KAAAI,QAOAT,GAAAG,GAAAD,GAAAC,GAAA,CAGA,GAAAZ,KAFAE,GAAAM,EAAAE,IAAAD,EAAAE,IAEA,CACAF,EAAAE,GAAAC,GACAhC,EAAA4B,EAAAE,EACA7B,EAAA4B,EAAAE,GACiBA,EAAAF,GACjB7B,EAAA8B,EACA7B,EAAA8B,IAEA/B,EAAA4B,EACA3B,EAAA4B,GAEA,MAIAT,EAAAE,GACAM,GAAAE,EACAD,GAAAE,IAEAD,GAAAF,EACAG,GAAAF,GAGAA,EAAAG,GACAhC,EAAA8B,EACA7B,EAAA8B,IAEA/B,EAAA4B,EACA3B,EAAA4B,GAIA7B,GAAA2B,OACWX,MAAAI,IAAAJ,MAAAK,MACXpB,EAAAD,EAAAuC,KAEA,MAEA,aAgDA,GA5CA,QAFAV,EAAAT,EAAAoB,MAAA,YAGAtB,IAEA,MAAAW,EAAAD,IACA7B,GAAA,EACA6B,KACW,MAAAC,EAAAD,IACXA,IAGAC,EAAAY,SAAAb,EAAA,EACAJ,EAAAT,EAAAc,EAAAD,KAAA7B,GACW,MAAA8B,EAAAD,EAAA,UAAAC,EAAAD,IAEX,MAAAC,EAAAD,KACAL,EAAAR,EAAAc,EAAAD,KAAA7B,OAEA6B,EAGA,IAAAC,EAAAY,QAAA,MAAAZ,EAAAD,EAAA,UAAAC,EAAAD,EAAA,UAAAC,EAAAD,EAAA,UAAAC,EAAAD,EAAA,MACAJ,EAAAT,EAAAc,EAAAD,GAAA7B,GACA2B,EAAAQ,KAAAC,IAAA,GAAAN,EAAAD,GAAAa,QACAb,MAIA,MAAAC,EAAAD,IAAA,MAAAC,EAAAD,EAAA,UAAAC,EAAAD,IAAA,MAAAC,EAAAD,EAAA,MACAH,EAAAV,EAAAc,EAAAD,EAAA,GAAA7B,GACA4B,EAAAO,KAAAC,IAAA,GAAAN,EAAAD,EAAA,GAAAa,QAAA,EACAb,GAAA,IAGW,MAAAC,EAAAD,EAAA,UAAAC,EAAAD,EAAA,IACXJ,EAAAT,EAAAc,EAAAD,GAAA7B,GACA2B,EAAAX,EAAAc,EAAAD,EAAA,MACAA,GAAA,GACW,MAAAC,EAAAD,EAAA,UAAAC,EAAAD,EAAA,KACXL,EAAAR,EAAAc,EAAAD,GAAA7B,GACAyB,EAAAT,EAAAc,EAAAD,EAAA,GAAA7B,GACA2B,EAAAX,EAAAc,EAAAD,EAAA,MACAA,GAAA,GAGAC,EAAAY,QAAAb,EAAA,CAEA7B,EACAC,EAAAyB,GAFAxB,EAAAyB,EAAAC,GAEAJ,EAAAI,EAAAH,EACA,MAKA,QACAN,IAGA,OAAAjB,EACA,UAAAW,EAGAd,EAAA,EAAAC,EAAA,OACAD,EAAA,EAAAoC,KAAAQ,IAAA1C,GACAF,EAAA,EAAAoC,KAAAQ,IAAAzC,IAgEA,SAAA0C,EAAAC,EAAAC,GAEA,IAAAD,EACA,OAAAC,EACA,IAAAA,EACA,OAAAD,EAEA,QAEA,KADAA,GAAAC,GAEA,OAAAA,EAEA,KADAA,GAAAD,GAEA,OAAAA,GAWA,SAAA/B,EAAA+B,EAAAC,GAEA,KAAArC,gBAAAK,GACA,WAAAA,EAAA+B,EAAAC,GAGA1B,EAAAyB,EAAAC,GAGAD,EADA/B,EAAA,OACA8B,EAAA7C,EAAA,EAAAA,EAAA,GAEA,EAGAU,KAAA,EAAAV,EAAA,EACAU,KAAA,EAAAV,EAAA,EAAA8C,EACApC,KAAA,EAAAV,EAAA,EAAA8C,EAOA/B,EAAA,SAEAA,EAAAF,UAAA,CAEAZ,EAAA,EACAC,EAAA,EACAC,EAAA,EAOAyC,IAAA,WAEA,WAAA7B,EAAAL,KAAA,EAAAA,KAAA,IAQAsC,IAAA,WAEA,WAAAjC,GAAAL,KAAA,EAAAA,KAAA,EAAAA,KAAA,IAQAuC,IAAA,SAAAH,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,GACA,IAAAhC,EACAL,KAAA,EAAAA,KAAA,EAAAV,EAAA,EAAAA,EAAA,EAAAU,KAAA,EAAAV,EAAA,EACAU,KAAA,EAAAV,EAAA,IASAkD,IAAA,SAAAJ,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,GACA,IAAAhC,EACAL,KAAA,EAAAA,KAAA,EAAAV,EAAA,EAAAA,EAAA,EAAAU,KAAA,EAAAV,EAAA,EACAU,KAAA,EAAAV,EAAA,IASAmD,IAAA,SAAAL,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,GACA,IAAAhC,EACAL,KAAA,EAAAV,EAAA,EAAAU,KAAA,EAAAV,EAAA,EACAU,KAAA,EAAAV,EAAA,IASAoD,IAAA,SAAAN,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,GACA,IAAAhC,EACAL,KAAA,EAAAV,EAAA,EAAAU,KAAA,EAAAV,EAAA,EACAU,KAAA,EAAAV,EAAA,IASAqD,MAAA,WACA,WAAAtC,EAAAL,OAQA4C,IAAA,SAAAR,EAAAC,GAEA,OAAA7B,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,IAAAK,EAAA0B,UAGAN,IAAAW,EACA,IAAA/B,EAAAL,KAAA,EAAAA,KAAA,EAAAA,KAAA,MAGAW,EAAAyB,EAAAC,GACA,IAAA/C,EAAA,OAAAU,KAAA,GACAK,EAAA,KAiBA,IAAAA,EACAL,KAAA,GAAAV,EAAA,EAAAU,KAAA,IAAAV,EAAA,EAAAU,KAAA,GACAV,EAAA,EAAAU,KAAA,KASAmC,IAAA,SAAAC,EAAAC,GAMA,OAJA1B,EAAAyB,EAAAC,GAIA,IAAAhC,EAAA8B,EAAA7C,EAAA,EAAAU,KAAA,GAAAmC,EAAA7C,EAAA,EAAAU,KAAA,GAAAV,EAAA,EAAAU,KAAA,IAQA6C,IAAA,SAAAT,EAAAC,GAMA,OAJA1B,EAAAyB,EAAAC,GAIA,IAAA/C,EAAA,OAAAU,KAAA,EACA,IAAAK,EAEA,IAAAA,EAAAf,EAAA,EAAAU,KAAA,EAAAmC,EAAA7C,EAAA,EAAAU,KAAA,GAAAmC,EAAA7C,EAAA,EAAAU,KAAA,KAQA8C,KAAA,SAAAC,GAIA,OAFAA,EAAArB,KAAAC,IAAA,GAAAoB,GAAA,GAEAvC,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,IAAAK,EAAA0B,KAEA,IAAA1B,EAAAqB,KAAAoB,KAAAC,EAAA/C,KAAA,EAAAA,KAAA,EAAAA,KAAA,GAAA+C,IAQAnB,MAAA,SAAAmB,GAIA,OAFAA,EAAArB,KAAAC,IAAA,GAAAoB,GAAA,GAEAvC,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,IAAAK,EAAA0B,KAEA,IAAA1B,EAAAqB,KAAAE,MAAAmB,EAAA/C,KAAA,EAAAA,KAAA,EAAAA,KAAA,GAAA+C,IAQAC,MAAA,SAAAD,GAIA,OAFAA,EAAArB,KAAAC,IAAA,GAAAoB,GAAA,GAEAvC,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,IAAAK,EAAA0B,KAEA,IAAA1B,EAAAqB,KAAAsB,MAAAD,EAAA/C,KAAA,EAAAA,KAAA,EAAAA,KAAA,GAAA+C,IAQAE,QAAA,WAEA,WAAA5C,EAAAL,KAAA,EAAAA,KAAA,EAAAA,KAAA,IAQA2B,IAAA,SAAAuB,GAEA,OAAAA,EAAA,EACA,IAAA7C,EAAAqB,KAAAC,IAAA3B,KAAA,EAAAA,KAAA,GAAAkD,GAAAxB,KAAAC,IAAA3B,KAAA,GAAAkD,IAEA,IAAA7C,EAAAqB,KAAAC,IAAA3B,KAAA,EAAAA,KAAA,EAAAkD,GAAAxB,KAAAC,IAAA3B,KAAA,EAAAkD,KASAC,OAAA,SAAAf,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,GACArC,KAAA,EAAAA,KAAA,EAAAV,EAAA,GAAAA,EAAA,EAAAA,EAAA,EAAAU,KAAA,GAQAoD,QAAA,SAAAhB,EAAAC,GAEA1B,EAAAyB,EAAAC,GACA,IAAAgB,EAAArD,KAAA,EAAAA,KAAA,EAAAV,EAAA,EAAAA,EAAA,EAAAA,EAAA,EAAAU,KAAA,EACA,SAAAqD,MAAA,IAGAC,SAAA,SAAAC,GAIA,GAAA/C,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,OAAAA,KAGA,IAAAwD,EAAAxD,KAAA,oBAIA,SAAAyD,EAAArB,GACA,WAAAA,EAAAH,OACA,IAAA5B,EAAA+B,EAAA,IACAqB,EAAArB,EAAAsB,MAAA,kBAAAtB,EAAA,IALAmB,KAAA,KAQA,QAAAI,EAAA,EAAqBA,EAAAH,EAAAvB,OAAiB0B,IAAA,CACtC,IAAAC,EAAAH,EAAAD,EAAAE,MAAA,EAAAC,EAAA,IACA,GAAAC,EAAA,IAAA5D,KAAA,aAAA6D,UAAAN,EACA,OAAAK,EAAA,IAAA5D,KAAA,GAGA,OAAAA,MAQA8D,UAAA,SAAA1B,EAAAC,GAGA,OADA1B,EAAAyB,EAAAC,OACA/C,EAAA,EAAAU,KAAA,IAAAA,KAAA,EAAAV,EAAA,GAAAA,EAAA,EAAAU,KAAA,KAQA6D,QAAA,WAEA,OAAA7D,KAAA,EAAAA,KAAA,EAAAA,KAAA,GAQA+D,WAAA,SAAAC,GAEA,IAAAC,EAAAC,EAAA,GACA1E,EAAAQ,KAAA,EACAP,EAAAO,KAAA,EAmBA,OAlBAA,KAAA,MACAkE,GAAA,KAGA,IAAAzE,EACAyE,GAAA1E,GAGAwE,IAAAC,EAAAvC,KAAAE,MAAApC,EAAAC,IAAA,IACAyE,GAAAD,EACAC,GAAA,IACA1E,GAAAC,GAGAyE,GAAA1E,EACA0E,GAAA,IACAA,GAAAzE,GAEAyE,GAQAC,QAAA,SAAAH,GAEA,IAAAC,EAAAC,EAAA,GACA1E,EAAAQ,KAAA,EACAP,EAAAO,KAAA,EAoBA,OAnBAA,KAAA,MACAkE,GAAA,KAGA,IAAAzE,EACAyE,GAAA1E,GAGAwE,IAAAC,EAAAvC,KAAAE,MAAApC,EAAAC,IAAA,IACAyE,GAAAD,EACAzE,GAAAC,GAGAyE,GAAA,UACAA,GAAA1E,EACA0E,GAAA,KACAA,GAAAzE,EACAyE,GAAA,KAEAA,GAQAE,YAAA,WAEA,IAAAf,EACAjB,EAAApC,KAAA,EACAqC,EAAArC,KAAA,EACAqE,EAAA,GAEA,GAAA7D,MAAAR,KAAA,IAAAQ,MAAAR,KAAA,GACA,OAAAqE,EAGA,GACAA,EAAAC,KAAA5C,KAAAE,MAAAQ,EAAAC,IACAgB,EAAAjB,EAAAC,EACAD,EAAAC,EACAA,EAAAgB,QACO,IAAAjB,GAEP,OAAAiC,GAQAE,SAAA,SAAAC,GAEA,IAAAC,EACAjD,EAAAxB,KAAA,EACAuB,EAAAvB,KAAA,EAEA,GAAAQ,MAAAgB,IAAAhB,MAAAe,GACA,YAGAlB,EAAA,SAEAmB,GADAiD,EAAAtC,EAAAX,EAAAD,GAEAA,GAAAkD,GAGAD,KAAA,GAEA,IAAAE,EA/fA,SAAAlF,EAAAC,GAEA,KAAUA,EAAA,KACVA,GAAA,GAGA,KAAUA,EAAA,KACVA,GAAA,GAGA,OAAAA,EACA,SAUA,IAHA,IAAAkF,EAAA,GAAAlF,EACA4D,EAAA,EAEU,IAAAsB,EAAWtB,IAGrB,GAFAsB,EAAA,GAAAA,EAAAlF,EAEA4D,EAAAhE,EACA,SAEA,OAAAgE,EAoeAuB,CAAApD,EAAAD,GACAsD,EAjeA,SAAArF,EAAAC,EAAAqF,GAKA,IAHA,IAAAC,EAAA,EACAC,EA/CA,SAAA3C,EAAA4C,EAAA/B,GAGA,IADA,IAAAgC,EAAA,EACUD,EAAA,EAAO5C,MAAAa,EAAA+B,IAAA,EAEjB,EAAAA,IACAC,IAAA7C,EAAAa,GAGA,OAAAgC,EAsCAC,CAAA,GAAAL,EAAArF,GAEA4D,EAAA,EAAmBA,EAAA,IAASA,IAAA,CAG5B,GAAA0B,IAAAC,EACA,OAAA3B,EAEA0B,EAAA,GAAAA,EAAAtF,EACAuF,EAAA,GAAAA,EAAAvF,EAEA,SAmdA2F,CAAA5D,EAAAD,EAAAmD,GAEAR,GAAA,IAAAlE,KAAA,SAUA,GARAkE,GAAA1C,EAAAD,EAAA,EAEAC,GAAAD,GACAC,GAAA,MAGA0C,GAAA,KAEAQ,EAAA,CAEA,QAAAf,EAAAkB,EAA4BlB,KAC5BO,GAAA1C,EAAAD,EAAA,EACAC,GAAAD,EACAC,GAAA,GAEA0C,GAAA,IACA,IAAAP,EAAAe,EAA4Bf,KAC5BO,GAAA1C,EAAAD,EAAA,EACAC,GAAAD,EACAC,GAAA,GAEA0C,GAAA,SAEA,IAAAP,EAAAa,EAAyBhD,GAAAmC,KACzBO,GAAA1C,EAAAD,EAAA,EACAC,GAAAD,EACAC,GAAA,GAGA,OAAA0C,SAOKzC,KAFQtC,EAAA,WACb,OAAAkB,GACKN,MAAAsF,EAFM,OAENC,EAAAD,QAAAlG,GAhxBL","file":"js/ba05a1334c679aed7c4e.js","sourcesContent":["/**\n * @license Fraction.js v4.0.12 09/09/2015\n * http://www.xarg.org/2014/03/rational-numbers-in-javascript/\n *\n * Copyright (c) 2015, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <nominator>, 1 => <denominator> ]\n * [ n => <nominator>, d => <denominator> ]\n *\n * Integer form\n * - Single integer value\n *\n * Double form\n * - Single double value\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n *\n * var f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n(function(root) {\n\n  \"use strict\";\n\n  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\n  var MAX_CYCLE_LEN = 2000;\n\n  // Parsed data to avoid calling \"new\" all the time\n  var P = {\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1\n  };\n\n  function createError(name) {\n\n    function errorConstructor() {\n      var temp = Error.apply(this, arguments);\n      temp['name'] = this['name'] = name;\n      this['stack'] = temp['stack'];\n      this['message'] = temp['message'];\n    }\n\n    /**\n     * Error constructor\n     *\n     * @constructor\n     */\n    function IntermediateInheritor() {}\n    IntermediateInheritor.prototype = Error.prototype;\n    errorConstructor.prototype = new IntermediateInheritor();\n\n    return errorConstructor;\n  }\n\n  var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');\n  var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');\n\n  function assign(n, s) {\n\n    if (isNaN(n = parseInt(n, 10))) {\n      throwInvalidParam();\n    }\n    return n * s;\n  }\n\n  function throwInvalidParam() {\n    throw new InvalidParameter();\n  }\n\n  var parse = function(p1, p2) {\n\n    var n = 0, d = 1, s = 1;\n    var v = 0, w = 0, x = 0, y = 1, z = 1;\n\n    var A = 0, B = 1;\n    var C = 1, D = 1;\n\n    var N = 10000000;\n    var M;\n\n    if (p1 === undefined || p1 === null) {\n      /* void */\n    } else if (p2 !== undefined) {\n      n = p1;\n      d = p2;\n      s = n * d;\n    } else\n      switch (typeof p1) {\n\n        case \"object\":\n        {\n          if (\"d\" in p1 && \"n\" in p1) {\n            n = p1[\"n\"];\n            d = p1[\"d\"];\n            if (\"s\" in p1)\n              n *= p1[\"s\"];\n          } else if (0 in p1) {\n            n = p1[0];\n            if (1 in p1)\n              d = p1[1];\n          } else {\n            throwInvalidParam();\n          }\n          s = n * d;\n          break;\n        }\n        case \"number\":\n        {\n          if (p1 < 0) {\n            s = p1;\n            p1 = -p1;\n          }\n\n          if (p1 % 1 === 0) {\n            n = p1;\n          } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow\n\n            if (p1 >= 1) {\n              z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));\n              p1 /= z;\n            }\n\n            // Using Farey Sequences\n            // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/\n\n            while (B <= N && D <= N) {\n              M = (A + C) / (B + D);\n\n              if (p1 === M) {\n                if (B + D <= N) {\n                  n = A + C;\n                  d = B + D;\n                } else if (D > B) {\n                  n = C;\n                  d = D;\n                } else {\n                  n = A;\n                  d = B;\n                }\n                break;\n\n              } else {\n\n                if (p1 > M) {\n                  A += C;\n                  B += D;\n                } else {\n                  C += A;\n                  D += B;\n                }\n\n                if (B > N) {\n                  n = C;\n                  d = D;\n                } else {\n                  n = A;\n                  d = B;\n                }\n              }\n            }\n            n *= z;\n          } else if (isNaN(p1) || isNaN(p2)) {\n            d = n = NaN;\n          }\n          break;\n        }\n        case \"string\":\n        {\n          B = p1.match(/\\d+|./g);\n\n          if (B === null)\n            throwInvalidParam();\n\n          if (B[A] === '-') {// Check for minus sign at the beginning\n            s = -1;\n            A++;\n          } else if (B[A] === '+') {// Check for plus sign at the beginning\n            A++;\n          }\n\n          if (B.length === A + 1) { // Check if it's just a simple number \"1234\"\n            w = assign(B[A++], s);\n          } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number\n\n            if (B[A] !== '.') { // Handle 0.5 and .5\n              v = assign(B[A++], s);\n            }\n            A++;\n\n            // Check for decimal places\n            if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === \"'\" && B[A + 3] === \"'\") {\n              w = assign(B[A], s);\n              y = Math.pow(10, B[A].length);\n              A++;\n            }\n\n            // Check for repeating places\n            if (B[A] === '(' && B[A + 2] === ')' || B[A] === \"'\" && B[A + 2] === \"'\") {\n              x = assign(B[A + 1], s);\n              z = Math.pow(10, B[A + 1].length) - 1;\n              A += 3;\n            }\n\n          } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n            w = assign(B[A], s);\n            y = assign(B[A + 2], 1);\n            A += 3;\n          } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n            v = assign(B[A], s);\n            w = assign(B[A + 2], s);\n            y = assign(B[A + 4], 1);\n            A += 5;\n          }\n\n          if (B.length <= A) { // Check for more tokens on the stack\n            d = y * z;\n            s = /* void */\n                    n = x + d * v + z * w;\n            break;\n          }\n\n          /* Fall through on error */\n        }\n        default:\n          throwInvalidParam();\n      }\n\n    if (d === 0) {\n      throw new DivisionByZero();\n    }\n\n    P[\"s\"] = s < 0 ? -1 : 1;\n    P[\"n\"] = Math.abs(n);\n    P[\"d\"] = Math.abs(d);\n  };\n\n  function modpow(b, e, m) {\n\n    var r = 1;\n    for (; e > 0; b = (b * b) % m, e >>= 1) {\n\n      if (e & 1) {\n        r = (r * b) % m;\n      }\n    }\n    return r;\n  }\n\n\n  function cycleLen(n, d) {\n\n    for (; d % 2 === 0;\n            d /= 2) {\n    }\n\n    for (; d % 5 === 0;\n            d /= 5) {\n    }\n\n    if (d === 1) // Catch non-cyclic numbers\n      return 0;\n\n    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n    // 10^(d-1) % d == 1\n    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n    // as we want to translate the numbers to strings.\n\n    var rem = 10 % d;\n    var t = 1;\n\n    for (; rem !== 1; t++) {\n      rem = rem * 10 % d;\n\n      if (t > MAX_CYCLE_LEN)\n        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n    }\n    return t;\n  }\n\n\n     function cycleStart(n, d, len) {\n\n    var rem1 = 1;\n    var rem2 = modpow(10, len, d);\n\n    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n      // Solve 10^s == 10^(s+t) (mod d)\n\n      if (rem1 === rem2)\n        return t;\n\n      rem1 = rem1 * 10 % d;\n      rem2 = rem2 * 10 % d;\n    }\n    return 0;\n  }\n\n  function gcd(a, b) {\n\n    if (!a)\n      return b;\n    if (!b)\n      return a;\n\n    while (1) {\n      a %= b;\n      if (!a)\n        return b;\n      b %= a;\n      if (!b)\n        return a;\n    }\n  };\n\n  /**\n   * Module constructor\n   *\n   * @constructor\n   * @param {number|Fraction=} a\n   * @param {number=} b\n   */\n  function Fraction(a, b) {\n\n    if (!(this instanceof Fraction)) {\n      return new Fraction(a, b);\n    }\n\n    parse(a, b);\n\n    if (Fraction['REDUCE']) {\n      a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    } else {\n      a = 1;\n    }\n\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  }\n\n  /**\n   * Boolean global variable to be able to disable automatic reduction of the fraction\n   *\n   */\n  Fraction['REDUCE'] = 1;\n\n  Fraction.prototype = {\n\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1,\n\n    /**\n     * Calculates the absolute value\n     *\n     * Ex: new Fraction(-4).abs() => 4\n     **/\n    \"abs\": function() {\n\n      return new Fraction(this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Inverts the sign of the current fraction\n     *\n     * Ex: new Fraction(-4).neg() => 4\n     **/\n    \"neg\": function() {\n\n      return new Fraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Adds two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n     **/\n    \"add\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n              this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n              this[\"d\"] * P[\"d\"]\n              );\n    },\n\n    /**\n     * Subtracts two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n     **/\n    \"sub\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n              this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n              this[\"d\"] * P[\"d\"]\n              );\n    },\n\n    /**\n     * Multiplies two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n     **/\n    \"mul\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n              this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n              this[\"d\"] * P[\"d\"]\n              );\n    },\n\n    /**\n     * Divides two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n     **/\n    \"div\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n              this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n              this[\"d\"] * P[\"n\"]\n              );\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * Ex: new Fraction(\"-17.(345)\").clone()\n     **/\n    \"clone\": function() {\n      return new Fraction(this);\n    },\n\n    /**\n     * Calculates the modulo of two rational numbers - a more precise fmod\n     *\n     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n     **/\n    \"mod\": function(a, b) {\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return new Fraction(NaN);\n      }\n\n      if (a === undefined) {\n        return new Fraction(this[\"s\"] * this[\"n\"] % this[\"d\"], 1);\n      }\n\n      parse(a, b);\n      if (0 === P[\"n\"] && 0 === this[\"d\"]) {\n        Fraction(0, 0); // Throw DivisionByZero\n      }\n\n      /*\n       * First silly attempt, kinda slow\n       *\n       return that[\"sub\"]({\n       \"n\": num[\"n\"] * Math.floor((this.n / this.d) / (num.n / num.d)),\n       \"d\": num[\"d\"],\n       \"s\": this[\"s\"]\n       });*/\n\n      /*\n       * New attempt: a1 / b1 = a2 / b2 * q + r\n       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r\n       * => (b2 * a1 % a2 * b1) / (b1 * b2)\n       */\n      return new Fraction(\n              this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n              P[\"d\"] * this[\"d\"]\n              );\n    },\n\n    /**\n     * Calculates the fractional gcd of two rational numbers\n     *\n     * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n     */\n    \"gcd\": function(a, b) {\n\n      parse(a, b);\n\n      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n      return new Fraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n    },\n\n    /**\n     * Calculates the fractional lcm of two rational numbers\n     *\n     * Ex: new Fraction(5,8).lcm(3,7) => 15\n     */\n    \"lcm\": function(a, b) {\n\n      parse(a, b);\n\n      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n      if (P[\"n\"] === 0 && this[\"n\"] === 0) {\n        return new Fraction;\n      }\n      return new Fraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n    },\n\n    /**\n     * Calculates the ceil of a rational number\n     *\n     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n     **/\n    \"ceil\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.ceil(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Calculates the floor of a rational number\n     *\n     * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n     **/\n    \"floor\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.floor(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Rounds a rational numbers\n     *\n     * Ex: new Fraction('4.(3)').round() => (4 / 1)\n     **/\n    \"round\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.round(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Gets the inverse of the fraction, means numerator and denumerator are exchanged\n     *\n     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n     **/\n    \"inverse\": function() {\n\n      return new Fraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n    },\n\n    /**\n     * Calculates the fraction to some integer exponent\n     *\n     * Ex: new Fraction(-1,2).pow(-3) => -8\n     */\n    \"pow\": function(m) {\n\n      if (m < 0) {\n        return new Fraction(Math.pow(this['s'] * this[\"d\"], -m), Math.pow(this[\"n\"], -m));\n      } else {\n        return new Fraction(Math.pow(this['s'] * this[\"n\"], m), Math.pow(this[\"d\"], m));\n      }\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"equals\": function(a, b) {\n\n      parse(a, b);\n      return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"]; // Same as compare() === 0\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"compare\": function(a, b) {\n\n      parse(a, b);\n      var t = (this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"]);\n      return (0 < t) - (t < 0);\n    },\n\n    \"simplify\": function(eps) {\n\n      // First naive implementation, needs improvement\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return this;\n      }\n\n      var cont = this['abs']()['toContinued']();\n\n      eps = eps || 0.001;\n\n      function rec(a) {\n        if (a.length === 1)\n          return new Fraction(a[0]);\n        return rec(a.slice(1))['inverse']()['add'](a[0]);\n      }\n\n      for (var i = 0; i < cont.length; i++) {\n        var tmp = rec(cont.slice(0, i + 1));\n        if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {\n          return tmp['mul'](this['s']);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Check if two rational numbers are divisible\n     *\n     * Ex: new Fraction(19.6).divisible(1.5);\n     */\n    \"divisible\": function(a, b) {\n\n      parse(a, b);\n      return !(!(P[\"n\"] * this[\"d\"]) || ((this[\"n\"] * P[\"d\"]) % (P[\"n\"] * this[\"d\"])));\n    },\n\n    /**\n     * Returns a decimal representation of the fraction\n     *\n     * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n     **/\n    'valueOf': function() {\n\n      return this[\"s\"] * this[\"n\"] / this[\"d\"];\n    },\n\n    /**\n     * Returns a string-fraction representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n     **/\n    'toFraction': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          str += \" \";\n          n %= d;\n        }\n\n        str += n;\n        str += '/';\n        str += d;\n      }\n      return str;\n    },\n\n    /**\n     * Returns a latex representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n     **/\n    'toLatex': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          n %= d;\n        }\n\n        str += \"\\\\frac{\";\n        str += n;\n        str += '}{';\n        str += d;\n        str += '}';\n      }\n      return str;\n    },\n\n    /**\n     * Returns an array of continued fraction elements\n     *\n     * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n     */\n    'toContinued': function() {\n\n      var t;\n      var a = this['n'];\n      var b = this['d'];\n      var res = [];\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return res;\n      }\n\n      do {\n        res.push(Math.floor(a / b));\n        t = a % b;\n        a = b;\n        b = t;\n      } while (a !== 1);\n\n      return res;\n    },\n\n    /**\n     * Creates a string representation of a fraction with all digits\n     *\n     * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n     **/\n    'toString': function(dec) {\n\n      var g;\n      var N = this[\"n\"];\n      var D = this[\"d\"];\n\n      if (isNaN(N) || isNaN(D)) {\n        return \"NaN\";\n      }\n\n      if (!Fraction['REDUCE']) {\n        g = gcd(N, D);\n        N /= g;\n        D /= g;\n      }\n\n      dec = dec || 15; // 15 = decimal places when no repitation\n\n      var cycLen = cycleLen(N, D); // Cycle length\n      var cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n      var str = this['s'] === -1 ? \"-\" : \"\";\n\n      str += N / D | 0;\n\n      N %= D;\n      N *= 10;\n\n      if (N)\n        str += \".\";\n\n      if (cycLen) {\n\n        for (var i = cycOff; i--; ) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \"(\";\n        for (var i = cycLen; i--; ) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \")\";\n      } else {\n        for (var i = dec; N && i--; ) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n      }\n      return str;\n    }\n  };\n\n  if (typeof define === \"function\" && define[\"amd\"]) {\n    define([], function() {\n      return Fraction;\n    });\n  } else if (typeof exports === \"object\") {\n    Object.defineProperty(exports, \"__esModule\", {'value': true});\n    Fraction['default'] = Fraction;\n    Fraction['Fraction'] = Fraction;\n    module['exports'] = Fraction;\n  } else {\n    root['Fraction'] = Fraction;\n  }\n\n})(this);\n"],"sourceRoot":""}