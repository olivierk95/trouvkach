{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm05.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm06.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/type/matrix/utils/algorithm04.js"],"names":["DimensionError","__webpack_require__","exports","name","factory","type","config","load","typed","equalScalar","SparseMatrix","a","b","callback","avalues","_values","aindex","_index","aptr","_ptr","asize","_size","adt","_datatype","bvalues","bindex","bptr","bsize","bdt","length","RangeError","dt","rows","columns","eq","zero","cf","find","convert","i","j","k","k1","cvalues","undefined","cindex","cptr","c","values","index","ptr","size","datatype","xa","xb","wa","wb","mark","push","wai","wbi","vc","splice","scatter","x","w","u","v","p","k0"],"mappings":"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","file":"js/bf9284fbcef71a29c8c8.js","sourcesContent":["'use strict';\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var equalScalar = load(require('../../../function/relational/equalScalar'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).\n   * Callback function invoked MAX(NNZA, NNZB) times\n   *\n   *\n   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0\n   * C(i,j) = ┤\n   *          └  0            ; otherwise\n   *\n   *\n   * @param {Matrix}   a                 The SparseMatrix instance (A)\n   * @param {Matrix}   b                 The SparseMatrix instance (B)\n   * @param {Function} callback          The f(Aij,Bij) operation to invoke\n   *\n   * @return {Matrix}                    SparseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294\n   */\n\n  var algorithm05 = function algorithm05(a, b, callback) {\n    // sparse matrix arrays\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var asize = a._size;\n    var adt = a._datatype; // sparse matrix arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // datatype\n\n    var dt; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // callback signature to use\n\n    var cf = callback; // process data types\n\n    if (typeof adt === 'string' && adt === bdt) {\n      // datatype\n      dt = adt; // find signature that matches (dt, dt)\n\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt); // callback\n\n      cf = typed.find(callback, [dt, dt]);\n    } // result arrays\n\n\n    var cvalues = avalues && bvalues ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [rows, columns],\n      datatype: dt\n    }); // workspaces\n\n    var xa = cvalues ? [] : undefined;\n    var xb = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column\n\n    var wa = [];\n    var wb = []; // vars\n\n    var i, j, k, k1; // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // update cptr\n      cptr[j] = cindex.length; // columns mark\n\n      var mark = j + 1; // loop values A(:,j)\n\n      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {\n        // row\n        i = aindex[k]; // push index\n\n        cindex.push(i); // update workspace\n\n        wa[i] = mark; // check we need to process values\n\n        if (xa) {\n          xa[i] = avalues[k];\n        }\n      } // loop values B(:,j)\n\n\n      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {\n        // row\n        i = bindex[k]; // check row existed in A\n\n        if (wa[i] !== mark) {\n          // push index\n          cindex.push(i);\n        } // update workspace\n\n\n        wb[i] = mark; // check we need to process values\n\n        if (xb) {\n          xb[i] = bvalues[k];\n        }\n      } // check we need to process values (non pattern matrix)\n\n\n      if (cvalues) {\n        // initialize first index in j\n        k = cptr[j]; // loop index in j\n\n        while (k < cindex.length) {\n          // row\n          i = cindex[k]; // marks\n\n          var wai = wa[i];\n          var wbi = wb[i]; // check Aij or Bij are nonzero\n\n          if (wai === mark || wbi === mark) {\n            // matrix values @ i,j\n            var va = wai === mark ? xa[i] : zero;\n            var vb = wbi === mark ? xb[i] : zero; // Cij\n\n            var vc = cf(va, vb); // check for zero\n\n            if (!eq(vc, zero)) {\n              // push value\n              cvalues.push(vc); // increment pointer\n\n              k++;\n            } else {\n              // remove value @ i, do not increment pointer\n              cindex.splice(k, 1);\n            }\n          }\n        }\n      }\n    } // update cptr\n\n\n    cptr[columns] = cindex.length; // return sparse matrix\n\n    return c;\n  };\n\n  return algorithm05;\n}\n\nexports.name = 'algorithm05';\nexports.factory = factory;","'use strict';\n\nvar scatter = require('./../../../utils/collection/scatter');\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var equalScalar = load(require('../../../function/relational/equalScalar'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).\n   * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.\n   *\n   *\n   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0\n   * C(i,j) = ┤\n   *          └  0            ; otherwise\n   *\n   *\n   * @param {Matrix}   a                 The SparseMatrix instance (A)\n   * @param {Matrix}   b                 The SparseMatrix instance (B)\n   * @param {Function} callback          The f(Aij,Bij) operation to invoke\n   *\n   * @return {Matrix}                    SparseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294\n   */\n\n  var algorithm06 = function algorithm06(a, b, callback) {\n    // sparse matrix arrays\n    var avalues = a._values;\n    var asize = a._size;\n    var adt = a._datatype; // sparse matrix arrays\n\n    var bvalues = b._values;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // datatype\n\n    var dt; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // callback signature to use\n\n    var cf = callback; // process data types\n\n    if (typeof adt === 'string' && adt === bdt) {\n      // datatype\n      dt = adt; // find signature that matches (dt, dt)\n\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt); // callback\n\n      cf = typed.find(callback, [dt, dt]);\n    } // result arrays\n\n\n    var cvalues = avalues && bvalues ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [rows, columns],\n      datatype: dt\n    }); // workspaces\n\n    var x = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column\n\n    var w = []; // marks indicating value in a given row has been updated\n\n    var u = []; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // update cptr\n      cptr[j] = cindex.length; // columns mark\n\n      var mark = j + 1; // scatter the values of A(:,j) into workspace\n\n      scatter(a, j, w, x, u, mark, c, cf); // scatter the values of B(:,j) into workspace\n\n      scatter(b, j, w, x, u, mark, c, cf); // check we need to process values (non pattern matrix)\n\n      if (x) {\n        // initialize first index in j\n        var k = cptr[j]; // loop index in j\n\n        while (k < cindex.length) {\n          // row\n          var i = cindex[k]; // check function was invoked on current row (Aij !=0 && Bij != 0)\n\n          if (u[i] === mark) {\n            // value @ i\n            var v = x[i]; // check for zero value\n\n            if (!eq(v, zero)) {\n              // push value\n              cvalues.push(v); // increment pointer\n\n              k++;\n            } else {\n              // remove value @ i, do not increment pointer\n              cindex.splice(k, 1);\n            }\n          } else {\n            // remove value @ i, do not increment pointer\n            cindex.splice(k, 1);\n          }\n        }\n      } else {\n        // initialize first index in j\n        var p = cptr[j]; // loop index in j\n\n        while (p < cindex.length) {\n          // row\n          var r = cindex[p]; // check function was invoked on current row (Aij !=0 && Bij != 0)\n\n          if (u[r] !== mark) {\n            // remove value @ i, do not increment pointer\n            cindex.splice(p, 1);\n          } else {\n            // increment pointer\n            p++;\n          }\n        }\n      }\n    } // update cptr\n\n\n    cptr[columns] = cindex.length; // return sparse matrix\n\n    return c;\n  };\n\n  return algorithm06;\n}\n\nexports.name = 'algorithm06';\nexports.factory = factory;","'use strict';\n\nvar DimensionError = require('../../../error/DimensionError');\n\nfunction factory(type, config, load, typed) {\n  var equalScalar = load(require('../../../function/relational/equalScalar'));\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).\n   * Callback function invoked MAX(NNZA, NNZB) times\n   *\n   *\n   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0\n   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0\n   *          └  B(i,j)       ; B(i,j) !== 0\n   *\n   *\n   * @param {Matrix}   a                 The SparseMatrix instance (A)\n   * @param {Matrix}   b                 The SparseMatrix instance (B)\n   * @param {Function} callback          The f(Aij,Bij) operation to invoke\n   *\n   * @return {Matrix}                    SparseMatrix (C)\n   *\n   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294\n   */\n\n  var algorithm04 = function algorithm04(a, b, callback) {\n    // sparse matrix arrays\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var asize = a._size;\n    var adt = a._datatype; // sparse matrix arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate dimensions\n\n    if (asize.length !== bsize.length) {\n      throw new DimensionError(asize.length, bsize.length);\n    } // check rows & columns\n\n\n    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {\n      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');\n    } // rows & columns\n\n\n    var rows = asize[0];\n    var columns = asize[1]; // datatype\n\n    var dt; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // callback signature to use\n\n    var cf = callback; // process data types\n\n    if (typeof adt === 'string' && adt === bdt) {\n      // datatype\n      dt = adt; // find signature that matches (dt, dt)\n\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt); // callback\n\n      cf = typed.find(callback, [dt, dt]);\n    } // result arrays\n\n\n    var cvalues = avalues && bvalues ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [rows, columns],\n      datatype: dt\n    }); // workspace\n\n    var xa = avalues && bvalues ? [] : undefined;\n    var xb = avalues && bvalues ? [] : undefined; // marks indicating we have a value in x for a given column\n\n    var wa = [];\n    var wb = []; // vars\n\n    var i, j, k, k0, k1; // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // update cptr\n      cptr[j] = cindex.length; // columns mark\n\n      var mark = j + 1; // loop A(:,j)\n\n      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n        // row\n        i = aindex[k]; // update c\n\n        cindex.push(i); // update workspace\n\n        wa[i] = mark; // check we need to process values\n\n        if (xa) {\n          xa[i] = avalues[k];\n        }\n      } // loop B(:,j)\n\n\n      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {\n        // row\n        i = bindex[k]; // check row exists in A\n\n        if (wa[i] === mark) {\n          // update record in xa @ i\n          if (xa) {\n            // invoke callback\n            var v = cf(xa[i], bvalues[k]); // check for zero\n\n            if (!eq(v, zero)) {\n              // update workspace\n              xa[i] = v;\n            } else {\n              // remove mark (index will be removed later)\n              wa[i] = null;\n            }\n          }\n        } else {\n          // update c\n          cindex.push(i); // update workspace\n\n          wb[i] = mark; // check we need to process values\n\n          if (xb) {\n            xb[i] = bvalues[k];\n          }\n        }\n      } // check we need to process values (non pattern matrix)\n\n\n      if (xa && xb) {\n        // initialize first index in j\n        k = cptr[j]; // loop index in j\n\n        while (k < cindex.length) {\n          // row\n          i = cindex[k]; // check workspace has value @ i\n\n          if (wa[i] === mark) {\n            // push value (Aij != 0 || (Aij != 0 && Bij != 0))\n            cvalues[k] = xa[i]; // increment pointer\n\n            k++;\n          } else if (wb[i] === mark) {\n            // push value (bij != 0)\n            cvalues[k] = xb[i]; // increment pointer\n\n            k++;\n          } else {\n            // remove index @ k\n            cindex.splice(k, 1);\n          }\n        }\n      }\n    } // update cptr\n\n\n    cptr[columns] = cindex.length; // return sparse matrix\n\n    return c;\n  };\n\n  return algorithm04;\n}\n\nexports.name = 'algorithm04';\nexports.factory = factory;"],"sourceRoot":""}