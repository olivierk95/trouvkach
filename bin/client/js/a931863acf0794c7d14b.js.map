{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/operators.js"],"names":["properties","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","OperatorNode:or","associativity","associativeWith","OperatorNode:xor","OperatorNode:and","OperatorNode:bitOr","OperatorNode:bitXor","OperatorNode:bitAnd","OperatorNode:equal","OperatorNode:unequal","OperatorNode:smaller","OperatorNode:larger","OperatorNode:smallerEq","OperatorNode:largerEq","RelationalNode","OperatorNode:leftShift","OperatorNode:rightArithShift","OperatorNode:rightLogShift","OperatorNode:to","RangeNode","OperatorNode:add","OperatorNode:subtract","OperatorNode:multiply","OperatorNode:divide","OperatorNode:dotMultiply","OperatorNode:dotDivide","OperatorNode:mod","OperatorNode:unaryPlus","OperatorNode:unaryMinus","OperatorNode:bitNot","OperatorNode:not","OperatorNode:pow","OperatorNode:dotPow","OperatorNode:factorial","OperatorNode:transpose","getPrecedence","_node","parenthesis","node","getContent","identifier","getIdentifier","i","length","module","exports","getAssociativity","index","property","hasOwnProperty","Error","isAssociativeWith","nodeA","nodeB","a","b","identifierA","identifierB","Array"],"mappings":"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","file":"js/a931863acf0794c7d14b.js","sourcesContent":["'use strict'; // list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\n\nvar properties = [{\n  // assignment\n  'AssignmentNode': {},\n  'FunctionAssignmentNode': {}\n}, {\n  // conditional expression\n  'ConditionalNode': {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'RelationalNode': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  'RangeNode': {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {number|null}\n */\n\nfunction getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\n\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if (property.hasOwnProperty('associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {bool|null}\n */\n\n\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if (property.hasOwnProperty('associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}\n\nmodule.exports.properties = properties;\nmodule.exports.getPrecedence = getPrecedence;\nmodule.exports.getAssociativity = getAssociativity;\nmodule.exports.isAssociativeWith = isAssociativeWith;"],"sourceRoot":""}