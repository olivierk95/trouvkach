{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/expression/node/FunctionNode.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","this","latex","__webpack_require__","escape","map","validateSafeMethod","getSafeProperty","exports","name","path","math","factory","type","config","load","typed","Node","SymbolNode","FunctionNode","fn","args","SyntaxError","isNode","TypeError","Array","isArray","every","defineProperty","get","bind","set","Error","deprecated","isFunctionNode","_compile","argNames","evalArgs","arg","isSymbolNode","undefined","rawArgs","scope","context","evalArg0","_evalArg","evalArg1","evalArg","isAccessorNode","isIndexNode","index","isObjectProperty","evalObject","object","prop","getObjectProperty","_rawArgs","evalFn","_rawArgs2","forEach","callback","_ifNode","clone","slice","nodeToString","toString","expandTemplate","template","node","options","match","regex","RegExp","inputPos","exec","substring","property","ReferenceError","toTex","join","customString","handler","_toString","isFunctionAssignmentNode","toJSON","mathjs","fromJSON","json","toHTML","nodeToTex","customTex","_toTex","latexConverter","customToTex","defaultTemplate","getIdentifier"],"mappings":"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","file":"js/8afb3808691533e65254.js","sourcesContent":["'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar latex = require('../../utils/latex');\n\nvar escape = require('../../utils/string').escape;\n\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nvar map = require('../../utils/array').map;\n\nvar validateSafeMethod = require('../../utils/customs').validateSafeMethod;\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory(type, config, load, typed, math) {\n  var Node = load(require('./Node'));\n  var SymbolNode = load(require('./SymbolNode'));\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!type.isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    }); // TODO: deprecated since v3, remove some day\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (type.isSymbolNode(this.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var name = this.fn.name;\n      var fn = name in math ? getSafeProperty(math, name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          return (name in scope ? getSafeProperty(scope, name) : fn)(rawArgs, math, _extends({}, scope, args));\n        };\n      } else {\n        // \"regular\" evaluation\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalFunctionNode(scope, args, context) {\n            return (name in scope ? getSafeProperty(scope, name) : fn)(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalFunctionNode(scope, args, context) {\n            return (name in scope ? getSafeProperty(scope, name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalFunctionNode(scope, args, context) {\n            return (name in scope ? getSafeProperty(scope, name) : fn).apply(null, map(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n    } else if (type.isAccessorNode(this.fn) && type.isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        validateSafeMethod(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : object[prop].apply(object, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : fn.apply(fn, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = type.isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = new RegExp('\\\\$(?:\\\\{([a-z_][a-z_0-9]*)(?:\\\\[([0-9]+)\\\\])?\\\\}|\\\\$)', 'ig');\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (_typeof(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if (type.isNode(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (type.isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if (type.isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (_typeof(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (_typeof(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(latex.defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}\n\nexports.name = 'FunctionNode';\nexports.path = 'expression.node';\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\n\nexports.factory = factory;"],"sourceRoot":""}