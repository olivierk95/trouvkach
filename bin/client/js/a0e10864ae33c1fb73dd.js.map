{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acos.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acosh.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acot.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acoth.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acsc.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/acsch.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/asec.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/asech.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/asin.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/asinh.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/atan.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/atan2.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/trigonometry/atanh.js"],"names":["deepMap","__webpack_require__","exports","name","factory","type","config","load","typed","acos","number","x","predictable","Math","Complex","BigNumber","Array | Matrix","toTex","1","_acosh","acosh","log","sqrt","PI","acot","atan","div","acoth","isFinite","atanh","acsc","asin","acsch","asinh","asec","asech","ret","matrix","algorithm02","algorithm03","algorithm09","algorithm11","algorithm12","algorithm13","algorithm14","atan2","number, number","BigNumber, BigNumber","y","SparseMatrix, SparseMatrix","SparseMatrix, DenseMatrix","DenseMatrix, SparseMatrix","DenseMatrix, DenseMatrix","Array, Array","valueOf","Array, Matrix","Matrix, Array","SparseMatrix, number | BigNumber","DenseMatrix, number | BigNumber","number | BigNumber, SparseMatrix","number | BigNumber, DenseMatrix","Array, number | BigNumber","number | BigNumber, Array","2","_atanh"],"mappings":"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","file":"js/a0e10864ae33c1fb73dd.js","sourcesContent":["'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse cosine of a value.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acos(x)\n   *\n   * Examples:\n   *\n   *    math.acos(0.5)           // returns number 1.0471975511965979\n   *    math.acos(math.cos(1.5)) // returns number 1.5\n   *\n   *    math.acos(2)             // returns Complex 0 + 1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    cos, atan, asin\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x  Function input\n   * @return {number | BigNumber | Complex | Array | Matrix} The arc cosine of x\n   */\n  var acos = typed('acos', {\n    'number': function number(x) {\n      if (x >= -1 && x <= 1 || config.predictable) {\n        return Math.acos(x);\n      } else {\n        return new type.Complex(x, 0).acos();\n      }\n    },\n    'Complex': function Complex(x) {\n      return x.acos();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.acos();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acos);\n    }\n  });\n  acos.toTex = {\n    1: \"\\\\cos^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acos;\n}\n\nexports.name = 'acos';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arccos of a value,\n   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acosh(x)\n   *\n   * Examples:\n   *\n   *    math.acosh(1.5)       // returns 0.9624236501192069\n   *\n   * See also:\n   *\n   *    cosh, asinh, atanh\n   *\n   * @param {number | Complex | Unit | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arccosine of x\n   */\n  var acosh = typed('acosh', {\n    'number': function number(x) {\n      if (x >= 1 || config.predictable) {\n        return _acosh(x);\n      }\n\n      if (x <= -1) {\n        return new type.Complex(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);\n      }\n\n      return new type.Complex(x, 0).acosh();\n    },\n    'Complex': function Complex(x) {\n      return x.acosh();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.acosh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acosh);\n    }\n  });\n  acosh.toTex = {\n    1: \"\\\\cosh^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acosh;\n}\n/**\n * Calculate the hyperbolic arccos of a number\n * @param {number} x\n * @return {number}\n * @private\n */\n\n\nvar _acosh = Math.acosh || function (x) {\n  return Math.log(Math.sqrt(x * x - 1) + x);\n};\n\nexports.name = 'acosh';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acot(x)\n   *\n   * Examples:\n   *\n   *    math.acot(0.5)           // returns number 0.4636476090008061\n   *    math.acot(math.cot(1.5)) // returns number 1.5\n   *\n   *    math.acot(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    cot, atan\n   *\n   * @param {number | Complex | Array | Matrix} x   Function input\n   * @return {number | Complex | Array | Matrix} The arc cotangent of x\n   */\n  var acot = typed('acot', {\n    'number': function number(x) {\n      return Math.atan(1 / x);\n    },\n    'Complex': function Complex(x) {\n      return x.acot();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).atan();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acot);\n    }\n  });\n  acot.toTex = {\n    1: \"\\\\cot^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acot;\n}\n\nexports.name = 'acot';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arccotangent of a value,\n   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acoth(x)\n   *\n   * Examples:\n   *\n   *    math.acoth(0.5)       // returns 0.8047189562170503\n   *\n   * See also:\n   *\n   *    acsch, asech\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arccotangent of x\n   */\n  var acoth = typed('acoth', {\n    'number': function number(x) {\n      if (x >= 1 || x <= -1 || config.predictable) {\n        return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;\n      }\n\n      return new type.Complex(x, 0).acoth();\n    },\n    'Complex': function Complex(x) {\n      return x.acoth();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).atanh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acoth);\n    }\n  });\n  acoth.toTex = {\n    1: \"\\\\coth^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acoth;\n}\n\nexports.name = 'acoth';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acsc(x)\n   *\n   * Examples:\n   *\n   *    math.acsc(0.5)           // returns number 0.5235987755982989\n   *    math.acsc(math.csc(1.5)) // returns number ~1.5\n   *\n   *    math.acsc(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    csc, asin, asec\n   *\n   * @param {number | Complex | Array | Matrix} x   Function input\n   * @return {number | Complex | Array | Matrix} The arc cosecant of x\n   */\n  var acsc = typed('acsc', {\n    'number': function number(x) {\n      if (x <= -1 || x >= 1 || config.predictable) {\n        return Math.asin(1 / x);\n      }\n\n      return new type.Complex(x, 0).acsc();\n    },\n    'Complex': function Complex(x) {\n      return x.acsc();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).asin();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acsc);\n    }\n  });\n  acsc.toTex = {\n    1: \"\\\\csc^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acsc;\n}\n\nexports.name = 'acsc';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arccosecant of a value,\n   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.acsch(x)\n   *\n   * Examples:\n   *\n   *    math.acsch(0.5)       // returns 1.4436354751788103\n   *\n   * See also:\n   *\n   *    asech, acoth\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arccosecant of x\n   */\n  var acsch = typed('acsch', {\n    'number': function number(x) {\n      x = 1 / x;\n      return Math.log(x + Math.sqrt(x * x + 1));\n    },\n    'Complex': function Complex(x) {\n      return x.acsch();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).asinh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, acsch);\n    }\n  });\n  acsch.toTex = {\n    1: \"\\\\mathrm{csch}^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return acsch;\n}\n\nexports.name = 'acsch';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.asec(x)\n   *\n   * Examples:\n   *\n   *    math.asec(0.5)           // returns 1.0471975511965979\n   *    math.asec(math.sec(1.5)) // returns 1.5\n   *\n   *    math.asec(2)             // returns 0 + 1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    acos, acot, acsc\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} The arc secant of x\n   */\n  var asec = typed('asec', {\n    'number': function number(x) {\n      if (x <= -1 || x >= 1 || config.predictable) {\n        return Math.acos(1 / x);\n      }\n\n      return new type.Complex(x, 0).asec();\n    },\n    'Complex': function Complex(x) {\n      return x.asec();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).acos();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, asec);\n    }\n  });\n  asec.toTex = {\n    1: \"\\\\sec^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return asec;\n}\n\nexports.name = 'asec';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arcsecant of a value,\n   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.asech(x)\n   *\n   * Examples:\n   *\n   *    math.asech(0.5)       // returns 1.3169578969248166\n   *\n   * See also:\n   *\n   *    acsch, acoth\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arcsecant of x\n   */\n  var asech = typed('asech', {\n    'number': function number(x) {\n      if (x <= 1 && x >= -1 || config.predictable) {\n        x = 1 / x;\n        var ret = Math.sqrt(x * x - 1);\n\n        if (x > 0 || config.predictable) {\n          return Math.log(ret + x);\n        }\n\n        return new type.Complex(Math.log(ret - x), Math.PI);\n      }\n\n      return new type.Complex(x, 0).asech();\n    },\n    'Complex': function Complex(x) {\n      return x.asech();\n    },\n    'BigNumber': function BigNumber(x) {\n      return new type.BigNumber(1).div(x).acosh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, asech);\n    }\n  });\n  asech.toTex = {\n    1: \"\\\\mathrm{sech}^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return asech;\n}\n\nexports.name = 'asech';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse sine of a value.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.asin(x)\n   *\n   * Examples:\n   *\n   *    math.asin(0.5)           // returns number 0.5235987755982989\n   *    math.asin(math.sin(1.5)) // returns number ~1.5\n   *\n   *    math.asin(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    sin, atan, acos\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input\n   * @return {number | BigNumber | Complex | Array | Matrix} The arc sine of x\n   */\n  var asin = typed('asin', {\n    'number': function number(x) {\n      if (x >= -1 && x <= 1 || config.predictable) {\n        return Math.asin(x);\n      } else {\n        return new type.Complex(x, 0).asin();\n      }\n    },\n    'Complex': function Complex(x) {\n      return x.asin();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.asin();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since asin(0) = 0\n      return deepMap(x, asin, true);\n    }\n  });\n  asin.toTex = {\n    1: \"\\\\sin^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return asin;\n}\n\nexports.name = 'asin';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arcsine of a value,\n   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.asinh(x)\n   *\n   * Examples:\n   *\n   *    math.asinh(0.5)       // returns 0.48121182505960347\n   *\n   * See also:\n   *\n   *    acosh, atanh\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arcsine of x\n   */\n  var asinh = typed('asinh', {\n    'number': Math.asinh || function (x) {\n      return Math.log(Math.sqrt(x * x + 1) + x);\n    },\n    'Complex': function Complex(x) {\n      return x.asinh();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.asinh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since asinh(0) = 0\n      return deepMap(x, asinh, true);\n    }\n  });\n  asinh.toTex = {\n    1: \"\\\\sinh^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return asinh;\n}\n\nexports.name = 'asinh';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the inverse tangent of a value.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.atan(x)\n   *\n   * Examples:\n   *\n   *    math.atan(0.5)           // returns number 0.4636476090008061\n   *    math.atan(math.tan(1.5)) // returns number 1.5\n   *\n   *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    tan, asin, acos\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input\n   * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x\n   */\n  var atan = typed('atan', {\n    'number': function number(x) {\n      return Math.atan(x);\n    },\n    'Complex': function Complex(x) {\n      return x.atan();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.atan();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since atan(0) = 0\n      return deepMap(x, atan, true);\n    }\n  });\n  atan.toTex = {\n    1: \"\\\\tan^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return atan;\n}\n\nexports.name = 'atan';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));\n  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));\n  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));\n  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));\n  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));\n  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  /**\n   * Calculate the inverse tangent function with two arguments, y/x.\n   * By providing two arguments, the right quadrant of the computed angle can be\n   * determined.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.atan2(y, x)\n   *\n   * Examples:\n   *\n   *    math.atan2(2, 2) / math.pi       // returns number 0.25\n   *\n   *    const angle = math.unit(60, 'deg') // returns Unit 60 deg\n   *    const x = math.cos(angle)\n   *    const y = math.sin(angle)\n   *\n   *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i\n   *\n   * See also:\n   *\n   *    tan, atan, sin, cos\n   *\n   * @param {number | Array | Matrix} y  Second dimension\n   * @param {number | Array | Matrix} x  First dimension\n   * @return {number | Array | Matrix} Four-quadrant inverse tangent\n   */\n\n  var atan2 = typed('atan2', {\n    'number, number': Math.atan2,\n    // Complex numbers doesn't seem to have a reasonable implementation of\n    // atan2(). Even Matlab removed the support, after they only calculated\n    // the atan only on base of the real part of the numbers and ignored the imaginary.\n    'BigNumber, BigNumber': function BigNumberBigNumber(y, x) {\n      return type.BigNumber.atan2(y, x);\n    },\n    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {\n      return algorithm09(x, y, atan2, false);\n    },\n    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {\n      // mind the order of y and x!\n      return algorithm02(y, x, atan2, true);\n    },\n    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {\n      return algorithm03(x, y, atan2, false);\n    },\n    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n      return algorithm13(x, y, atan2);\n    },\n    'Array, Array': function ArrayArray(x, y) {\n      return atan2(matrix(x), matrix(y)).valueOf();\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      return atan2(matrix(x), y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      return atan2(x, matrix(y));\n    },\n    'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {\n      return algorithm11(x, y, atan2, false);\n    },\n    'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {\n      return algorithm14(x, y, atan2, false);\n    },\n    'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {\n      // mind the order of y and x\n      return algorithm12(y, x, atan2, true);\n    },\n    'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {\n      // mind the order of y and x\n      return algorithm14(y, x, atan2, true);\n    },\n    'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {\n      return algorithm14(matrix(x), y, atan2, false).valueOf();\n    },\n    'number | BigNumber, Array': function numberBigNumberArray(x, y) {\n      return algorithm14(matrix(y), x, atan2, true).valueOf();\n    }\n  });\n  atan2.toTex = {\n    2: \"\\\\mathrm{atan2}\\\\left(${args}\\\\right)\"\n  };\n  return atan2;\n}\n\nexports.name = 'atan2';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Calculate the hyperbolic arctangent of a value,\n   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.atanh(x)\n   *\n   * Examples:\n   *\n   *    math.atanh(0.5)       // returns 0.5493061443340549\n   *\n   * See also:\n   *\n   *    acosh, asinh\n   *\n   * @param {number | Complex | Array | Matrix} x  Function input\n   * @return {number | Complex | Array | Matrix} Hyperbolic arctangent of x\n   */\n  var atanh = typed('atanh', {\n    'number': function number(x) {\n      if (x <= 1 && x >= -1 || config.predictable) {\n        return _atanh(x);\n      }\n\n      return new type.Complex(x, 0).atanh();\n    },\n    'Complex': function Complex(x) {\n      return x.atanh();\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.atanh();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since atanh(0) = 0\n      return deepMap(x, atanh, true);\n    }\n  });\n  atanh.toTex = {\n    1: \"\\\\tanh^{-1}\\\\left(${args[0]}\\\\right)\"\n  };\n  return atanh;\n}\n/**\n * Calculate the hyperbolic arctangent of a number\n * @param {number} x\n * @return {number}\n * @private\n */\n\n\nvar _atanh = Math.atanh || function (x) {\n  return Math.log((1 + x) / (1 - x)) / 2;\n};\n\nexports.name = 'atanh';\nexports.factory = factory;"],"sourceRoot":""}