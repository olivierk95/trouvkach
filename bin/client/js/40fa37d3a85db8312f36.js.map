{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/utils/object.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isBigNumber","__webpack_require__","exports","clone","x","type","Array","isArray","map","value","Date","valueOf","RegExp","TypeError","object","callback","key","hasOwnProperty","extend","a","b","prop","deepExtend","Object","undefined","deepEqual","i","len","length","canDefineProperty","defineProperty","get","e","lazy","fn","_value","_uninitialized","set","configurable","enumerable","traverse","path","names","split","name","property","call","isFactory","factory"],"mappings":"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","file":"js/40fa37d3a85db8312f36.js","sourcesContent":["'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isBigNumber = require('./bignumber/isBigNumber');\n/**\n * Clone an object\n *\n *     clone(x)\n *\n * Can clone any primitive type, array, and object.\n * If x has a function clone, this function will be invoked to clone the object.\n *\n * @param {*} x\n * @return {*} clone\n */\n\n\nexports.clone = function clone(x) {\n  var type = _typeof(x); // immutable primitive types\n\n\n  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {\n    return x;\n  } // use clone function of the object when available\n\n\n  if (typeof x.clone === 'function') {\n    return x.clone();\n  } // array\n\n\n  if (Array.isArray(x)) {\n    return x.map(function (value) {\n      return clone(value);\n    });\n  }\n\n  if (x instanceof Date) return new Date(x.valueOf());\n  if (isBigNumber(x)) return x; // bignumbers are immutable\n\n  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp\n  // object\n\n  return exports.map(x, clone);\n};\n/**\n * Apply map to all properties of an object\n * @param {Object} object\n * @param {function} callback\n * @return {Object} Returns a copy of the object with mapped properties\n */\n\n\nexports.map = function (object, callback) {\n  var clone = {};\n\n  for (var key in object) {\n    if (exports.hasOwnProperty(object, key)) {\n      clone[key] = callback(object[key]);\n    }\n  }\n\n  return clone;\n};\n/**\n * Extend object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\n\n\nexports.extend = function (a, b) {\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      a[prop] = b[prop];\n    }\n  }\n\n  return a;\n};\n/**\n * Deep extend an object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @returns {Object}\n */\n\n\nexports.deepExtend = function deepExtend(a, b) {\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop]);\n        } else {\n          a[prop] = b[prop];\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        a[prop] = b[prop];\n      }\n    }\n  }\n\n  return a;\n};\n/**\n * Deep test equality of all fields in two pairs of arrays or objects.\n * @param {Array | Object} a\n * @param {Array | Object} b\n * @returns {boolean}\n */\n\n\nexports.deepEqual = function deepEqual(a, b) {\n  var prop, i, len;\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!exports.deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (a instanceof Object) {\n    if (Array.isArray(b) || !(b instanceof Object)) {\n      return false;\n    }\n\n    for (prop in a) {\n      // noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    for (prop in b) {\n      // noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return a === b;\n  }\n};\n/**\n * Test whether the current JavaScript engine supports Object.defineProperty\n * @returns {boolean} returns true if supported\n */\n\n\nexports.canDefineProperty = function () {\n  // test needed for broken IE8 implementation\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty({}, 'x', {\n        get: function get() {}\n      });\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n};\n/**\n * Attach a lazy loading property to a constant.\n * The given function `fn` is called once when the property is first requested.\n * On older browsers (<IE8), the function will fall back to direct evaluation\n * of the properties value.\n * @param {Object} object   Object where to add the property\n * @param {string} prop     Property name\n * @param {Function} fn     Function returning the property value. Called\n *                          without arguments.\n */\n\n\nexports.lazy = function (object, prop, fn) {\n  if (exports.canDefineProperty()) {\n    var _uninitialized = true;\n\n    var _value;\n\n    Object.defineProperty(object, prop, {\n      get: function get() {\n        if (_uninitialized) {\n          _value = fn();\n          _uninitialized = false;\n        }\n\n        return _value;\n      },\n      set: function set(value) {\n        _value = value;\n        _uninitialized = false;\n      },\n      configurable: true,\n      enumerable: true\n    });\n  } else {\n    // fall back to immediate evaluation\n    object[prop] = fn();\n  }\n};\n/**\n * Traverse a path into an object.\n * When a namespace is missing, it will be created\n * @param {Object} object\n * @param {string} path   A dot separated string like 'name.space'\n * @return {Object} Returns the object at the end of the path\n */\n\n\nexports.traverse = function (object, path) {\n  var obj = object;\n\n  if (path) {\n    var names = path.split('.');\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n\n      if (!(name in obj)) {\n        obj[name] = {};\n      }\n\n      obj = obj[name];\n    }\n  }\n\n  return obj;\n};\n/**\n * A safe hasOwnProperty\n * @param {Object} object\n * @param {string} property\n */\n\n\nexports.hasOwnProperty = function (object, property) {\n  return object && Object.hasOwnProperty.call(object, property);\n};\n/**\n * Test whether an object is a factory. a factory has fields:\n *\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\n * - name: string (optional)\n * - path: string    A dot separated path (optional)\n * - math: boolean   If true (false by default), the math namespace is passed\n *                   as fifth argument of the factory function\n *\n * @param {*} object\n * @returns {boolean}\n */\n\n\nexports.isFactory = function (object) {\n  return object && typeof object.factory === 'function';\n};"],"sourceRoot":""}