{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/core/function/import.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/core/function/config.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","lazy","__webpack_require__","isFactory","traverse","ArgumentsError","exports","math","name","factory","type","config","load","typed","_import","value","options","wrap","wrapper","args","i","len","arguments","length","arg","valueOf","fn","apply","transform","isTypedFunction","override","signatures","_importTransform","emit","undefined","silent","Error","expression","allowedInExpressions","mathWithTransform","_deleteTransform","_importFactory","existingTransform","namespace","path","existing","hasOwnProperty","resolver","instance","factoryAllowedInExpressions","isSupportedType","object","isUnit","isComplex","isBigNumber","isFraction","isMatrix","Array","isArray","unsafe","docs","error","json","chain","mathImport","num","forEach","entry","TypeError","validateOption","values","array","item","indexOf","index","map","toLowerCase","findIndex","console","warn","JSON","stringify","join","MATRIX","NUMBER","_config","prev","clone","deepExtend","curr","changes"],"mappings":"4FAEA,SAAAA,EAAAC,GAAwU,OAAtOD,EAA3E,mBAAAE,QAAA,iBAAAA,OAAAC,SAA2E,SAAAF,GAAkC,cAAAA,GAA+B,SAAAA,GAAkC,OAAAA,GAAA,mBAAAC,QAAAD,EAAAG,cAAAF,QAAAD,IAAAC,OAAAG,UAAA,gBAAAJ,IAAmIA,GAExU,IAAAK,EAAWC,EAAQ,GAAoBD,KAEvCE,EAAgBD,EAAQ,GAAoBC,UAE5CC,EAAeF,EAAQ,GAAoBE,SAE3CC,EAAqBH,EAAQ,IAkT7BI,EAAAC,MAAA,EAEAD,EAAAE,KAAA,SACAF,EAAAG,QAnTA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAN,GAgGA,SAAAO,EAAAN,EAAAO,EAAAC,GAOA,GALAA,EAAAC,MAAA,mBAAAF,IA4EAG,EAAA,WAGA,IAFA,IAAAC,EAAA,GAEAC,EAAA,EAAAC,EAAAC,UAAAC,OAA6CH,EAAAC,EAASD,IAAA,CACtD,IAAAI,EAAAF,UAAAF,GACAD,EAAAC,GAAAI,KAAAC,UAGA,OAAAC,EAAAC,MAAApB,EAAAY,KATAO,EAzEAX,GAqFAa,YACAV,EAAAU,UAAAF,EAAAE,WAtFAb,EAyFAG,GAtFAW,EAAAtB,EAAAC,KAAAqB,EAAAd,GAgBA,OAbAA,EAFAC,EAAAc,SAEAjB,EAAAL,EAAAO,EAAAgB,YAGAlB,EAAAN,EAAAC,GAAAO,GAGAR,EAAAC,GAAAO,EAEAiB,EAAAxB,EAAAO,QAEAR,EAAA0B,KAAA,SAAAzB,EAAA,WACA,OAAAO,IAwDA,IAAAW,EACAR,EApDA,QAAAgB,IAAA3B,EAAAC,IAAAQ,EAAAc,SAQA,OAPAvB,EAAAC,GAAAO,EAEAiB,EAAAxB,EAAAO,QAEAR,EAAA0B,KAAA,SAAAzB,EAAA,WACA,OAAAO,IAKA,IAAAC,EAAAmB,OACA,UAAAC,MAAA,kBAAA5B,EAAA,qBAIA,SAAAwB,EAAAxB,EAAAO,GACAA,GAAA,mBAAAA,EAAAa,WACArB,EAAA8B,WAAAT,UAAApB,GAAAO,EAAAa,UAEAU,EAAA9B,KACAD,EAAA8B,WAAAE,kBAAA/B,GAAAO,EAAAa,oBAIArB,EAAA8B,WAAAT,UAAApB,GAEA8B,EAAA9B,KACAD,EAAA8B,WAAAE,kBAAA/B,GAAAO,IAKA,SAAAyB,EAAAhC,UACAD,EAAA8B,WAAAT,UAAApB,GAEA8B,EAAA9B,GACAD,EAAA8B,WAAAE,kBAAA/B,GAAAD,EAAAC,UAEAD,EAAA8B,WAAAE,kBAAA/B,GAsCA,SAAAiC,EAAAhC,EAAAO,GACA,oBAAAP,EAAAD,KAAA,CACA,IAAAA,EAAAC,EAAAD,KACAkC,EAAAlC,KAAAD,EAAA8B,WAAAT,UACAe,EAAAlC,EAAAmC,KAAAxC,EAAAG,EAAAE,EAAAmC,MAAArC,EACAsC,EAAAF,EAAAG,eAAAtC,GAAAmC,EAAAnC,QAAA0B,EAEAa,EAAA,WACA,IAAAC,EAAApC,EAAAH,GAEA,GAAAuC,GAAA,mBAAAA,EAAApB,UACA,UAAAQ,MAAA,yIAGA,GAAAP,EAAAgB,IAAAhB,EAAAmB,GAOA,OANAhC,EAAAc,WAGAkB,EAAAnC,EAAAgC,EAAAG,IAGAA,EAGA,QAAAd,IAAAW,GAAA7B,EAAAc,SACA,OAAAkB,EAGA,IAAAhC,EAAAmB,OACA,UAAAC,MAAA,kBAAA5B,EAAA,uBAIA,IAAAC,EAAAR,MACAA,EAAA0C,EAAAnC,EAAAuC,GAEAL,EACAF,EAAAhC,IAEA,yBAAAC,EAAAmC,MAAAK,EAAAxC,KACAR,EAAAM,EAAA8B,WAAAE,kBAAA/B,EAAAuC,KAIAJ,EAAAnC,GAAAuC,IAEAL,EACAF,EAAAhC,IAEA,yBAAAC,EAAAmC,MAAAK,EAAAxC,MACAF,EAAA8B,WAAAE,kBAAA/B,GAAAuC,MAKAxC,EAAA0B,KAAA,SAAAzB,EAAAuC,EAAAtC,EAAAmC,WAIAhC,EAAAH,GAWA,SAAAyC,EAAAC,GACA,yBAAAA,GAAA,iBAAAA,GAAA,iBAAAA,GAAA,kBAAAA,GAAA,OAAAA,MAAAzC,EAAA0C,OAAAD,OAAAzC,EAAA2C,UAAAF,OAAAzC,EAAA4C,YAAAH,OAAAzC,EAAA6C,WAAAJ,OAAAzC,EAAA8C,SAAAL,OAAAM,MAAAC,QAAAP,GASA,SAAAtB,EAAAH,GACA,yBAAAA,GAAA,WAAA/B,EAAA+B,EAAAK,YAGA,SAAAO,EAAA9B,GACA,OAAAmD,EAAAb,eAAAtC,GAGA,SAAAyC,EAAAxC,GACA,YAAAyB,IAAAzB,EAAAmC,OAAAe,EAAAb,eAAArC,EAAAD,MAIA,IAAAmD,EAAA,CACAtB,YAAA,EACA3B,MAAA,EACAkD,MAAA,EACAC,OAAA,EACAC,MAAA,EACAC,OAAA,GAGA,OA7PA,SAAAC,EAAAb,EAAAnC,GACA,IAAAiD,EAAA3C,UAAAC,OAEA,OAAA0C,GAAA,IAAAA,EACA,UAAA5D,EAAA,SAAA4D,EAAA,KAQA,GALAjD,IACAA,EAAA,IAIAb,EAAAgD,GACAV,EAAAU,EAAAnC,QACK,GAAAyC,MAAAC,QAAAP,GACLA,EAAAe,QAAA,SAAAC,GACAH,EAAAG,EAAAnD,UAEK,cAAArB,EAAAwD,IAEL,QAAA3C,KAAA2C,EACA,GAAAA,EAAAL,eAAAtC,GAAA,CACA,IAAAO,EAAAoC,EAAA3C,GAEA0C,EAAAnC,GACAD,EAAAN,EAAAO,EAAAC,GACWb,EAAAgD,GACXV,EAAAU,EAAAnC,GAEAgD,EAAAjD,EAAAC,SAKA,IAAAA,EAAAmB,OACA,UAAAiC,UAAA,wCAiOA9D,EAAAL,MAAA,oCC9TA,IAAAkD,EAAajD,EAAQ,GAiGrB,SAAAmE,EAAArD,EAAAR,EAAA8D,GACA,QAAApC,IAAAlB,EAAAR,KAzBA+D,EAyBAD,EAzBAE,EAyBAxD,EAAAR,IAxBA,IAAA+D,EAAAE,QAAAD,IAwBA,CACA,IAAAE,EAfA,SAAAH,EAAAC,GACA,OAAAD,EAAAI,IAAA,SAAAvD,GACA,OAAAA,EAAAwD,gBACGH,QAAAD,EAAAI,eAYHC,CAAAP,EAAAtD,EAAAR,KAEA,IAAAkE,GAGAI,QAAAC,KAAA,mDAAAvE,EAAA,iBAAA8D,EAAAI,GAAA,iBAAA1D,EAAAR,GAAA,MACAQ,EAAAR,GAAA8D,EAAAI,IAGAI,QAAAC,KAAA,2BAAA/D,EAAAR,GAAA,+BAAAA,EAAA,yBAAA8D,EAAAK,IAAAK,KAAAC,WAAAC,KAAA,WAnCA,IAAAX,EAAAC,EAwCAlE,EAAAE,KAAA,SACAF,EAAAC,MAAA,EAEAD,EAAAG,QAlHA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAN,GACA,IAAA4E,EAAA,mBAEAC,EAAA,kCAqCA,SAAAC,EAAArE,GACA,GAAAA,EAAA,CACA,IAAAsE,EAAAnC,EAAAwB,IAAAhE,EAAAwC,EAAAoC,OAEAlB,EAAArD,EAAA,SAAAmE,GACAd,EAAArD,EAAA,SAAAoE,GAEAjC,EAAAqC,WAAA7E,EAAAK,GACA,IAAAyE,EAAAtC,EAAAwB,IAAAhE,EAAAwC,EAAAoC,OACAG,EAAAvC,EAAAwB,IAAA3D,EAAAmC,EAAAoC,OAGA,OADAhF,EAAA0B,KAAA,SAAAwD,EAAAH,EAAAI,GACAD,EAEA,OAAAtC,EAAAwB,IAAAhE,EAAAwC,EAAAoC,OAOA,OAFAF,EAAAF,SACAE,EAAAD,SACAC","file":"js/e0addd5c164a9ce63d28.js","sourcesContent":["'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar lazy = require('../../utils/object').lazy;\n\nvar isFactory = require('../../utils/object').isFactory;\n\nvar traverse = require('../../utils/object').traverse;\n\nvar ArgumentsError = require('../../error/ArgumentsError');\n\nfunction factory(type, config, load, typed, math) {\n  /**\n   * Import functions from an object or a module\n   *\n   * Syntax:\n   *\n   *    math.import(object)\n   *    math.import(object, options)\n   *\n   * Where:\n   *\n   * - `object: Object`\n   *   An object with functions to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(require('numbers'), {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} object   Object with functions to be imported.\n   * @param {Object} [options]        Import options.\n   */\n  function mathImport(object, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    } // TODO: allow a typed-function with name too\n\n\n    if (isFactory(object)) {\n      _importFactory(object, options);\n    } else if (Array.isArray(object)) {\n      object.forEach(function (entry) {\n        mathImport(entry, options);\n      });\n    } else if (_typeof(object) === 'object') {\n      // a map with functions\n      for (var name in object) {\n        if (object.hasOwnProperty(name)) {\n          var value = object[name];\n\n          if (isSupportedType(value)) {\n            _import(name, value, options);\n          } else if (isFactory(object)) {\n            _importFactory(object, options);\n          } else {\n            mathImport(value, options);\n          }\n        }\n      }\n    } else {\n      if (!options.silent) {\n        throw new TypeError('Factory, Object, or Array expected');\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace and create a chain proxy for it.\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    if (typeof factory.name === 'string') {\n      var name = factory.name;\n      var existingTransform = name in math.expression.transform;\n      var namespace = factory.path ? traverse(math, factory.path) : math;\n      var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;\n\n      var resolver = function resolver() {\n        var instance = load(factory);\n\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {// replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (!options.silent) {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || object && type.isUnit(object) || object && type.isComplex(object) || object && type.isBigNumber(object) || object && type.isFraction(object) || object && type.isMatrix(object) || object && Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function allowedInExpressions(name) {\n    return !unsafe.hasOwnProperty(name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !unsafe.hasOwnProperty(factory.name);\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    'expression': true,\n    'type': true,\n    'docs': true,\n    'error': true,\n    'json': true,\n    'chain': true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}\n\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\n\nexports.name = 'import';\nexports.factory = factory;\nexports.lazy = true;","'use strict';\n\nvar object = require('../../utils/object');\n\nfunction factory(type, config, load, typed, math) {\n  var MATRIX = ['Matrix', 'Array']; // valid values for option matrix\n\n  var NUMBER = ['number', 'BigNumber', 'Fraction']; // valid values for option number\n\n  /**\n   * Set configuration options for math.js, and get current options.\n   * Will emit a 'config' event, with arguments (curr, prev, changes).\n   *\n   * Syntax:\n   *\n   *     math.config(config: Object): Object\n   *\n   * Examples:\n   *\n   *     math.config().number                // outputs 'number'\n   *     math.eval('0.4')                    // outputs number 0.4\n   *     math.config({number: 'Fraction'})\n   *     math.eval('0.4')                    // outputs Fraction 2/5\n   *\n   * @param {Object} [options] Available options:\n   *                            {number} epsilon\n   *                              Minimum relative difference between two\n   *                              compared values, used by all comparison functions.\n   *                            {string} matrix\n   *                              A string 'Matrix' (default) or 'Array'.\n   *                            {string} number\n   *                              A string 'number' (default), 'BigNumber', or 'Fraction'\n   *                            {number} precision\n   *                              The number of significant digits for BigNumbers.\n   *                              Not applicable for Numbers.\n   *                            {string} parenthesis\n   *                              How to display parentheses in LaTeX and string\n   *                              output.\n   *                            {string} randomSeed\n   *                              Random seed for seeded pseudo random number generator.\n   *                              Set to null to randomly seed.\n   * @return {Object} Returns the current configuration\n   */\n\n  function _config(options) {\n    if (options) {\n      var prev = object.map(config, object.clone); // validate some of the options\n\n      validateOption(options, 'matrix', MATRIX);\n      validateOption(options, 'number', NUMBER); // merge options\n\n      object.deepExtend(config, options);\n      var curr = object.map(config, object.clone);\n      var changes = object.map(options, object.clone); // emit 'config' event\n\n      math.emit('config', curr, prev, changes);\n      return curr;\n    } else {\n      return object.map(config, object.clone);\n    }\n  } // attach the valid options to the function so they can be extended\n\n\n  _config.MATRIX = MATRIX;\n  _config.NUMBER = NUMBER;\n  return _config;\n}\n/**\n * Test whether an Array contains a specific item.\n * @param {Array.<string>} array\n * @param {string} item\n * @return {boolean}\n */\n\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n/**\n * Find a string in an array. Case insensitive search\n * @param {Array.<string>} array\n * @param {string} item\n * @return {number} Returns the index when found. Returns -1 when not found\n */\n\n\nfunction findIndex(array, item) {\n  return array.map(function (i) {\n    return i.toLowerCase();\n  }).indexOf(item.toLowerCase());\n}\n/**\n * Validate an option\n * @param {Object} options         Object with options\n * @param {string} name            Name of the option to validate\n * @param {Array.<string>} values  Array with valid values for this option\n */\n\n\nfunction validateOption(options, name, values) {\n  if (options[name] !== undefined && !contains(values, options[name])) {\n    var index = findIndex(values, options[name]);\n\n    if (index !== -1) {\n      // right value, wrong casing\n      // TODO: lower case values are deprecated since v3, remove this warning some day.\n      console.warn('Warning: Wrong casing for configuration option \"' + name + '\", should be \"' + values[index] + '\" instead of \"' + options[name] + '\".');\n      options[name] = values[index]; // change the option to the right casing\n    } else {\n      // unknown value\n      console.warn('Warning: Unknown value \"' + options[name] + '\" for configuration option \"' + name + '\". Available options: ' + values.map(JSON.stringify).join(', ') + '.');\n    }\n  }\n}\n\nexports.name = 'config';\nexports.math = true; // request the math namespace as fifth argument\n\nexports.factory = factory;"],"sourceRoot":""}