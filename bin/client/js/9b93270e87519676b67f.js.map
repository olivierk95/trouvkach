{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/OperatorNode.js"],"names":["latex","__webpack_require__","map","escape","isSafeMethod","getSafeProperty","operators","exports","name","path","factory","type","config","load","typed","Node","OperatorNode","op","fn","args","implicit","this","SyntaxError","TypeError","Array","isArray","every","isNode","calculateNecessaryParentheses","root","parenthesis","result","precedence","getPrecedence","associativity","getAssociativity","length","getIdentifier","arg","getContent","operandPrecedence","operandIdentifier","rootIdentifier","properties","latexLeftParens","latexParens","lhsParens","rhsParens","lhsPrecedence","assocWithLhs","isAssociativeWith","_rootIdentifier","lhsIdentifier","rhsIdentifier","rhsPrecedence","assocWithRhs","latexRightParens","argPrecedence","assocWithArg","argAssociativity","index","isParenthesisNode","prototype","isOperatorNode","_compile","math","argNames","Error","evalArgs","evalArg0","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","callback","i","_ifNode","clone","slice","isUnary","isBinary","_toString","options","parens","assoc","operand","toString","lhs","rhs","stringifiedArgs","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","lhsTex","rhsTex","texifiedArgs"],"mappings":"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","file":"js/9b93270e87519676b67f.js","sourcesContent":["'use strict';\n\nvar latex = require('../../utils/latex');\n\nvar map = require('../../utils/array').map;\n\nvar escape = require('../../utils/string').escape;\n\nvar isSafeMethod = require('../../utils/customs').isSafeMethod;\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nvar operators = require('../operators');\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = getSafeProperty(math, this.fn);\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, map(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = operators.getPrecedence(root, parenthesis);\n    var associativity = operators.getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      var parens = args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n      return parens;\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        // precedence of the operand\n        var operandPrecedence = operators.getPrecedence(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n        if (latex && operandPrecedence !== null) {\n          var operandIdentifier;\n          var rootIdentifier;\n\n          if (parenthesis === 'keep') {\n            operandIdentifier = args[0].getIdentifier();\n            rootIdentifier = root.getIdentifier();\n          } else {\n            // Ignore Parenthesis Nodes when not in 'keep' mode\n            operandIdentifier = args[0].getContent().getIdentifier();\n            rootIdentifier = root.getContent().getIdentifier();\n          }\n\n          if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n            result = [false];\n            break;\n          }\n\n          if (operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n            result = [false];\n            break;\n          }\n        }\n\n        if (operandPrecedence === null) {\n          // if the operand has no defined precedence, no parens are needed\n          result = [false];\n          break;\n        }\n\n        if (operandPrecedence <= precedence) {\n          // if the operands precedence is lower, parens are needed\n          result = [true];\n          break;\n        } // otherwise, no parens needed\n\n\n        result = [false];\n        break;\n\n      case 2:\n        // binary operators\n        var lhsParens; // left hand side needs parenthesis?\n        // precedence of the left hand side\n\n        var lhsPrecedence = operators.getPrecedence(args[0], parenthesis); // is the root node associative with the left hand side\n\n        var assocWithLhs = operators.isAssociativeWith(root, args[0], parenthesis);\n\n        if (lhsPrecedence === null) {\n          // if the left hand side has no defined precedence, no parens are needed\n          // FunctionNode for example\n          lhsParens = false;\n        } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n          // In case of equal precedence, if the root node is left associative\n          // parens are **never** necessary for the left hand side.\n          // If it is right associative however, parens are necessary\n          // if the root node isn't associative with the left hand side\n          lhsParens = true;\n        } else if (lhsPrecedence < precedence) {\n          lhsParens = true;\n        } else {\n          lhsParens = false;\n        }\n\n        var rhsParens; // right hand side needs parenthesis?\n        // precedence of the right hand side\n\n        var rhsPrecedence = operators.getPrecedence(args[1], parenthesis); // is the root node associative with the right hand side?\n\n        var assocWithRhs = operators.isAssociativeWith(root, args[1], parenthesis);\n\n        if (rhsPrecedence === null) {\n          // if the right hand side has no defined precedence, no parens are needed\n          // FunctionNode for example\n          rhsParens = false;\n        } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n          // In case of equal precedence, if the root node is right associative\n          // parens are **never** necessary for the right hand side.\n          // If it is left associative however, parens are necessary\n          // if the root node isn't associative with the right hand side\n          rhsParens = true;\n        } else if (rhsPrecedence < precedence) {\n          rhsParens = true;\n        } else {\n          rhsParens = false;\n        } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n        if (latex) {\n          var _rootIdentifier;\n\n          var lhsIdentifier;\n          var rhsIdentifier;\n\n          if (parenthesis === 'keep') {\n            _rootIdentifier = root.getIdentifier();\n            lhsIdentifier = root.args[0].getIdentifier();\n            rhsIdentifier = root.args[1].getIdentifier();\n          } else {\n            // Ignore ParenthesisNodes when not in 'keep' mode\n            _rootIdentifier = root.getContent().getIdentifier();\n            lhsIdentifier = root.args[0].getContent().getIdentifier();\n            rhsIdentifier = root.args[1].getContent().getIdentifier();\n          }\n\n          if (lhsPrecedence !== null) {\n            if (operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n              lhsParens = false;\n            }\n\n            if (operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n              lhsParens = false;\n            }\n          }\n\n          if (rhsPrecedence !== null) {\n            if (operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n              rhsParens = false;\n            }\n\n            if (operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n              rhsParens = false;\n            }\n          }\n        }\n\n        result = [lhsParens, rhsParens];\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = operators.getPrecedence(arg, parenthesis);\n            var assocWithArg = operators.isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = operators.getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      } // fall back to postfix\n\n\n      return '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = latex.operators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}\n\nexports.name = 'OperatorNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}