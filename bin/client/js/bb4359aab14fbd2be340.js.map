{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/size.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/sort.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/sqrtm.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/matrix/squeeze.js"],"names":["array","__webpack_require__","exports","name","factory","type","config","load","typed","matrix","size","Matrix","x","Array","string","length","number | Complex | BigNumber | Unit | boolean | null","toTex","undefined","compareAsc","compareDesc","a","b","compareNatural","sort","_arrayIsVector","_matrixIsVector","toArray","storage","Array, function","_comparator","Matrix, function","Array, string","order","Matrix, string","Error","latex","abs","add","multiply","sqrt","subtract","inv","max","identity","sqrtm","Array | Matrix","A","isMatrix","RangeError","format","_denmanBeavers","_maxIterations","_tolerance","error","iterations","Y","Z","Yk","1","concat","operators","object","squeeze","clone","res","isArray","any"],"mappings":"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","file":"js/bb4359aab14fbd2be340.js","sourcesContent":["'use strict';\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Calculate the size of a matrix or scalar.\n   *\n   * Syntax:\n   *\n   *     math.size(x)\n   *\n   * Examples:\n   *\n   *     math.size(2.3)                  // returns []\n   *     math.size('hello world')        // returns [11]\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.size(A)                    // returns [2, 3]\n   *     math.size(math.range(1,6))      // returns [5]\n   *\n   * See also:\n   *\n   *     resize, squeeze, subset\n   *\n   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix\n   * @return {Array | Matrix} A vector with size of `x`.\n   */\n\n  var size = typed('size', {\n    'Matrix': function Matrix(x) {\n      // TODO: return the same matrix type as the input\n      return matrix(x.size());\n    },\n    'Array': array.size,\n    'string': function string(x) {\n      return config.matrix === 'Array' ? [x.length] : matrix([x.length]);\n    },\n    'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {\n      // scalar\n      return config.matrix === 'Array' ? [] : matrix([]);\n    }\n  });\n  size.toTex = undefined; // use default template\n\n  return size;\n}\n\nexports.name = 'size';\nexports.factory = factory;","'use strict';\n\nvar size = require('../../utils/array').size;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var compareAsc = load(require('../relational/compare'));\n\n  var compareDesc = function compareDesc(a, b) {\n    return -compareAsc(a, b);\n  };\n\n  var compareNatural = load(require('../relational/compareNatural'));\n  /**\n   * Sort the items in a matrix.\n   *\n   * Syntax:\n   *\n   *    math.sort(x)\n   *    math.sort(x, compare)\n   *\n   * Examples:\n   *\n   *    math.sort([5, 10, 1]) // returns [1, 5, 10]\n   *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)\n   *    // returns ['A', 'B', 'C', 'D']\n   *\n   *    function sortByLength (a, b) {\n   *      return a.length - b.length\n   *    }\n   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)\n   *    // returns ['Tom', 'Sara', 'Langdon']\n   *\n   * See also:\n   *\n   *    filter, forEach, map, compare, compareNatural\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to sort\n   * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']\n   *        An optional _comparator function or name. The function is called as\n   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,\n   *        and 0 when a == b.\n   * @return {Matrix | Array} Returns the sorted matrix.\n   */\n\n  var sort = typed('sort', {\n    'Array': function Array(x) {\n      _arrayIsVector(x);\n\n      return x.sort(compareAsc);\n    },\n    'Matrix': function Matrix(x) {\n      _matrixIsVector(x);\n\n      return matrix(x.toArray().sort(compareAsc), x.storage());\n    },\n    'Array, function': function ArrayFunction(x, _comparator) {\n      _arrayIsVector(x);\n\n      return x.sort(_comparator);\n    },\n    'Matrix, function': function MatrixFunction(x, _comparator) {\n      _matrixIsVector(x);\n\n      return matrix(x.toArray().sort(_comparator), x.storage());\n    },\n    'Array, string': function ArrayString(x, order) {\n      _arrayIsVector(x);\n\n      return x.sort(_comparator(order));\n    },\n    'Matrix, string': function MatrixString(x, order) {\n      _matrixIsVector(x);\n\n      return matrix(x.toArray().sort(_comparator(order)), x.storage());\n    }\n  });\n  sort.toTex = undefined; // use default template\n\n  /**\n   * Get the comparator for given order ('asc', 'desc', 'natural')\n   * @param {'asc' | 'desc' | 'natural'} order\n   * @return {Function} Returns a _comparator function\n   */\n\n  function _comparator(order) {\n    if (order === 'asc') {\n      return compareAsc;\n    } else if (order === 'desc') {\n      return compareDesc;\n    } else if (order === 'natural') {\n      return compareNatural;\n    } else {\n      throw new Error('String \"asc\", \"desc\", or \"natural\" expected');\n    }\n  }\n  /**\n   * Validate whether an array is one dimensional\n   * Throws an error when this is not the case\n   * @param {Array} array\n   * @private\n   */\n\n\n  function _arrayIsVector(array) {\n    if (size(array).length !== 1) {\n      throw new Error('One dimensional array expected');\n    }\n  }\n  /**\n   * Validate whether a matrix is one dimensional\n   * Throws an error when this is not the case\n   * @param {Matrix} matrix\n   * @private\n   */\n\n\n  function _matrixIsVector(matrix) {\n    if (matrix.size().length !== 1) {\n      throw new Error('One dimensional matrix expected');\n    }\n  }\n\n  return sort;\n}\n\nexports.name = 'sort';\nexports.factory = factory;","'use strict';\n\nvar array = require('../../utils/array');\n\nvar latex = require('../../utils/latex');\n\nvar string = require('../../utils/string');\n\nfunction factory(type, config, load, typed) {\n  var abs = load(require('../arithmetic/abs'));\n  var add = load(require('../arithmetic/add'));\n  var multiply = load(require('../arithmetic/multiply'));\n  var sqrt = load(require('../arithmetic/sqrt'));\n  var subtract = load(require('../arithmetic/subtract'));\n  var inv = load(require('../matrix/inv'));\n  var size = load(require('../matrix/size'));\n  var max = load(require('../statistics/max'));\n  var identity = load(require('./identity'));\n  /**\n   * Calculate the principal square root of a square matrix.\n   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix\n   *\n   * Syntax:\n   *\n   *     X = math.sqrtm(A)\n   *\n   * Examples:\n   *\n   *     math.sqrtm([[1, 2], [3, 4]]) // returns [[-2, 1], [1.5, -0.5]]\n   *\n   * See also:\n   *\n   *     sqrt, pow\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   */\n\n  var sqrtm = typed('sqrtm', {\n    'Array | Matrix': function ArrayMatrix(A) {\n      var size = type.isMatrix(A) ? A.size() : array.size(A);\n\n      switch (size.length) {\n        case 1:\n          // Single element Array | Matrix\n          if (size[0] === 1) {\n            return sqrt(A);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + string.format(size) + ')');\n          }\n\n        case 2:\n          // Two-dimensional Array | Matrix\n          var rows = size[0];\n          var cols = size[1];\n\n          if (rows === cols) {\n            return _denmanBeavers(A);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + string.format(size) + ')');\n          }\n\n      }\n    }\n  });\n  var _maxIterations = 1e3;\n  var _tolerance = 1e-6;\n  /**\n   * Calculate the principal square root matrix using the Denman–Beavers iterative method\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   * @private\n   */\n\n  function _denmanBeavers(A) {\n    var error;\n    var iterations = 0;\n    var Y = A;\n    var Z = identity(size(A));\n\n    do {\n      var Yk = Y;\n      Y = multiply(0.5, add(Yk, inv(Z)));\n      Z = multiply(0.5, add(Z, inv(Yk)));\n      error = max(abs(subtract(Y, Yk)));\n\n      if (error > _tolerance && ++iterations > _maxIterations) {\n        throw new Error('computing square root of matrix: iterative method could not converge');\n      }\n    } while (error > _tolerance);\n\n    return Y;\n  }\n\n  sqrtm.toTex = {\n    1: \"{${args[0]}}\".concat(latex.operators['pow'], \"{\\\\frac{1}{2}}\")\n  };\n  return sqrtm;\n}\n\nexports.name = 'sqrtm';\nexports.factory = factory;","'use strict';\n\nvar object = require('../../utils/object');\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.\n   *\n   * Syntax:\n   *\n   *     math.squeeze(x)\n   *\n   * Examples:\n   *\n   *     math.squeeze([3])           // returns 3\n   *     math.squeeze([[3]])         // returns 3\n   *\n   *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)\n   *     math.squeeze(A)             // returns [0, 0, 0] (size 3)\n   *\n   *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)\n   *     math.squeeze(B)             // returns [0, 0, 0] (size 3)\n   *\n   *     // only inner and outer dimensions are removed\n   *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)\n   *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)\n   *\n   * See also:\n   *\n   *     subset\n   *\n   * @param {Matrix | Array} x      Matrix to be squeezed\n   * @return {Matrix | Array} Squeezed matrix\n   */\n\n  var squeeze = typed('squeeze', {\n    'Array': function Array(x) {\n      return array.squeeze(object.clone(x));\n    },\n    'Matrix': function Matrix(x) {\n      var res = array.squeeze(x.toArray()); // FIXME: return the same type of matrix as the input\n\n      return Array.isArray(res) ? matrix(res) : res;\n    },\n    'any': function any(x) {\n      // scalar\n      return object.clone(x);\n    }\n  });\n  squeeze.toTex = undefined; // use default template\n\n  return squeeze;\n}\n\nexports.name = 'squeeze';\nexports.factory = factory;"],"sourceRoot":""}