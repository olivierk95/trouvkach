{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/arithmetic/multiply.js"],"names":["extend","__webpack_require__","array","exports","name","factory","type","config","load","typed","latex","matrix","addScalar","multiplyScalar","equalScalar","algorithm11","algorithm14","DenseMatrix","SparseMatrix","multiply","Array, Array","x","y","_validateMatrixDimensions","size","m","isMatrix","valueOf","Matrix, Matrix","xsize","ysize","length","a","b","n","Error","dt","adata","_data","adt","_datatype","bdata","bdt","af","mf","find","c","i","_multiplyVectorVector","storage","asize","_size","bsize","alength","bcolumns","j","sum","data","datatype","_multiplyVectorDenseMatrix","_multiplyVectorMatrix","_multiplyMatrixVector","_multiplyMatrixMatrix","Matrix, Array","Array, Matrix","SparseMatrix, any","DenseMatrix, any","any, SparseMatrix","any, DenseMatrix","Array, any","any, Array","any, any","any, any, ...any","rest","result","signatures","size1","size2","RangeError","arows","acolumns","row","avalues","_values","aindex","_index","aptr","_ptr","brows","cvalues","cindex","cptr","eq","zero","convert","w","ib","vbi","ka0","ka1","ka","ia","push","p1","p","ic","values","index","ptr","DenseMatrix, DenseMatrix","DenseMatrix, SparseMatrix","bvalues","bindex","bptr","jb","kb0","kb1","last","mark","cij","kb","SparseMatrix, DenseMatrix","vbij","p0","SparseMatrix, SparseMatrix","undefined","toTex","2","concat","operators"],"mappings":"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","file":"js/b2850f91e6a5c0e320c4.js","sourcesContent":["'use strict';\n\nvar extend = require('../../utils/object').extend;\n\nvar array = require('../../utils/array');\n\nfunction factory(type, config, load, typed) {\n  var latex = require('../../utils/latex');\n\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var addScalar = load(require('./addScalar'));\n  var multiplyScalar = load(require('./multiplyScalar'));\n  var equalScalar = load(require('../relational/equalScalar'));\n  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));\n  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));\n  var DenseMatrix = type.DenseMatrix;\n  var SparseMatrix = type.SparseMatrix;\n  /**\n   * Multiply two or more values, `x * y`.\n   * For matrices, the matrix product is calculated.\n   *\n   * Syntax:\n   *\n   *    math.multiply(x, y)\n   *    math.multiply(x, y, z, ...)\n   *\n   * Examples:\n   *\n   *    math.multiply(4, 5.2)        // returns number 20.8\n   *    math.multiply(2, 3, 4)       // returns number 24\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    const d = [[1, 2, 3], [3, -4, 7]]\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\n   *\n   *    const e = math.unit('2.1 km')\n   *    math.multiply(3, e)          // returns Unit 6.3 km\n   *\n   * See also:\n   *\n   *    divide, prod, cross, dot\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\n   */\n\n  var multiply = typed('multiply', extend({\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n    'Array, Array': function ArrayArray(x, y) {\n      // check dimensions\n      _validateMatrixDimensions(array.size(x), array.size(y)); // use dense matrix implementation\n\n\n      var m = multiply(matrix(x), matrix(y)); // return array or scalar\n\n      return type.isMatrix(m) ? m.valueOf() : m;\n    },\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size(); // check dimensions\n\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\n\n\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        } // Vector * Matrix\n\n\n        return _multiplyVectorMatrix(x, y);\n      } // process y dimensions\n\n\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      } // Matrix * Matrix\n\n\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(x, matrix(y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(matrix(x, y.storage()), y);\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm11(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, multiplyScalar, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': function anyAnyAny(x, y, rest) {\n      var result = multiply(x, y);\n\n      for (var i = 0; i < rest.length; i++) {\n        result = multiply(result, rest[i]);\n      }\n\n      return result;\n    }\n  }, multiplyScalar.signatures));\n\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n\n            break;\n\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n\n            break;\n\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (N)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {number}             Scalar value\n   */\n\n\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    } // a dense\n\n\n    var adata = a._data;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result (do not initialize it with zero)\n\n\n    var c = mf(adata[0], bdata[0]); // loop data\n\n    for (var i = 1; i < n; i++) {\n      // multiply and accumulate\n      c = af(c, mf(adata[i], bdata[i]));\n    }\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Matrix         (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Dense Matrix   (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var alength = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix columns\n\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\n\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n\n      c[j] = sum;\n    } // return matrix\n\n\n    return new DenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {Matrix}             Dense Vector   (M)\n   */\n\n\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Matrix         (NxC)\n   *\n   * @return {Matrix}             Matrix         (MxC)\n   */\n\n\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix  (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             Dense Vector (M)\n   */\n\n\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // sum (do not initialize it with zero)\n\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\n\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n\n      c[i] = sum;\n    } // return matrix\n\n\n    return new DenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            DenseMatrix    (NxC)\n   *\n   * @return {Matrix}             DenseMatrix    (MxC)\n   */\n\n\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // initialize row array\n\n      c[i] = []; // loop matrix b columns\n\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\n\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n\n        c[i][j] = sum;\n      }\n    } // return matrix\n\n\n    return new DenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            SparseMatrix   (NxC)\n   *\n   * @return {Matrix}             SparseMatrix   (MxC)\n   */\n\n\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate b matrix\n\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    } // rows & columns\n\n\n    var arows = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // indeces in column jb\n\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\n\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0; // loop a rows\n\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1; // C[i, jb]\n\n          var cij = void 0; // values in b column j\n\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb]; // check value has been initialized\n\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\n\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          } // check column has been processed and value != 0\n\n\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix    (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             SparseMatrix    (M, 1)\n   */\n\n\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0]; // result\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // workspace\n\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // update ptr\n\n    cptr[0] = 0; // rows in b\n\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\n\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka]; // check value exists in current j\n\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true; // add i to pattern of C\n\n            cindex.push(ia); // x(ia) = A\n\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    } // copy values from x to column jb of c\n\n\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p]; // copy value\n\n      cvalues[p] = x[ic];\n    } // update ptr\n\n\n    cptr[1] = cindex.length; // return sparse matrix\n\n    return new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            DenseMatrix       (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // rows in jb\n\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\n\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      } // copy values from x to column jb of c\n\n\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p]; // copy value\n\n        cvalues[p] = x[ic];\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            SparseMatrix      (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\n\n    var values = avalues && bvalues; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = new SparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // variables\n\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // B values & index in j\n\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb]; // check we need to process values\n\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia);\n            }\n          }\n        }\n      } // check we need to process matrix values (pattern matrix)\n\n\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p]; // copy value\n\n          cvalues[p] = x[ic];\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n\n  multiply.toTex = {\n    2: \"\\\\left(${args[0]}\".concat(latex.operators['multiply'], \"${args[1]}\\\\right)\")\n  };\n  return multiply;\n}\n\nexports.name = 'multiply';\nexports.factory = factory;"],"sourceRoot":""}