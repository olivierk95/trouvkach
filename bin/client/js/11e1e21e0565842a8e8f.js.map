{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/FunctionAssignmentNode.js"],"names":["keywords","__webpack_require__","escape","forEach","join","latex","operators","setSafeProperty","exports","name","path","factory","type","config","load","typed","Node","FunctionAssignmentNode","params","expr","this","SyntaxError","TypeError","Array","isArray","isNode","Error","map","param","types","needParenthesis","node","parenthesis","precedence","getPrecedence","exprPrecedence","prototype","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","scope","args","context","signatures","childArgs","i","length","arguments","fn","callback","_ifNode","slice","clone","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","_toTex","toTex","concat","toSymbol"],"mappings":"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","file":"js/11e1e21e0565842a8e8f.js","sourcesContent":["'use strict';\n\nvar keywords = require('../keywords');\n\nvar escape = require('../../utils/string').escape;\n\nvar forEach = require('../../utils/array').forEach;\n\nvar join = require('../../utils/array').join;\n\nvar latex = require('../../utils/latex');\n\nvar operators = require('../operators');\n\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!type.isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (name in keywords) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      setSafeProperty(scope, name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var exprPrecedence = operators.getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(latex.toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}\n\nexports.name = 'FunctionAssignmentNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}