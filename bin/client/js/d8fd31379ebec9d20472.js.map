{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csPost.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/algebra/sparse/csReach.js"],"names":["exports","name","path","factory","type","config","load","csTdfs","__webpack_require__","parent","n","j","k","post","w","next","stack","csDfs","csMarked","csMark","g","b","xi","pinv","p","p0","p1","gptr","_ptr","gsize","_size","bindex","_index","bptr","top","i"],"mappings":"2FAkEAA,EAAAC,KAAA,SACAD,EAAAE,KAAA,iBACAF,EAAAG,QAlEA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAoBE,EAAQ,MA4D5B,OAlDA,SAAAC,EAAAC,GAEA,IAAAD,EACA,YAIA,IACAE,EADAC,EAAA,EAGAC,EAAA,GAGAC,EAAA,GAGAC,EAAAL,EACAM,EAAA,EAAAN,EAEA,IAAAC,EAAA,EAAeA,EAAAD,EAAOC,IAEtBG,EANA,EAMAH,IAAA,EAIA,IAAAA,EAAAD,EAAA,EAAmBC,GAAA,EAAQA,KAE3B,IAAAF,EAAAE,KAKAG,EAAAC,EAAAJ,GAAAG,EAjBA,EAiBAL,EAAAE,IACAG,EAlBA,EAkBAL,EAAAE,OAIA,IAAAA,EAAA,EAAeA,EAAAD,EAAOC,KAEtB,IAAAF,EAAAE,KAKAC,EAAAL,EAAAI,EAAAC,EAAAE,EA7BA,EA6BAC,EAAAF,EAAAG,IAGA,OAAAH,sCCDAb,EAAAC,KAAA,UACAD,EAAAE,KAAA,iBACAF,EAAAG,QA3DA,SAAAC,EAAAC,EAAAC,GACA,IAAAW,EAAAX,EAAmBE,EAAQ,MAC3BU,EAAAZ,EAAsBE,EAAQ,MAC9BW,EAAAb,EAAoBE,EAAQ,MAmD5B,OAjCA,SAAAY,EAAAC,EAAAT,EAAAU,EAAAC,GAEA,IAQAC,EAAAC,EAAAC,EARAC,EAAAP,EAAAQ,KACAC,EAAAT,EAAAU,MAEAC,EAAAV,EAAAW,OACAC,EAAAZ,EAAAO,KAEAlB,EAAAmB,EAAA,GAIAK,EAAAxB,EAEA,IAAAe,EAAAQ,EAAArB,GAAAc,EAAAO,EAAArB,EAAA,GAAAY,EAAAC,EAAgDD,EAAAE,EAAQF,IAAA,CAExD,IAAAW,EAAAJ,EAAAP,GAEAN,EAAAS,EAAAQ,KAEAD,EAAAjB,EAAAkB,EAAAf,EAAAc,EAAAZ,EAAAC,IAKA,IAAAC,EAAAU,EAAiBV,EAAAd,EAAOc,IAExBL,EAAAQ,EAAAL,EAAAE,IAGA,OAAAU","file":"js/d8fd31379ebec9d20472.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load) {\n  var csTdfs = load(require('./csTdfs'));\n  /**\n   * Post order a tree of forest\n   *\n   * @param {Array}   parent          The tree or forest\n   * @param {Number}  n               Number of columns\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csPost = function csPost(parent, n) {\n    // check inputs\n    if (!parent) {\n      return null;\n    } // vars\n\n\n    var k = 0;\n    var j; // allocate result\n\n    var post = []; // (n)\n    // workspace, head: first n entries, next: next n entries, stack: last n entries\n\n    var w = []; // (3 * n)\n\n    var head = 0;\n    var next = n;\n    var stack = 2 * n; // initialize workspace\n\n    for (j = 0; j < n; j++) {\n      // empty linked lists\n      w[head + j] = -1;\n    } // traverse nodes in reverse order\n\n\n    for (j = n - 1; j >= 0; j--) {\n      // check j is a root\n      if (parent[j] === -1) {\n        continue;\n      } // add j to list of its parent\n\n\n      w[next + j] = w[head + parent[j]];\n      w[head + parent[j]] = j;\n    } // loop nodes\n\n\n    for (j = 0; j < n; j++) {\n      // skip j if it is not a root\n      if (parent[j] !== -1) {\n        continue;\n      } // depth-first search\n\n\n      k = csTdfs(j, k, w, head, next, post, stack);\n    }\n\n    return post;\n  };\n\n  return csPost;\n}\n\nexports.name = 'csPost';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load) {\n  var csDfs = load(require('./csDfs'));\n  var csMarked = load(require('./csMarked'));\n  var csMark = load(require('./csMark'));\n  /**\n   * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n   * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n   * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   pinv            The inverse row permutation vector\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csReach = function csReach(g, b, k, xi, pinv) {\n    // g arrays\n    var gptr = g._ptr;\n    var gsize = g._size; // b arrays\n\n    var bindex = b._index;\n    var bptr = b._ptr; // columns\n\n    var n = gsize[1]; // vars\n\n    var p, p0, p1; // initialize top\n\n    var top = n; // loop column indeces in B\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      // node i\n      var i = bindex[p]; // check node i is marked\n\n      if (!csMarked(gptr, i)) {\n        // start a dfs at unmarked node i\n        top = csDfs(i, g, top, xi, pinv);\n      }\n    } // loop columns from top -> n - 1\n\n\n    for (p = top; p < n; p++) {\n      // restore G\n      csMark(gptr, xi[p]);\n    }\n\n    return top;\n  };\n\n  return csReach;\n}\n\nexports.name = 'csReach';\nexports.path = 'algebra.sparse';\nexports.factory = factory;"],"sourceRoot":""}