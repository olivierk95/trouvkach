{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/decomposition/qr.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/function/algebra/decomposition/lup.js"],"names":["exports","name","factory","type","config","load","typed","matrix","__webpack_require__","zeros","identity","isZero","unequal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtract","_denseQR","m","i","j","k","rows","_size","cols","Q","Qdata","_data","R","clone","Rdata","w","Math","min","pivot","sgn","conjSgn","alphaSquared","alpha","u1","tau","s","Error","toString","this","DenseMatrix","SparseMatrix","_sparseQR","Array","a","r","valueOf","object","abs","larger","equalScalar","Spa","_denseLUP","columns","n","data","ldata","lsize","udata","usize","p","pi","pabsv","vjj","v","absv","_swapRows","vij","l","size","u","pv","length","L","U","_sparseLUP","values","_values","index","_index","ptr","_ptr","lvalues","lindex","lptr","uvalues","uindex","uptr","pvCo","pvOc","_loop","spa","push","k0","k1","set","forEach","vkj","_forEachRow","vik","accumulate","x","y","kx","ky","get","swap"],"mappings":"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","file":"js/a7bf01502cf93299914f.js","sourcesContent":["'use strict';\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n  var zeros = load(require('../../matrix/zeros'));\n  var identity = load(require('../../matrix/identity'));\n  var isZero = load(require('../../utils/isZero'));\n  var unequal = load(require('../../relational/unequal'));\n  var sign = load(require('../../arithmetic/sign'));\n  var sqrt = load(require('../../arithmetic/sqrt'));\n  var conj = load(require('../../complex/conj'));\n  var unaryMinus = load(require('../../arithmetic/unaryMinus'));\n  var addScalar = load(require('../../arithmetic/addScalar'));\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  /**\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\n   * two matrices (`Q`, `R`) where `Q` is an\n   * orthogonal matrix and `R` is an upper triangular matrix.\n   *\n   * Syntax:\n   *\n   *    math.qr(A)\n   *\n   * Example:\n   *\n   *    const m = [\n   *      [1, -1,  4],\n   *      [1,  4, -2],\n   *      [1,  4,  2],\n   *      [1,  -1, 0]\n   *    ]\n   *    const result = math.qr(m)\n   *    // r = {\n   *    //   Q: [\n   *    //     [0.5, -0.5,   0.5],\n   *    //     [0.5,  0.5,  -0.5],\n   *    //     [0.5,  0.5,   0.5],\n   *    //     [0.5, -0.5,  -0.5],\n   *    //   ],\n   *    //   R: [\n   *    //     [2, 3,  2],\n   *    //     [0, 5, -2],\n   *    //     [0, 0,  4],\n   *    //     [0, 0,  0]\n   *    //   ]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lusolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array\n   * for which to get the QR decomposition.\n   *\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\n   * matrix and R: the upper triangular matrix\n   */\n\n  var qr = typed('qr', {\n    'DenseMatrix': function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    'SparseMatrix': function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    'Array': function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseQR(m); // result\n\n\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  });\n\n  function _denseQR(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data; // vars\n\n    var i, j, k;\n    var w = zeros([rows], '');\n\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\n       * **k-th Household matrix**\n       *\n       * The matrix I - 2*v*transpose(v)\n       * x     = first column of A\n       * x1    = first element of x\n       * alpha = x1 / |x1| * |x|\n       * e1    = tranpose([1, 0, 0, ...])\n       * u     = x - alpha * e1\n       * v     = u / |u|\n       *\n       * Household matrix = I - 2 * v * tranpose(v)\n       *\n       *  * Initially Q = I and R = A.\n       *  * Household matrix is a reflection in a plane normal to v which\n       *    will zero out all but the top right element in R.\n       *  * Appplying reflection to both Q and R will not change product.\n       *  * Repeat this process on the (1,1) minor to get R as an upper\n       *    triangular matrix.\n       *  * Reflections leave the magnitude of the columns of Q unchanged\n       *    so Q remains othoganal.\n       *\n       */\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n\n        w[k] = 1;\n\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        } // tau = - conj(u1 / alpha)\n\n\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n        /*\n         * tau and w have been choosen so that\n         *\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\n         */\n\n        /*\n         * -- calculate R = R - tau * w * tranpose(w) * R --\n         * Only do calculation with rows k to (rows-1)\n         * Additionally columns 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n        for (j = k; j < cols; j++) {\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\n\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          } // calculate the jth element of [tau * transpose(w) * R]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\n         * Q is a square matrix (rows x rows)\n         * Only do calculation with columns k to (rows-1)\n         * Additionally rows 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n\n        for (i = 0; i < rows; i++) {\n          s = 0.0; // calculate ith element of [Q * w]\n\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          } // calculate the ith element of [tau * Q * w]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    } // coerse almost zero elements to zero\n    // TODO I feel uneasy just zeroing these values\n\n\n    for (i = 0; i < rows; ++i) {\n      for (j = 0; j < i && j < cols; ++j) {\n        if (unequal(0, divideScalar(Rdata[i][j], 1e5))) {\n          throw new Error('math.qr(): unknown error - ' + 'R is not lower triangular (element (' + i + ', ' + j + ')  = ' + Rdata[i][j] + ')');\n        }\n\n        Rdata[i][j] = multiplyScalar(Rdata[i][j], 0);\n      }\n    } // return matrices\n\n\n    return {\n      Q: Q,\n      R: R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n\n  return qr;\n}\n\nexports.name = 'qr';\nexports.factory = factory;","'use strict';\n\nvar util = require('../../../utils/index');\n\nvar object = util.object;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n  var abs = load(require('../../arithmetic/abs'));\n  var addScalar = load(require('../../arithmetic/addScalar'));\n  var divideScalar = load(require('../../arithmetic/divideScalar'));\n  var multiplyScalar = load(require('../../arithmetic/multiplyScalar'));\n  var subtract = load(require('../../arithmetic/subtract'));\n  var larger = load(require('../../relational/larger'));\n  var equalScalar = load(require('../../relational/equalScalar'));\n  var unaryMinus = load(require('../../arithmetic/unaryMinus'));\n  var SparseMatrix = type.SparseMatrix;\n  var DenseMatrix = type.DenseMatrix;\n  var Spa = type.Spa;\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n\n  var lup = typed('lup', {\n    'DenseMatrix': function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    'SparseMatrix': function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    'Array': function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = object.clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  return lup;\n}\n\nexports.name = 'lup';\nexports.factory = factory;"],"sourceRoot":""}