{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/typeof.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/index.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isPrime.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isInteger.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isNumeric.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isZero.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isNegative.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isPositive.js","webpack:////home/badou/trouvkach/node_modules/mathjs/lib/function/utils/isNaN.js"],"names":["_typeof2","obj","Symbol","iterator","constructor","prototype","exports","name","factory","type","config","load","typed","_typeof","any","x","t","Array","isArray","Date","RegExp","isBigNumber","isComplex","isFraction","isMatrix","isUnit","isIndex","isRange","isResultSet","isNode","isChain","isHelp","toTex","undefined","module","__webpack_require__","deepMap","isPrime","number","i","BigNumber","lt","equals","mod","isZero","times","lte","plus","Array | Matrix","isInteger","isInt","Fraction","d","isFinite","n","isNumeric","number | BigNumber | Fraction | boolean","Complex | Unit | string | null | undefined | Node","Complex","re","im","Unit","value","isNegative","isNeg","isNaN","s","isPositive","Number"],"mappings":"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","file":"js/f6b55559172e546d519c.js","sourcesContent":["'use strict';\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Determine the type of a variable.\n   *\n   * Function `typeof` recognizes the following types of objects:\n   *\n   * Object                 | Returns       | Example\n   * ---------------------- | ------------- | ------------------------------------------\n   * null                   | `'null'`      | `math.typeof(null)`\n   * number                 | `'number'`    | `math.typeof(3.5)`\n   * boolean                | `'boolean'`   | `math.typeof(true)`\n   * string                 | `'string'`    | `math.typeof('hello world')`\n   * Array                  | `'Array'`     | `math.typeof([1, 2, 3])`\n   * Date                   | `'Date'`      | `math.typeof(new Date())`\n   * Function               | `'Function'`  | `math.typeof(function () {})`\n   * Object                 | `'Object'`    | `math.typeof({a: 2, b: 3})`\n   * RegExp                 | `'RegExp'`    | `math.typeof(/a regexp/)`\n   * undefined              | `'undefined'` | `math.typeof(undefined)`\n   * math.type.BigNumber    | `'BigNumber'` | `math.typeof(math.bignumber('2.3e500'))`\n   * math.type.Chain        | `'Chain'`     | `math.typeof(math.chain(2))`\n   * math.type.Complex      | `'Complex'`   | `math.typeof(math.complex(2, 3))`\n   * math.type.Fraction     | `'Fraction'`  | `math.typeof(math.fraction(1, 3))`\n   * math.type.Help         | `'Help'`      | `math.typeof(math.help('sqrt'))`\n   * math.type.Help         | `'Help'`      | `math.typeof(math.help('sqrt'))`\n   * math.type.Index        | `'Index'`     | `math.typeof(math.index(1, 3))`\n   * math.type.Matrix       | `'Matrix'`    | `math.typeof(math.matrix([[1,2], [3, 4]]))`\n   * math.type.Range        | `'Range'`     | `math.typeof(math.range(0, 10))`\n   * math.type.ResultSet    | `'ResultSet'` | `math.typeof(math.eval('a=2\\nb=3'))`\n   * math.type.Unit         | `'Unit'`      | `math.typeof(math.unit('45 deg'))`\n   * math.expression.node&#8203;.AccessorNode            | `'AccessorNode'`            | `math.typeof(math.parse('A[2]'))`\n   * math.expression.node&#8203;.ArrayNode               | `'ArrayNode'`               | `math.typeof(math.parse('[1,2,3]'))`\n   * math.expression.node&#8203;.AssignmentNode          | `'AssignmentNode'`          | `math.typeof(math.parse('x=2'))`\n   * math.expression.node&#8203;.BlockNode               | `'BlockNode'`               | `math.typeof(math.parse('a=2; b=3'))`\n   * math.expression.node&#8203;.ConditionalNode         | `'ConditionalNode'`         | `math.typeof(math.parse('x<0 ? -x : x'))`\n   * math.expression.node&#8203;.ConstantNode            | `'ConstantNode'`            | `math.typeof(math.parse('2.3'))`\n   * math.expression.node&#8203;.FunctionAssignmentNode  | `'FunctionAssignmentNode'`  | `math.typeof(math.parse('f(x)=x^2'))`\n   * math.expression.node&#8203;.FunctionNode            | `'FunctionNode'`            | `math.typeof(math.parse('sqrt(4)'))`\n   * math.expression.node&#8203;.IndexNode               | `'IndexNode'`               | `math.typeof(math.parse('A[2]').index)`\n   * math.expression.node&#8203;.ObjectNode              | `'ObjectNode'`              | `math.typeof(math.parse('{a:2}'))`\n   * math.expression.node&#8203;.ParenthesisNode         | `'ParenthesisNode'`         | `math.typeof(math.parse('(2+3)'))`\n   * math.expression.node&#8203;.RangeNode               | `'RangeNode'`               | `math.typeof(math.parse('1:10'))`\n   * math.expression.node&#8203;.SymbolNode              | `'SymbolNode'`              | `math.typeof(math.parse('x'))`\n   *\n   * Syntax:\n   *\n   *    math.typeof(x)\n   *\n   * Examples:\n   *\n   *    math.typeof(3.5)                     // returns 'number'\n   *    math.typeof(math.complex('2-4i'))    // returns 'Complex'\n   *    math.typeof(math.unit('45 deg'))     // returns 'Unit'\n   *    math.typeof('hello world')           // returns 'string'\n   *\n   * @param {*} x     The variable for which to test the type.\n   * @return {string} Returns the name of the type. Primitive types are lower case,\n   *                  non-primitive types are upper-camel-case.\n   *                  For example 'number', 'string', 'Array', 'Date'.\n   */\n  var _typeof = typed('_typeof', {\n    'any': function any(x) {\n      var t = _typeof2(x);\n\n      if (t === 'object') {\n        // JavaScript types\n        if (x === null) return 'null';\n        if (Array.isArray(x)) return 'Array';\n        if (x instanceof Date) return 'Date';\n        if (x instanceof RegExp) return 'RegExp'; // math.js types\n\n        if (type.isBigNumber(x)) return 'BigNumber';\n        if (type.isComplex(x)) return 'Complex';\n        if (type.isFraction(x)) return 'Fraction';\n        if (type.isMatrix(x)) return 'Matrix';\n        if (type.isUnit(x)) return 'Unit';\n        if (type.isIndex(x)) return 'Index';\n        if (type.isRange(x)) return 'Range';\n        if (type.isResultSet(x)) return 'ResultSet';\n        if (type.isNode(x)) return x.type;\n        if (type.isChain(x)) return 'Chain';\n        if (type.isHelp(x)) return 'Help';\n        return 'Object';\n      }\n\n      if (t === 'function') return 'Function';\n      return t; // can be 'string', 'number', 'boolean', ...\n    }\n  });\n\n  _typeof.toTex = undefined; // use default template\n\n  return _typeof;\n}\n\nexports.name = 'typeof';\nexports.factory = factory;","'use strict';\n\nmodule.exports = [require('./clone'), require('./isInteger'), require('./isNegative'), require('./isNumeric'), require('./hasNumericValue'), require('./isPositive'), require('./isPrime'), require('./isZero'), require('./isNaN'), require('./typeof')];","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is prime: has no divisors other than itself and one.\n   * The function supports type `number`, `bignumber`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isPrime(x)\n   *\n   * Examples:\n   *\n   *    math.isPrime(3)                     // returns true\n   *    math.isPrime(-2)                    // returns false\n   *    math.isPrime(0)                     // returns false\n   *    math.isPrime(-0)                    // returns false\n   *    math.isPrime(0.5)                   // returns false\n   *    math.isPrime('2')                   // returns true\n   *    math.isPrime([2, 17, 100])           // returns [true, true, false]\n   *\n   * See also:\n   *\n   *    isNumeric, isZero, isNegative, isInteger\n   *\n   * @param {number | BigNumber | Array | Matrix} x  Value to be tested\n   * @return {boolean}  Returns true when `x` is larger than zero.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isPrime = typed('isPrime', {\n    'number': function number(x) {\n      if (x < 2) {\n        return false;\n      }\n\n      if (x === 2) {\n        return true;\n      }\n\n      if (x % 2 === 0) {\n        return false;\n      }\n\n      for (var i = 3; i * i <= x; i += 2) {\n        if (x % i === 0) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    'BigNumber': function BigNumber(x) {\n      if (x.lt(2)) {\n        return false;\n      }\n\n      if (x.equals(2)) {\n        return true;\n      }\n\n      if (x.mod(2).isZero()) {\n        return false;\n      }\n\n      for (var i = type.BigNumber(3); i.times(i).lte(x); i = i.plus(1)) {\n        if (x.mod(i).isZero()) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isPrime);\n    }\n  });\n  return isPrime;\n}\n\nexports.name = 'isPrime';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nvar number = require('../../utils/number');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is an integer number.\n   * The function supports `number`, `BigNumber`, and `Fraction`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isInteger(x)\n   *\n   * Examples:\n   *\n   *    math.isInteger(2)                     // returns true\n   *    math.isInteger(0)                     // returns true\n   *    math.isInteger(0.5)                   // returns false\n   *    math.isInteger(math.bignumber(500))   // returns true\n   *    math.isInteger(math.fraction(4))      // returns true\n   *    math.isInteger('3')                   // returns true\n   *    math.isInteger([3, 0.5, -2])          // returns [true, false, true]\n   *    math.isInteger(math.complex('2-4i')   // throws an error\n   *\n   * See also:\n   *\n   *    isNumeric, isPositive, isNegative, isZero\n   *\n   * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested\n   * @return {boolean}  Returns true when `x` contains a numeric, integer value.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isInteger = typed('isInteger', {\n    'number': number.isInteger,\n    // TODO: what to do with isInteger(add(0.1, 0.2))  ?\n    'BigNumber': function BigNumber(x) {\n      return x.isInt();\n    },\n    'Fraction': function Fraction(x) {\n      return x.d === 1 && isFinite(x.n);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isInteger);\n    }\n  });\n  return isInteger;\n}\n\nexports.name = 'isInteger';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is an numeric value.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isNumeric(x)\n   *\n   * Examples:\n   *\n   *    math.isNumeric(2)                     // returns true\n   *    math.isNumeric('2')                   // returns true\n   *    math.hasNumericValue('2')             // returns true\n   *    math.isNumeric(0)                     // returns true\n   *    math.isNumeric(math.bignumber(500))   // returns true\n   *    math.isNumeric(math.fraction(4))      // returns true\n   *    math.isNumeric(math.complex('2-4i')   // returns false\n   *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]\n   *\n   * See also:\n   *\n   *    isZero, isPositive, isNegative, isInteger, hasNumericValue\n   *\n   * @param {*} x       Value to be tested\n   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,\n   *                    `Fraction`, or `boolean`. Returns false for other types.\n   *                    Throws an error in case of unknown types.\n   */\n  var isNumeric = typed('isNumeric', {\n    'number | BigNumber | Fraction | boolean': function numberBigNumberFractionBoolean() {\n      return true;\n    },\n    'Complex | Unit | string | null | undefined | Node': function ComplexUnitStringNullUndefinedNode() {\n      return false;\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isNumeric);\n    }\n  });\n  return isNumeric;\n}\n\nexports.name = 'isNumeric';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is zero.\n   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,\n   * `Complex`, and `Unit`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isZero(x)\n   *\n   * Examples:\n   *\n   *    math.isZero(0)                     // returns true\n   *    math.isZero(2)                     // returns false\n   *    math.isZero(0.5)                   // returns false\n   *    math.isZero(math.bignumber(0))     // returns true\n   *    math.isZero(math.fraction(0))      // returns true\n   *    math.isZero(math.fraction(1,3))    // returns false\n   *    math.isZero(math.complex('2 - 4i') // returns false\n   *    math.isZero(math.complex('0i')     // returns true\n   *    math.isZero('0')                   // returns true\n   *    math.isZero('2')                   // returns false\n   *    math.isZero([2, 0, -3]')           // returns [false, true, false]\n   *\n   * See also:\n   *\n   *    isNumeric, isPositive, isNegative, isInteger\n   *\n   * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested\n   * @return {boolean}  Returns true when `x` is zero.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isZero = typed('isZero', {\n    'number': function number(x) {\n      return x === 0;\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.isZero();\n    },\n    'Complex': function Complex(x) {\n      return x.re === 0 && x.im === 0;\n    },\n    'Fraction': function Fraction(x) {\n      return x.d === 1 && x.n === 0;\n    },\n    'Unit': function Unit(x) {\n      return isZero(x.value);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isZero);\n    }\n  });\n  return isZero;\n}\n\nexports.name = 'isZero';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is negative: smaller than zero.\n   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isNegative(x)\n   *\n   * Examples:\n   *\n   *    math.isNegative(3)                     // returns false\n   *    math.isNegative(-2)                    // returns true\n   *    math.isNegative(0)                     // returns false\n   *    math.isNegative(-0)                    // returns false\n   *    math.isNegative(math.bignumber(2))     // returns false\n   *    math.isNegative(math.fraction(-2, 5))  // returns true\n   *    math.isNegative('-2')                  // returns true\n   *    math.isNegative([2, 0, -3]')           // returns [false, false, true]\n   *\n   * See also:\n   *\n   *    isNumeric, isPositive, isZero, isInteger\n   *\n   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested\n   * @return {boolean}  Returns true when `x` is larger than zero.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isNegative = typed('isNegative', {\n    'number': function number(x) {\n      return x < 0;\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.isNeg() && !x.isZero() && !x.isNaN();\n    },\n    'Fraction': function Fraction(x) {\n      return x.s < 0; // It's enough to decide on the sign\n    },\n    'Unit': function Unit(x) {\n      return isNegative(x.value);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isNegative);\n    }\n  });\n  return isNegative;\n}\n\nexports.name = 'isNegative';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is positive: larger than zero.\n   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isPositive(x)\n   *\n   * Examples:\n   *\n   *    math.isPositive(3)                     // returns true\n   *    math.isPositive(-2)                    // returns false\n   *    math.isPositive(0)                     // returns false\n   *    math.isPositive(-0)                    // returns false\n   *    math.isPositive(0.5)                   // returns true\n   *    math.isPositive(math.bignumber(2))     // returns true\n   *    math.isPositive(math.fraction(-2, 5))  // returns false\n   *    math.isPositive(math.fraction(1,3))    // returns false\n   *    math.isPositive('2')                   // returns true\n   *    math.isPositive([2, 0, -3])            // returns [true, false, false]\n   *\n   * See also:\n   *\n   *    isNumeric, isZero, isNegative, isInteger\n   *\n   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested\n   * @return {boolean}  Returns true when `x` is larger than zero.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isPositive = typed('isPositive', {\n    'number': function number(x) {\n      return x > 0;\n    },\n    'BigNumber': function BigNumber(x) {\n      return !x.isNeg() && !x.isZero() && !x.isNaN();\n    },\n    'Fraction': function Fraction(x) {\n      return x.s > 0 && x.n > 0;\n    },\n    'Unit': function Unit(x) {\n      return isPositive(x.value);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, isPositive);\n    }\n  });\n  return isPositive;\n}\n\nexports.name = 'isPositive';\nexports.factory = factory;","'use strict';\n\nvar deepMap = require('../../utils/collection/deepMap');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Test whether a value is NaN (not a number).\n   * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.\n   *\n   * The function is evaluated element-wise in case of Array or Matrix input.\n   *\n   * Syntax:\n   *\n   *     math.isNaN(x)\n   *\n   * Examples:\n   *\n   *    math.isNaN(3)                     // returns false\n   *    math.isNaN(NaN)                   // returns true\n   *    math.isNaN(0)                     // returns false\n   *    math.isNaN(math.bignumber(NaN))   // returns true\n   *    math.isNaN(math.bignumber(0))     // returns false\n   *    math.isNaN(math.fraction(-2, 5))  // returns false\n   *    math.isNaN('-2')                  // returns false\n   *    math.isNaN([2, 0, -3, NaN]')      // returns [false, false, false, true]\n   *\n   * See also:\n   *\n   *    isNumeric, isNegative, isPositive, isZero, isInteger\n   *\n   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested\n   * @return {boolean}  Returns true when `x` is NaN.\n   *                    Throws an error in case of an unknown data type.\n   */\n  var isNaN = typed('isNaN', {\n    'number': function number(x) {\n      return Number.isNaN(x);\n    },\n    'BigNumber': function BigNumber(x) {\n      return x.isNaN();\n    },\n    'Fraction': function Fraction(x) {\n      return false;\n    },\n    'Complex': function Complex(x) {\n      return x.isNaN();\n    },\n    'Unit': function Unit(x) {\n      return Number.isNaN(x.value);\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return deepMap(x, Number.isNaN);\n    }\n  });\n  return isNaN;\n}\n\nexports.name = 'isNaN';\nexports.factory = factory;"],"sourceRoot":""}