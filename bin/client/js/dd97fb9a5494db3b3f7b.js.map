{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/core/typed.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","typedFunction","__webpack_require__","digits","isBigNumber","isMatrix","_createTyped","create","exports","type","isNumber","x","isComplex","Complex","isFraction","Fraction","isUnit","isString","isArray","Array","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","Date","isRegExp","RegExp","isObject","Object","isNull","isUndefined","undefined","isAccessorNode","isNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","isFunctionAssignmentNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","isParenthesisNode","isRangeNode","isSymbolNode","isChain","typed","types","name","test","conversions","from","to","convert","TypeError","BigNumber","toNumber","valueOf","n","Number","isNaN","Error","err","array","DenseMatrix","matrix"],"mappings":"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","file":"js/dd97fb9a5494db3b3f7b.js","sourcesContent":["'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar typedFunction = require('typed-function');\n\nvar digits = require('./../utils/number').digits;\n\nvar isBigNumber = require('./../utils/bignumber/isBigNumber');\n\nvar isMatrix = require('./../utils/collection/isMatrix'); // returns a new instance of typed-function\n\n\nvar _createTyped = function createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped = typedFunction.create;\n  return typedFunction;\n};\n/**\n * Factory function for creating a new typed instance\n * @param {Object} type   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\n\nexports.create = function create(type) {\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // type checks for all known types\n  //\n  // note that:\n  //\n  // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\n  //   instanceof cannot be used because that would not allow to pass data from\n  //   one instance of math.js to another since each has it's own instance of Unit.\n  // - check the `isUnit` property via the constructor, so there will be no\n  //   matches for \"fake\" instances like plain objects with a property `isUnit`.\n  //   That is important for security reasons.\n  // - It must not be possible to override the type checks used internally,\n  //   for security reasons, so these functions are not exposed in the expression\n  //   parser.\n  type.isNumber = function (x) {\n    return typeof x === 'number';\n  };\n\n  type.isComplex = function (x) {\n    return type.Complex && x instanceof type.Complex || false;\n  };\n\n  type.isBigNumber = isBigNumber;\n\n  type.isFraction = function (x) {\n    return type.Fraction && x instanceof type.Fraction || false;\n  };\n\n  type.isUnit = function (x) {\n    return x && x.constructor.prototype.isUnit || false;\n  };\n\n  type.isString = function (x) {\n    return typeof x === 'string';\n  };\n\n  type.isArray = Array.isArray;\n  type.isMatrix = isMatrix;\n\n  type.isDenseMatrix = function (x) {\n    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix || false;\n  };\n\n  type.isSparseMatrix = function (x) {\n    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix || false;\n  };\n\n  type.isRange = function (x) {\n    return x && x.constructor.prototype.isRange || false;\n  };\n\n  type.isIndex = function (x) {\n    return x && x.constructor.prototype.isIndex || false;\n  };\n\n  type.isBoolean = function (x) {\n    return typeof x === 'boolean';\n  };\n\n  type.isResultSet = function (x) {\n    return x && x.constructor.prototype.isResultSet || false;\n  };\n\n  type.isHelp = function (x) {\n    return x && x.constructor.prototype.isHelp || false;\n  };\n\n  type.isFunction = function (x) {\n    return typeof x === 'function';\n  };\n\n  type.isDate = function (x) {\n    return x instanceof Date;\n  };\n\n  type.isRegExp = function (x) {\n    return x instanceof RegExp;\n  };\n\n  type.isObject = function (x) {\n    return _typeof(x) === 'object' && x.constructor === Object && !type.isComplex(x) && !type.isFraction(x);\n  };\n\n  type.isNull = function (x) {\n    return x === null;\n  };\n\n  type.isUndefined = function (x) {\n    return x === undefined;\n  };\n\n  type.isAccessorNode = function (x) {\n    return x && x.isAccessorNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isArrayNode = function (x) {\n    return x && x.isArrayNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isAssignmentNode = function (x) {\n    return x && x.isAssignmentNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isBlockNode = function (x) {\n    return x && x.isBlockNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isConditionalNode = function (x) {\n    return x && x.isConditionalNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isConstantNode = function (x) {\n    return x && x.isConstantNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isFunctionAssignmentNode = function (x) {\n    return x && x.isFunctionAssignmentNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isFunctionNode = function (x) {\n    return x && x.isFunctionNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isIndexNode = function (x) {\n    return x && x.isIndexNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isNode = function (x) {\n    return x && x.isNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isObjectNode = function (x) {\n    return x && x.isObjectNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isOperatorNode = function (x) {\n    return x && x.isOperatorNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isParenthesisNode = function (x) {\n    return x && x.isParenthesisNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isRangeNode = function (x) {\n    return x && x.isRangeNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isSymbolNode = function (x) {\n    return x && x.isSymbolNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isChain = function (x) {\n    return x && x.constructor.prototype.isChain || false;\n  }; // get a new instance of typed-function\n\n\n  var typed = _createTyped(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: type.isNumber\n  }, {\n    name: 'Complex',\n    test: type.isComplex\n  }, {\n    name: 'BigNumber',\n    test: type.isBigNumber\n  }, {\n    name: 'Fraction',\n    test: type.isFraction\n  }, {\n    name: 'Unit',\n    test: type.isUnit\n  }, {\n    name: 'string',\n    test: type.isString\n  }, {\n    name: 'Array',\n    test: type.isArray\n  }, {\n    name: 'Matrix',\n    test: type.isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: type.isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: type.isSparseMatrix\n  }, {\n    name: 'Range',\n    test: type.isRange\n  }, {\n    name: 'Index',\n    test: type.isIndex\n  }, {\n    name: 'boolean',\n    test: type.isBoolean\n  }, {\n    name: 'ResultSet',\n    test: type.isResultSet\n  }, {\n    name: 'Help',\n    test: type.isHelp\n  }, {\n    name: 'function',\n    test: type.isFunction\n  }, {\n    name: 'Date',\n    test: type.isDate\n  }, {\n    name: 'RegExp',\n    test: type.isRegExp\n  }, {\n    name: 'null',\n    test: type.isNull\n  }, {\n    name: 'undefined',\n    test: type.isUndefined\n  }, {\n    name: 'OperatorNode',\n    test: type.isOperatorNode\n  }, {\n    name: 'ConstantNode',\n    test: type.isConstantNode\n  }, {\n    name: 'SymbolNode',\n    test: type.isSymbolNode\n  }, {\n    name: 'ParenthesisNode',\n    test: type.isParenthesisNode\n  }, {\n    name: 'FunctionNode',\n    test: type.isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: type.isFunctionAssignmentNode\n  }, {\n    name: 'ArrayNode',\n    test: type.isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: type.isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: type.isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: type.isConditionalNode\n  }, {\n    name: 'IndexNode',\n    test: type.isIndexNode\n  }, {\n    name: 'RangeNode',\n    test: type.isRangeNode\n  }, {\n    name: 'Node',\n    test: type.isNode\n  }, {\n    name: 'Object',\n    test: type.isObject // order 'Object' last, it matches on other classes too\n\n  }]; // TODO: add conversion from BigNumber to number?\n\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      // note: conversion from number to BigNumber can fail if x has >15 digits\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new type.BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      var f = new type.Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return new type.Fraction(x);\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      try {\n        return new type.BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      try {\n        return new type.Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      try {\n        return new type.Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      return new type.BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      return new type.Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      return new type.DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n};"],"sourceRoot":""}