{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/matrix/index.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/matrix/kron.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/matrix/getMatrixDataType.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/matrix/identity.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/function/matrix/inv.js"],"names":["module","exports","__webpack_require__","size","name","factory","type","config","load","typed","matrix","multiplyScalar","Matrix, Matrix","x","y","_kron","toArray","Matrix, Array","Array, Matrix","Array, Array","a","b","length","RangeError","JSON","stringify","t","r","map","push","getArrayDataType","Array","Matrix","getDataType","array","isInteger","identity","","string","format","number | BigNumber","rows","_identity","undefined","number | BigNumber, string","number | BigNumber, number | BigNumber","cols","number | BigNumber, number | BigNumber, string","_identityVector","Array, string","valueOf","storage","Matrix, string","toTex","Error","Big","isBigNumber","BigNumber","toNumber","one","defaultValue","diagonal","res","resize","minimum","d","util","divideScalar","addScalar","multiply","unaryMinus","det","abs","inv","Array | Matrix","isMatrix","_inv","any","mat","s","f","value","temp","A","concat","B","c","ABig","rBig","Ac","Bc","Ar","Br","1"],"mappings":"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","file":"js/c7b3002a8afcca25819c.js","sourcesContent":["'use strict';\n\nmodule.exports = [require('./concat'), require('./cross'), require('./ctranspose'), require('./det'), require('./diag'), require('./dot'), require('./eye'), require('./expm'), require('./filter'), require('./flatten'), require('./forEach'), require('./identity'), require('./inv'), require('./kron'), require('./map'), require('./ones'), require('./partitionSelect'), require('./range'), require('./reshape'), require('./resize'), require('./size'), require('./sort'), require('./sqrtm'), require('./squeeze'), require('./subset'), require('./trace'), require('./transpose'), require('./zeros'), require('./getMatrixDataType')];","'use strict';\n\nvar size = require('../../utils/array').size;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var multiplyScalar = load(require('../arithmetic/multiplyScalar'));\n  /**\n     * Calculates the kronecker product of 2 matrices or vectors.\n     *\n     * NOTE: If a one dimensional vector / matrix is given, it will be\n     * wrapped so its two dimensions.\n     * See the examples.\n     *\n     * Syntax:\n     *\n     *    math.kron(x, y)\n     *\n     * Examples:\n     *\n     *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])\n     *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]\n     *\n     *    math.kron([1,1], [2,3,4])\n     *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]\n     *\n     * See also:\n     *\n     *    multiply, dot, cross\n     *\n     * @param  {Array | Matrix} x     First vector\n     * @param  {Array | Matrix} y     Second vector\n     * @return {Array | Matrix}       Returns the kronecker product of `x` and `y`\n     */\n\n  var kron = typed('kron', {\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      return matrix(_kron(x.toArray(), y.toArray()));\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      return matrix(_kron(x.toArray(), y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      return matrix(_kron(x, y.toArray()));\n    },\n    'Array, Array': _kron\n  });\n  return kron;\n  /**\n     * Calculate the kronecker product of two matrices / vectors\n     * @param {Array} a  First vector\n     * @param {Array} b  Second vector\n     * @returns {Array} Returns the kronecker product of x and y\n     * @private\n     */\n\n  function _kron(a, b) {\n    // Deal with the dimensions of the matricies.\n    if (size(a).length === 1) {\n      // Wrap it in a 2D Matrix\n      a = [a];\n    }\n\n    if (size(b).length === 1) {\n      // Wrap it in a 2D Matrix\n      b = [b];\n    }\n\n    if (size(a).length > 2 || size(b).length > 2) {\n      throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' + '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');\n    }\n\n    var t = [];\n    var r = [];\n    return a.map(function (a) {\n      return b.map(function (b) {\n        r = [];\n        t.push(r);\n        return a.map(function (y) {\n          return b.map(function (x) {\n            return r.push(multiplyScalar(y, x));\n          });\n        });\n      });\n    }) && t;\n  }\n}\n\nexports.name = 'kron';\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var getArrayDataType = load(require('../../type/matrix/utils/getArrayDataType'));\n  /**\n   * Find the data type of all elements in a matrix or array,\n   * for example 'number' if all items are a number and 'Complex' if all values\n   * are complex numbers.\n   * If a matrix contains more than one data type, it will return 'mixed'.\n   *\n   * Syntax:\n   *\n   *    math.getMatrixDataType(x)\n   *\n   * Examples:\n   *\n   *    const x = [ [1, 2, 3], [4, 5, 6] ]\n   *    const mixedX = [ [1, true], [2, 3] ]\n   *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3] ]\n   *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]\n   *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]\n   *    const sparse = math.sparse(x)\n   *    const dense = math.matrix(x)\n   *    math.getMatrixDataType(x)   // returns 'number'\n   *    math.getMatrixDataType(sparse)   // returns 'number'\n   *    math.getMatrixDataType(dense)   // returns 'number'\n   *    math.getMatrixDataType(mixedX) // returns 'mixed'\n   *    math.getMatrixDataType(fractionX) // returns 'Fraction'\n   *    math.getMatrixDataType(unitX) // returns 'Unit'\n   *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'\n   *\n   * See also:\n   *  SparseMatrix, DenseMatrix\n   *\n   * @param {...Matrix | Array} x   The Matrix with values.\n   *\n   * @return {string} A string representation of the matrix type\n   */\n\n  var getMatrixDataType = typed('getMatrixDataType', {\n    'Array': function Array(x) {\n      return getArrayDataType(x);\n    },\n    'Matrix': function Matrix(x) {\n      return x.getDataType();\n    }\n  });\n  return getMatrixDataType;\n}\n\nexports.name = 'getMatrixDataType';\nexports.factory = factory;","'use strict';\n\nvar array = require('../../utils/array');\n\nvar isInteger = require('../../utils/number').isInteger;\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  /**\n   * Create a 2-dimensional identity matrix with size m x n or n x n.\n   * The matrix has ones on the diagonal and zeros elsewhere.\n   *\n   * Syntax:\n   *\n   *    math.identity(n)\n   *    math.identity(n, format)\n   *    math.identity(m, n)\n   *    math.identity(m, n, format)\n   *    math.identity([m, n])\n   *    math.identity([m, n], format)\n   *\n   * Examples:\n   *\n   *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n   *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]\n   *\n   *    const A = [[1, 2, 3], [4, 5, 6]]\n   *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]\n   *\n   * See also:\n   *\n   *    diag, ones, zeros, size, range\n   *\n   * @param {...number | Matrix | Array} size   The size for the matrix\n   * @param {string} [format]                   The Matrix storage format\n   *\n   * @return {Matrix | Array | number} A matrix with ones on the diagonal.\n   */\n\n  var identity = typed('identity', {\n    '': function _() {\n      return config.matrix === 'Matrix' ? matrix([]) : [];\n    },\n    'string': function string(format) {\n      return matrix(format);\n    },\n    'number | BigNumber': function numberBigNumber(rows) {\n      return _identity(rows, rows, config.matrix === 'Matrix' ? 'default' : undefined);\n    },\n    'number | BigNumber, string': function numberBigNumberString(rows, format) {\n      return _identity(rows, rows, format);\n    },\n    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {\n      return _identity(rows, cols, config.matrix === 'Matrix' ? 'default' : undefined);\n    },\n    'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format) {\n      return _identity(rows, cols, format);\n    },\n    'Array': function Array(size) {\n      return _identityVector(size);\n    },\n    'Array, string': function ArrayString(size, format) {\n      return _identityVector(size, format);\n    },\n    'Matrix': function Matrix(size) {\n      return _identityVector(size.valueOf(), size.storage());\n    },\n    'Matrix, string': function MatrixString(size, format) {\n      return _identityVector(size.valueOf(), format);\n    }\n  });\n  identity.toTex = undefined; // use default template\n\n  return identity;\n\n  function _identityVector(size, format) {\n    switch (size.length) {\n      case 0:\n        return format ? matrix(format) : [];\n\n      case 1:\n        return _identity(size[0], size[0], format);\n\n      case 2:\n        return _identity(size[0], size[1], format);\n\n      default:\n        throw new Error('Vector containing two values expected');\n    }\n  }\n  /**\n   * Create an identity matrix\n   * @param {number | BigNumber} rows\n   * @param {number | BigNumber} cols\n   * @param {string} [format]\n   * @returns {Matrix}\n   * @private\n   */\n\n\n  function _identity(rows, cols, format) {\n    // BigNumber constructor with the right precision\n    var Big = type.isBigNumber(rows) || type.isBigNumber(cols) ? type.BigNumber : null;\n    if (type.isBigNumber(rows)) rows = rows.toNumber();\n    if (type.isBigNumber(cols)) cols = cols.toNumber();\n\n    if (!isInteger(rows) || rows < 1) {\n      throw new Error('Parameters in function identity must be positive integers');\n    }\n\n    if (!isInteger(cols) || cols < 1) {\n      throw new Error('Parameters in function identity must be positive integers');\n    }\n\n    var one = Big ? new type.BigNumber(1) : 1;\n    var defaultValue = Big ? new Big(0) : 0;\n    var size = [rows, cols]; // check we need to return a matrix\n\n    if (format) {\n      // get matrix storage constructor\n      var F = type.Matrix.storage(format); // create diagonal matrix (use optimized implementation for storage format)\n\n      return F.diagonal(size, one, 0, defaultValue);\n    } // create and resize array\n\n\n    var res = array.resize([], size, defaultValue); // fill in ones on the diagonal\n\n    var minimum = rows < cols ? rows : cols; // fill diagonal\n\n    for (var d = 0; d < minimum; d++) {\n      res[d][d] = one;\n    }\n\n    return res;\n  }\n}\n\nexports.name = 'identity';\nexports.factory = factory;","'use strict';\n\nvar util = require('../../utils/index');\n\nfunction factory(type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var divideScalar = load(require('../arithmetic/divideScalar'));\n  var addScalar = load(require('../arithmetic/addScalar'));\n  var multiply = load(require('../arithmetic/multiply'));\n  var unaryMinus = load(require('../arithmetic/unaryMinus'));\n  var det = load(require('../matrix/det'));\n  var identity = load(require('./identity'));\n  var abs = load(require('../arithmetic/abs'));\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n\n  var inv = typed('inv', {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = type.isMatrix(x) ? x.size() : util.array.size(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if (type.isMatrix(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + util.string.format(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          var rows = size[0];\n          var cols = size[1];\n\n          if (rows === cols) {\n            if (type.isMatrix(x)) {\n              return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _inv(x, rows, cols);\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + util.string.format(size) + ')');\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + util.string.format(size) + ')');\n      }\n    },\n    'any': function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      http://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n\n  inv.toTex = {\n    1: \"\\\\left(${args[0]}\\\\right)^{-1}\"\n  };\n  return inv;\n}\n\nexports.name = 'inv';\nexports.factory = factory;"],"sourceRoot":""}