{"version":3,"sources":["webpack:////home/badou/trouvkach/node_modules/mathjs/lib/expression/node/IndexNode.js"],"names":["map","__webpack_require__","escape","exports","name","path","factory","type","config","load","typed","Node","Range","isArray","Array","IndexNode","dimensions","dotNotation","this","SyntaxError","every","isNode","TypeError","isObjectProperty","Error","deprecated","Object","defineProperty","get","set","createRange","start","end","step","isBigNumber","toNumber","prototype","isIndexNode","_compile","math","argNames","evalDimensions","range","i","isRangeNode","needsEnd","childArgNames","create","evalStart","evalEnd","evalStep","scope","args","context","size","valueOf","childArgs","_evalStart","_evalEnd","_evalStep","isSymbolNode","_childArgNames","evalRange","_evalRange","evalDimension","index","apply","forEach","callback","length","_ifNode","clone","slice","isConstantNode","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex"],"mappings":"2FAEA,IAAAA,EAAUC,EAAQ,GAAmBD,IAErCE,EAAaD,EAAQ,GAAoBC,OA+QzCC,EAAAC,KAAA,YACAD,EAAAE,KAAA,kBACAF,EAAAG,QA/QA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAkBR,EAAQ,KAC1BW,EAAAH,EAAmBR,EAAQ,MAC3BY,EAAAC,MAAAD,QAiBA,SAAAE,EAAAC,EAAAC,GACA,KAAAC,gBAAAH,GACA,UAAAI,YAAA,oDAMA,GAHAD,KAAAF,aACAE,KAAAD,gBAAA,GAEAJ,EAAAG,OAAAI,MAAAb,EAAAc,QACA,UAAAC,UAAA,8DAGA,GAAAJ,KAAAD,cAAAC,KAAAK,mBACA,UAAAC,MAAA,qDAIA,IAAAC,EAAA,WACA,UAAAD,MAAA,0EAGAE,OAAAC,eAAAT,KAAA,UACAU,IAAAH,EACAI,IAAAJ,IA2NA,SAAAK,EAAAC,EAAAC,EAAAC,GACA,WAAArB,EAAAL,EAAA2B,YAAAH,KAAAI,WAAAJ,EAAAxB,EAAA2B,YAAAF,KAAAG,WAAAH,EAAAzB,EAAA2B,YAAAD,KAAAE,WAAAF,GAGA,OA3NAlB,EAAAqB,UAAA,IAAAzB,EACAI,EAAAqB,UAAA7B,KAAA,YACAQ,EAAAqB,UAAAC,aAAA,EAeAtB,EAAAqB,UAAAE,SAAA,SAAAC,EAAAC,GAMA,IAAAC,EAAAzC,EAAAkB,KAAAF,WAAA,SAAA0B,EAAAC,GACA,GAAApC,EAAAqC,YAAAF,GAAA,CACA,GAAAA,EAAAG,WAAA,CAEA,IAAAC,EAAApB,OAAAqB,OAAAP,GACAM,EAAA,OAEA,IAAAE,EAAAN,EAAAX,MAAAO,SAAAC,EAAAO,GAEAG,EAAAP,EAAAV,IAAAM,SAAAC,EAAAO,GAEAI,EAAAR,EAAAT,KAAAS,EAAAT,KAAAK,SAAAC,EAAAO,GAAA,WACA,UAEA,gBAAAK,EAAAC,EAAAC,GACA,IAAAC,EAAAf,EAAAe,KAAAD,GAAAE,UACAC,EAAA9B,OAAAqB,OAAAK,GAEA,OADAI,EAAA,IAAAF,EAAAX,GACAb,EAAAkB,EAAAG,EAAAK,EAAAH,GAAAJ,EAAAE,EAAAK,EAAAH,GAAAH,EAAAC,EAAAK,EAAAH,KAIA,IAAAI,EAAAf,EAAAX,MAAAO,SAAAC,EAAAC,GAEAkB,EAAAhB,EAAAV,IAAAM,SAAAC,EAAAC,GAEAmB,EAAAjB,EAAAT,KAAAS,EAAAT,KAAAK,SAAAC,EAAAC,GAAA,WACA,UAGA,gBAAAW,EAAAC,EAAAC,GACA,OAAAvB,EAAA2B,EAAAN,EAAAC,EAAAC,GAAAK,EAAAP,EAAAC,EAAAC,GAAAM,EAAAR,EAAAC,EAAAC,KAGO,GAAA9C,EAAAqD,aAAAlB,IAAA,QAAAA,EAAAtC,KAAA,CAEP,IAAAyD,EAAAnC,OAAAqB,OAAAP,GAEAqB,EAAA,OAEA,IAAAC,EAAApB,EAAAJ,SAAAC,EAAAsB,GAEA,gBAAAV,EAAAC,EAAAC,GACA,IAAAC,EAAAf,EAAAe,KAAAD,GAAAE,UACAC,EAAA9B,OAAAqB,OAAAK,GAEA,OADAI,EAAA,IAAAF,EAAAX,GACAmB,EAAAX,EAAAK,EAAAH,IAIA,IAAAU,EAAArB,EAAAJ,SAAAC,EAAAC,GAEA,gBAAAW,EAAAC,EAAAC,GACA,OAAAU,EAAAZ,EAAAC,EAAAC,MAIA,gBAAAF,EAAAC,EAAAC,GACA,IAAArC,EAAAhB,EAAAyC,EAAA,SAAAuB,GACA,OAAAA,EAAAb,EAAAC,EAAAC,KAEA,OAAAd,EAAA0B,MAAAC,MAAA3B,EAAAvB,KASAD,EAAAqB,UAAA+B,QAAA,SAAAC,GACA,QAAAzB,EAAA,EAAmBA,EAAAzB,KAAAF,WAAAqD,OAA4B1B,IAC/CyB,EAAAlD,KAAAF,WAAA2B,GAAA,cAAAA,EAAA,IAAAzB,OAWAH,EAAAqB,UAAApC,IAAA,SAAAoE,GAGA,IAFA,IAAApD,EAAA,GAEA2B,EAAA,EAAmBA,EAAAzB,KAAAF,WAAAqD,OAA4B1B,IAC/C3B,EAAA2B,GAAAzB,KAAAoD,QAAAF,EAAAlD,KAAAF,WAAA2B,GAAA,cAAAA,EAAA,IAAAzB,OAGA,WAAAH,EAAAC,IAQAD,EAAAqB,UAAAmC,MAAA,WACA,WAAAxD,EAAAG,KAAAF,WAAAwD,MAAA,KAQAzD,EAAAqB,UAAAb,iBAAA,WACA,WAAAL,KAAAF,WAAAqD,QAAA9D,EAAAkE,eAAAvD,KAAAF,WAAA,sBAAAE,KAAAF,WAAA,GAAA0D,OASA3D,EAAAqB,UAAAuC,kBAAA,WACA,OAAAzD,KAAAK,mBAAAL,KAAAF,WAAA,GAAA0D,MAAA,MASA3D,EAAAqB,UAAAwC,UAAA,SAAAC,GAEA,OAAA3D,KAAAD,YAAA,IAAAC,KAAAyD,oBAAA,IAAAzD,KAAAF,WAAA8D,KAAA,WAQA/D,EAAAqB,UAAA2C,OAAA,WACA,OACAC,OAAA,YACAhE,WAAAE,KAAAF,WACAC,YAAAC,KAAAD,cAYAF,EAAAkE,SAAA,SAAAC,GACA,WAAAnE,EAAAmE,EAAAlE,WAAAkE,EAAAjE,cASAF,EAAAqB,UAAA+C,OAAA,SAAAN,GAIA,IAFA,IAAA7D,EAAA,GAEA2B,EAAA,EAAmBA,EAAAzB,KAAAF,WAAAqD,OAA4B1B,IAC/C3B,EAAA2B,GAAAzB,KAAAF,WAAA2B,GAAAwC,SAGA,OAAAjE,KAAAD,YACA,sGAAAf,EAAAgB,KAAAyD,qBAAA,UAEA,kEAAA3D,EAAA8D,KAAA,4GAUA/D,EAAAqB,UAAAgD,OAAA,SAAAP,GACA,IAAA7D,EAAAE,KAAAF,WAAAhB,IAAA,SAAA0C,GACA,OAAAA,EAAA2C,MAAAR,KAEA,OAAA3D,KAAAD,YAAA,IAAAC,KAAAyD,oBAAA,KAAuE3D,EAAA8D,KAAA,UAQvE/D","file":"js/242e8970e078d9fca71e.js","sourcesContent":["'use strict';\n\nvar map = require('../../utils/array').map;\n\nvar escape = require('../../utils/string').escape;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var Range = load(require('../../type/matrix/Range'));\n  var isArray = Array.isArray;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!isArray(dimensions) || !dimensions.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (type.isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames['end'] = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var size = math.size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs['end'] = size[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (type.isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames['end'] = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var size = math.size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs['end'] = size[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return math.index.apply(math, dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0));\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && type.isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(type.isBigNumber(start) ? start.toNumber() : start, type.isBigNumber(end) ? end.toNumber() : end, type.isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}\n\nexports.name = 'IndexNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}