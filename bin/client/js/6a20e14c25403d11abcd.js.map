{"version":3,"sources":["webpack:////home/badou/Desktop/LastDeploy/trouvkach/node_modules/mathjs/lib/expression/node/BlockNode.js"],"names":["forEach","__webpack_require__","map","exports","name","path","factory","type","config","load","typed","Node","ResultSet","BlockNode","blocks","this","SyntaxError","Array","isArray","Error","block","node","visible","undefined","isNode","TypeError","prototype","isBlockNode","_compile","math","argNames","evalBlocks","eval","scope","args","context","results","result","push","callback","i","length","_ifNode","clone","_toString","options","param","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex"],"mappings":"2FAEA,IAAAA,EAAcC,EAAQ,GAAmBD,QAEzCE,EAAUD,EAAQ,GAAmBC,IA0LrCC,EAAAC,KAAA,YACAD,EAAAE,KAAA,kBACAF,EAAAG,QA1LA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAkBR,EAAQ,KAC1BW,EAAAH,EAAuBR,EAAQ,MAW/B,SAAAY,EAAAC,GACA,KAAAC,gBAAAF,GACA,UAAAG,YAAA,oDAIA,IAAAC,MAAAC,QAAAJ,GAAA,UAAAK,MAAA,kBACAJ,KAAAD,SAAAZ,IAAA,SAAAkB,GACA,IAAAC,EAAAD,KAAAC,KACAC,GAAAF,QAAAG,IAAAH,EAAAE,SAAAF,EAAAE,QACA,IAAAf,EAAAiB,OAAAH,GAAA,UAAAI,UAAA,kCACA,qBAAAH,EAAA,UAAAG,UAAA,wCACA,OACAJ,OACAC,aA0JA,OArJAT,EAAAa,UAAA,IAAAf,EACAE,EAAAa,UAAAnB,KAAA,YACAM,EAAAa,UAAAC,aAAA,EAeAd,EAAAa,UAAAE,SAAA,SAAAC,EAAAC,GACA,IAAAC,EAAA7B,EAAAa,KAAAD,OAAA,SAAAM,GACA,OACAY,KAAAZ,EAAAC,KAAAO,SAAAC,EAAAC,GACAR,QAAAF,EAAAE,WAGA,gBAAAW,EAAAC,EAAAC,GACA,IAAAC,EAAA,GAQA,OAPApC,EAAA+B,EAAA,SAAAX,GACA,IAAAiB,EAAAjB,EAAAY,KAAAC,EAAAC,EAAAC,GAEAf,EAAAE,SACAc,EAAAE,KAAAD,KAGA,IAAAzB,EAAAwB,KASAvB,EAAAa,UAAA1B,QAAA,SAAAuC,GACA,QAAAC,EAAA,EAAmBA,EAAAzB,KAAAD,OAAA2B,OAAwBD,IAC3CD,EAAAxB,KAAAD,OAAA0B,GAAAnB,KAAA,UAAAmB,EAAA,SAAAzB,OAWAF,EAAAa,UAAAxB,IAAA,SAAAqC,GAGA,IAFA,IAAAzB,EAAA,GAEA0B,EAAA,EAAmBA,EAAAzB,KAAAD,OAAA2B,OAAwBD,IAAA,CAC3C,IAAApB,EAAAL,KAAAD,OAAA0B,GAEAnB,EAAAN,KAAA2B,QAAAH,EAAAnB,EAAAC,KAAA,UAAAmB,EAAA,SAAAzB,OAEAD,EAAA0B,GAAA,CACAnB,OACAC,QAAAF,EAAAE,SAIA,WAAAT,EAAAC,IAQAD,EAAAa,UAAAiB,MAAA,WAOA,WAAA9B,EANAE,KAAAD,OAAAZ,IAAA,SAAAkB,GACA,OACAC,KAAAD,EAAAC,KACAC,QAAAF,EAAAE,aAaAT,EAAAa,UAAAkB,UAAA,SAAAC,GACA,OAAA9B,KAAAD,OAAAZ,IAAA,SAAA4C,GACA,OAAAA,EAAAzB,KAAA0B,SAAAF,IAAAC,EAAAxB,QAAA,UACK0B,KAAA,OAQLnC,EAAAa,UAAAuB,OAAA,WACA,OACAC,OAAA,YACApC,OAAAC,KAAAD,SAYAD,EAAAsC,SAAA,SAAAC,GACA,WAAAvC,EAAAuC,EAAAtC,SAUAD,EAAAa,UAAA2B,OAAA,SAAAR,GACA,OAAA9B,KAAAD,OAAAZ,IAAA,SAAA4C,GACA,OAAAA,EAAAzB,KAAAgC,OAAAR,IAAAC,EAAAxB,QAAA,8CACK0B,KAAA,+CASLnC,EAAAa,UAAA4B,OAAA,SAAAT,GACA,OAAA9B,KAAAD,OAAAZ,IAAA,SAAA4C,GACA,OAAAA,EAAAzB,KAAAkC,MAAAV,IAAAC,EAAAxB,QAAA,UACK0B,KAAA,aAGLnC","file":"js/6a20e14c25403d11abcd.js","sourcesContent":["'use strict';\n\nvar forEach = require('../../utils/array').forEach;\n\nvar map = require('../../utils/array').map;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var ResultSet = load(require('../../type/resultset/ResultSet'));\n  /**\n   * @constructor BlockNode\n   * @extends {Node}\n   * Holds a set with blocks\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n   *            An array with blocks, where a block is constructed as an Object\n   *            with properties block, which is a Node, and visible, which is\n   *            a boolean. The property visible is optional and is true by default\n   */\n\n  function BlockNode(blocks) {\n    if (!(this instanceof BlockNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input, copy blocks\n\n\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\n    this.blocks = blocks.map(function (block) {\n      var node = block && block.node;\n      var visible = block && block.visible !== undefined ? block.visible : true;\n      if (!type.isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\n      return {\n        node: node,\n        visible: visible\n      };\n    });\n  }\n\n  BlockNode.prototype = new Node();\n  BlockNode.prototype.type = 'BlockNode';\n  BlockNode.prototype.isBlockNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  BlockNode.prototype._compile = function (math, argNames) {\n    var evalBlocks = map(this.blocks, function (block) {\n      return {\n        eval: block.node._compile(math, argNames),\n        visible: block.visible\n      };\n    });\n    return function evalBlockNodes(scope, args, context) {\n      var results = [];\n      forEach(evalBlocks, function evalBlockNode(block) {\n        var result = block.eval(scope, args, context);\n\n        if (block.visible) {\n          results.push(result);\n        }\n      });\n      return new ResultSet(results);\n    };\n  };\n  /**\n   * Execute a callback for each of the child blocks of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  BlockNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.blocks.length; i++) {\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n    }\n  };\n  /**\n   * Create a new BlockNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {BlockNode} Returns a transformed copy of the node\n   */\n\n\n  BlockNode.prototype.map = function (callback) {\n    var blocks = [];\n\n    for (var i = 0; i < this.blocks.length; i++) {\n      var block = this.blocks[i];\n\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n\n      blocks[i] = {\n        node: node,\n        visible: block.visible\n      };\n    }\n\n    return new BlockNode(blocks);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {BlockNode}\n   */\n\n\n  BlockNode.prototype.clone = function () {\n    var blocks = this.blocks.map(function (block) {\n      return {\n        node: block.node,\n        visible: block.visible\n      };\n    });\n    return new BlockNode(blocks);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  BlockNode.prototype._toString = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toString(options) + (param.visible ? '' : ';');\n    }).join('\\n');\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  BlockNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'BlockNode',\n      blocks: this.blocks\n    };\n  };\n  /**\n   * Instantiate an BlockNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\n   *                       where mathjs is optional\n   * @returns {BlockNode}\n   */\n\n\n  BlockNode.fromJSON = function (json) {\n    return new BlockNode(json.blocks);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  BlockNode.prototype.toHTML = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n    }).join('<span class=\"math-separator\"><br /></span>');\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  BlockNode.prototype._toTex = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toTex(options) + (param.visible ? '' : ';');\n    }).join('\\\\;\\\\;\\n');\n  };\n\n  return BlockNode;\n}\n\nexports.name = 'BlockNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}