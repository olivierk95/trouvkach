{"version":3,"sources":["webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/RelationalNode.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/SymbolNode.js","webpack:////home/raph/home/raph/becode/trouvkach/node_modules/mathjs/lib/expression/node/UpdateNode.js"],"names":["operators","__webpack_require__","latex","escape","exports","name","path","factory","type","config","load","typed","Node","getSafeProperty","RelationalNode","conditionals","params","this","SyntaxError","Array","isArray","TypeError","length","prototype","isRelationalNode","_compile","math","argNames","self","compiled","map","p","scope","args","context","evalLhs","evalRhs","i","condFn","forEach","callback","_this","n","_this2","slice","_ifNode","clone","_toString","options","parenthesis","precedence","getPrecedence","paramStrings","index","paramPrecedence","toString","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","ret","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","hasOwnProperty","isValuelessUnit","Unit","SymbolNode","isSymbolNode","isUnit","Error","undef","symbol","toSymbol"],"mappings":"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","file":"js/b1fa8119c434915a56c1.js","sourcesContent":["'use strict';\n\nvar operators = require('../operators');\n\nvar latex = require('../../utils/latex');\n\nvar escape = require('../../utils/string').escape;\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n\n  var getSafeProperty = require('../../utils/customs').getSafeProperty;\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n\n\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = operators.getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      'equal': '==',\n      'unequal': '!=',\n      'smaller': '<',\n      'larger': '>',\n      'smallerEq': '<=',\n      'largerEq': '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = operators.getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      'equal': '==',\n      'unequal': '!=',\n      'smaller': '<',\n      'larger': '>',\n      'smallerEq': '<=',\n      'largerEq': '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = operators.getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latex.operators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}\n\nexports.name = 'RelationalNode';\nexports.path = 'expression.node';\nexports.factory = factory;","'use strict';\n\nvar latex = require('../../utils/latex');\n\nvar escape = require('../../utils/string').escape;\n\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory(type, config, load, typed, math) {\n  var Node = load(require('./Node'));\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n\n  function isValuelessUnit(name) {\n    return type.Unit ? type.Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (hasOwnProperty(argNames, name)) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : isUnit ? new type.Unit(null, name) : undef(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {} // nothing to do, we don't have childs\n\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n  ;\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  function undef(name) {\n    throw new Error('Undefined symbol ' + name);\n  }\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = latex.toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}\n\nexports.name = 'SymbolNode';\nexports.path = 'expression.node';\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\n\nexports.factory = factory;","'use strict';\n\nfunction factory(type, config, load, typed) {\n  /**\n   * @constructor UpdateNode\n   */\n  function UpdateNode() {\n    // TODO: deprecated since v3. Cleanup some day\n    throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');\n  }\n\n  return UpdateNode;\n}\n\nexports.name = 'UpdateNode';\nexports.path = 'expression.node';\nexports.factory = factory;"],"sourceRoot":""}